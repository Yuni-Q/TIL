
# 시스템을 연결하는 네트워크 구조

## 네트워크
- 서로 다른 장비가 데이터를 교환 할 때 기본적으로는 네트워크를 경유헤서 데이터를 송수신할 필요가 있다.
- 현재 네트워크 자체가 그 구조를 알지 못해도 사용할 수 있도록 돼 있다.
- 네트워크에서 발생하는 데이터 처리나 교환에는 다양한 구조가 존재한다.

## [기초] 계층 구조란?

### 게층 구조는 역할 분담
- 계층 구조에서는 데이터나 기능 호출 흐름에 따라 계층 간 역할이 나누어진다는 특징이 있다.
- 역할이 나누어져 있기 때문에 각 층은 자신이 담당하는 일만 책임을 지며, 다른 일은 다른 계층이 책임을 진다. 상호 연결돼 있는 계층들에서는 교환 방법, 즉 인터페이스만 정해 두면 된다.
- 각 층은 상호 간에 어떤 일을 하는지(어떤 기능을 가지고 있는지) 알고 있지만, 구체적으로 어떤 방식으로 처리하고 있는지는 알지 못한다. 즉, 은폐화 되어 있다.
- 계층 구조로 나눔으로써 계층 간에 영향을 주지 않고 독립적으로 동작 할 수 있다. 상호 간에 내부 처리를 은폐하고 있기 때문에 인터페이스만 바꾸지 않으면 각 계층이 내부적인 처리를 마음대로 바꾸어도 문제가 없다.
- 단점으로는 작업 효율을 희생해야 한다는 점을 들 수 있다. 컴퓨터에서는 작업 효율은 성능을 의미한다. 교대할 때의 작업 인계를 위한 오버헤드가 발생한다.

### 계층 모델의 대표적인 예 - OSI 7계층 모델
- OSI(Open Systems Interconnection)라는 통신 규격을 만들 때 고안된 것으로, OSI 통신 기능을 7개의 계층으로 나눈 것이다.
- OSI 자체는 현재 사용되고 있지 않지만, 이 계층 구조 개념은 다양한 분야에서공통적으로 참조할 수 있는 참조 모델로 현재도 사용되고 있다. 또한, 참조 모델이 되면서 엔지니어가 서로 공용할 수 있는 일종의 공통 언어 역할도 하고 있다.
 
#### OSI 참조 모델
- 애플리케이션 계층(application layer) : 애플리케이션 처리
- 프레젠테이션 계층(presentation layer) : 데이터 표현 방법
- 세션 계층(session layer) : 통신 시작과 종료 순서
- 전송 계층(transport layer) : 네트워크 통신관리
- 네트워크 계층(network layer) : 네트워크 통신 경로 선택
- 데이터 링크 계층(data linl layer) : 직접 접속돼 있는 기기 간 처리
- 물리 계층(physical layer) : 전기적인 접속

### 계층 구조는 네트워크 외에도 존재한다.
- 3계층형 시스템도 계층 구조다. 시스템 규모가 커질수록 역할별로 계층화하지 않으면 전체 구조가 복잡해져서 개발이 힘들어진다.
- 서버 한 대의 내부를 살펴봐도 역시 계층 구조로 되어 있다. 애플리케이션이나, OS, 하드웨어 조합도 계층 구조하고할 수있기 때문에 부분별로 선택할 수 있다. 휴대전화는 성능이 다양해서 OS나 하드웨어를 자유롭게 변셩할 수 있을 정도로 계층이 나누어져 있지 않다. 따라서 부분별로 선택하는 것이 어렵다.

## [기초]프로토콜이란?
- 프로토콜(protocol)이라는 영어 단어는 사전에 정해 놓은 순서를 의미한다.
- 컴퓨터 용어로는 특히 통신 프로토콜이라는 이름으로 자주 등장하며, 컴퓨터가 서로 소통하기 위해 정한 규약을 가리킨다.

### 컴퓨터에서는 프로토콜이 필수 불가결이다.
- 컴퓨터의 거의 모든 곳에 프로토콜이 사용된다. 떨어진 곳에 있는 두 개의 장비는 사전에 절차를 정해 두지 않으면 서로 통신할 수 없다. 그래서 네트워크와 프로토콜은 뗼래야 뗼 수 없는 관계다.
- 프로토콜은 같은 계층 간의 약속이라고 할 수 있다.
- 네트워크 업계에서는 공통 프로토콜 선정을 위한 IEEEsk IETF 같은 표준화 단체가 존재한다.

#### 표준화 단체에 대해서
- IEEE는 전지전자 기수루 학회이지만, 전기통신을 사용한 프로토콜 표준화 활동도 하고 있다. 그중 우리가 자주 접하는 것은 무선 LAN 프로토콜이다. IEEE 802.11n 대응이라고 쓰여진 무선 LAN 공유기. 이것이 IEEE가 표준화한 규격 중 하나다.
- IETF는 인터넷에서 사용되는 다양한 기술을 표준화한 단체다. 이 단체는 꽤 열려 있는 단체로, 다양한 제조사나 대학 관계자는 물론 통신 전문가들도 참여하고 있으며, 이들이 협의를 거쳐서 표준 규격을 정하고 있다.
- IETF에서 정해진 것은 RFC라는 이름의 문서로 나와 있다. 이것은 Request for Comment(주석 제안)의 약자로, 이것을 통해서도 인터넷 기술이 공개화되고 있다.
- 표준화된 것 중에는 이미 다른 규격이 보급돼 있어서 더는 사용되지 않는 것도 있다. 대표적인 예가 OSI와 이더넷이다.

### 프로토콜은 서버 내부에도 존재한다.
- USB 프로토콜이 존재한다.
- 저장소에서 데이터를 꺼낼 때도 프로토콜이 정해져 있다. 대표적으로 SCSI 프롵토콜이 있다.
- CPU 안에도 프로토콜이 존재한다. 코어들이 서로 통신을 하기 위한 프로토콜도 있다.

## TCP/IP를 이용하고 있는 현재의 네트워크
- 인터넷을 포함해서 현재 네트워크를 지탱하는 것은 TCP/IP 및 관련 프로토콜이다.

### 인터넷의 발전과 TCP/IP 프로토콜
- 인터넷의 시초는 1969년에 미국 국방성의 연구로부터 시작된다. 이때 구축된 실험 네트워크는 ARPANET(아파넷)이라고 불리는 것이다.
- 1980년대까지는 아파넷 외에도 다른 네트워크도 운영되고 있었으며, 이들이 상호간에 접속할 수 있게 됐다. 이 시기에는 네트워크 제조사별로 수많은 독자 프로토콜을 사용하고 있어서 상호 접속에 문제가 있었다. 이런 이유로 국제 규격의 프로토콜을 만들자는 움직임이 시작됐다. 이것이 1982년에 제정된 OSI라는 프로토콜이다.
- 이때는 이미 1970년대에 고안 된 TCP나 IP 프로토콜이 보급되고 있었으며, OSI 자체도 복잡한 사양 때문에 상호 접속성에 문제가 있었다. 국제 규격으로 OSI 사용을 권장했지만, 결국 OSI는 사장되고 말았다.
- 최종적으로는 TCP/IP 프로토콜 슈트를 이용하는 네트워크가 대다수가 됐고, TCP/IP가 인터넷의 사실상 표준이 된 것이다.
- 다양한 네트워크가 상호 산에 협력하면서 인터넷이 발전했고, 그 가운데 TCP/IP가 발전돼 온 것이다.

### TCP/IP 계층 구조
- TCP/IP 슈트는 TCP와 IP의 두 가지 프로토콜을 주축으로 한 프로토콜 집합이다. 주축이라고 하지만 TCP를 반드시 사용해야 하는 것은 아니며, IP는 통신 상대 지정 시에 IP 주소를 이용하기 때문에 반드시 필요하다고 할 수 있다.
- TCP/IP에서는 반드시 이 7계층이 분명하게 나누어지는 것은 아니다. TCP/IP 4계층 모델 등으로 불리며, OSI 7계층의 1~2계층을 모아서 링크 계층, 5~7계층을 모아서 애플리케이션으로 취급하기도 한다.
- HTTP 통신 데이터를 상대방에게 보내기 위해서 TCP에 데이터를 건네지만, 여기서부터 이너넷 계층까지는 OS 커널이 담당한다. 커널 내에서 TCP, IP, 이더넷을 담당하는 기능이 필요한 정보를 데이터에 부여해서 최종적으로 이더넷 프레임이 생성된다. 이것이 NIC에 전달돼서 이더넷 케이블 등을 통해 인접 노드를 경유해서 최종 위치까지 전달된다.
- 계층 구조로 나누어져 있어서 통신하고 싶은 애플리케이션은 독자적으로 통신 구조를 만들 필요 없이 TCP/IP에게 위임할 수 있다.
- 각 계층을 담당하고 있는 것도 쉽게 변경할 수 있다. (TCP 대신에 신뢰성이 낮지만 간단하게 데이터를 송수신할 수 있는 UDP를 사용하거나, 유선이 아닌 무선으로 통신을 하는 등 용도에 맞게 변경할 수 있는 점도 계층 구조의 장점이다.)
- TCP/IP는 4계층이라고 하짐ㄴ, 실제 현장에서 계층을 숫자로 부를 때는 OSI 참조 모델의 7계층 방식으로 부르는 경우가 많다. 링크 계층, 즉 이더넷 계층을 레이어 2나 L2로 IP 계층을 레이어 3나 L3, 전송 계층(TCP 계층) 레이어 4나 L4라고 부른다.
- 각 계층별 처리를 하는 네트워크 스위치를 L2 스위치나, L3 스위치라고 부르는 경우도 있다.
- L5, L6, L7을 모아서 애플이케이션 게층으로 취급하기 때문에 TCP/IP 이야기를 할 때는 거의 등장하지 않는다.

## [레이어]애플리케이션 계층의 프로토콜 HTTP
- 애플리케이션이 사용하는 프로토콜을 모두 애플리케이션 계층 프로토콜이라 부른다.
- 애플리케이션 계층 프로토콜은 자신이 통신을 하는 것이 아니라 통신 자체는 모두 OS, 즉 TCP/IP에 맡긴다.
- HTTP 사양은 RFC2616에서 정하고 있다.

### 요청과 응답의 구체적인 내용

#### 요청(요구)
- 요청 : 서버에 대한 요구 명령, 대상 데이터를 지정한다.
- 메세지 헤더 : 브라우저에 상세한 정보를 전달한다.(표시 대응 브라우저, 데이터 형식, 접속 방식 등)
- 메세지 바디 : 브라우저에 입력한 내용이 포함된다.
- 요청 시 중요한 것은 서버에 던지는 명령이다. GET은 파일 요구이고, POST는 데이터를 전송한다는 의미다.
- 헤더 부분에는 다양한 부가 정보가 들어가면 세밀한 제어를 위해 사용한다. User-Agent는 브라우저 식별 정보를 가지고 있으며, Cookie는 세션 식별자로 사용된다.

#### 응답(전송)
- 상태 : 결과가 정상인지 에러가 있는지 등의 상태 정보를 가진다.
- 메시지 헤더 : 브라우저에 상세한 정보를 전달한다.(표시 대응 브라우저, 데이터 형식, 접속 방식 등)
- 메시지 바디 : HTML 데이터 등 실제 데이터가 저장된다.

### -
- HTTP가 그 하위 계층인 IP나 유선을 통해 명령을 보내거나 통신 제어를 하지는 않는다. 이 때문에 HTTP 요청은 여러 가지 명령만으로 구성돼서 매우 간단한 구조라는 것을 알 수 있다.

### 애플리케이션 프로토콜은 사용자 공간에서 처리
- 애플리케이션 자체가 통신 구조를 가지지 않고서도 원격지에 있는 서버 애플리케이션과 통신할 수 있다.(소켓같은 것을 이용해서)
- 애플리케이션 프로토콜으 기본적으로 애플리케이션 프로세스 내부에서 모두 구현된다.

### 소켓 이하는 커널 공간에서 처리
- 의뢰 방법은 시스템 콜이다. 이때 접속 대상 서버의 IP 주소와 TCP 포트의 두 가지 정보가 필요하다. 이 두가지 정보는 각각 IP 도착 위치와 TCP 도착 위치다.
- 의뢰를 받은 커널은 소켓을 만들어 준다. 소켓을 만든 것뿐으로 데이터를 보내기 위해 구멍을 연 것이다.
- TCP를 사용하기 때문에 TCP를 사용한다는 것과 IP 주소 및 포트 번호 정보를 시스템 콜 경유로 커널에 전달하면, 접속 대상 서버와의 연결이 생성된다. 이때 상대방 서버에서도 소켓이 만들어지며, 상대 서버와의 사이에 가상 경로(버추얼 서킷)가 생성 된다.
- 프로세스 관점에서는 소캣으라니느 구멍에 넣은(기록한) 데이터가 가상 경로를 통해서 상대 통신 소켓 구멍으로 나오는 것이다. 매우 간단한 것 같지만, 커널이 열심히 여러 처리를 해 주고 있다.

#### 한번 잡으면 놓아주지 않는다
- HTTP는 한 번 요청/응답 관계가 끝나면 세션을 종료한다.
- 하위 계층인 3way-handshaking 등의 오버헤드가 발생해서 전체 화면의 응답에 영향을 끼치게 된다.
- 세션을 남겨 두는 기능을 Keep-Alive라고 한다.
- 웹 서버 측에 세션 잔존 시간 등을 설정한다.
- 프로토콜 헤더의 Connection에 keep-alive가 있으면 이 기능이 켜진 것이고, close라고 쓰여 있으면 꺼진 것이다.
- 무의미하게 세션을 길게 유지하면 HTTP 프로세스/응답이 세션을 놓지 못해서 신규 요청을 접수할 수 없게 되니 주의가 필요하다.

## [레이어4] 전송 계층 프로토콜 TCP
- 소케에 기록된 애플리케이션 데이터는 커널 내에서 통신 대상에게 전달하기 위한 준비를 시작한다. 제일 먼저 임무를 수행하는 것이 전송 계층 프로토콜인 TCP다. TCP(Transmission Control Protocol)는 명칭 그대로 전송을 제어하는 프로토콜로, 신뢰도가 높은 데이터 전송을 가리킨다.

### TCP의 역할
- 애플리케이션이 보내 데이터를 그 형태 그대로 상대방에게 확실하게 전달하는 것이다. 단, 가능한 주변에는 민폐를 끼치지 않는다. 원래 신뢰도가 낮은 인터넷에서 사용하기 위해 만들어졌기 떄문에 이런 역할이 주어졌다고 할 수 있다.
- TCP가 담당하는ㄱ ㅓㅅ은 어디까지나 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때로, 상대 서버까지 전송하는 부분은 하위 계층인 IP에 모두 위임한다. 물론 TCP에 의존하지 않고 IP만으로도 통신 할 수 있지만, IP에는 데이터가 상대방에게 확실히 전달됐는지 확인하는기능이나 도착한 순서를 확인하는 기능 등이 없다.

#### TCP 중요한 기능
- 포트 번호를 이용해서 데이터 전송
- 연결 생성
- 데이터 보증과 재전송 제어
- 호름 제어와 폭주 제어

#### 인터넷의 주인은 누구?
- 인터넷에서는 양자 간(end-to-end) 신뢰성을 담보한 TCP 같은 구조가 필요하다.
- 인터넷은 모두가 공유하는 것으로 공평성도 매우 중요하다.
- 공평성과 공평성에 대한 정신을 강조하고 있다.

### 커널 공간의 TCP 처리 흐름
- 소켓에 기록된 애플리케이션 데이터는 소켓의 큐를 경유해서 소켓 버퍼라 불리는 메뫼 영역에서 처리 된다. 소켓 버퍼는 소켓별로 준비된 전용 메모리 영역으로, 이후 계속되는 IP나 이더넷까지의 일련의 처리도 소켓 버퍼 내에서 이루어진다.
- TCP는 세그먼트(segment)라고 하는 단위(TCP 패킷이라 불리는 경우도 있지만 정의상 적합하지 않다)로 데이터를 관리하고 있다. 이 떄문에 애플리케이션 데이터에 TCP 헤더를 붙여서 TCP 세그먼트를 작성한다.
- 헤더에는 도착 지점 포트 번호를 포함해서 TCP 기능을 표현하기 위한 수많은 정보를 기록된다.
- 하나의 TCP 세그먼트로 전송할 수 있는 최대 데이터 크기를 MMS(Maximum Segment Size)라고 한다.
- 최종적으로 링크 계층을 사용해서 데이터를 전송하기 때문에 MMS는 링크 계층에서 전송 할 수 있는 최대 크기에 의존하며, 환경이나 설정에 따라 달라진다.
- 링크 계층의 최대 데이터 크기를 MTU(Maximum Transger Unit)라고 한다.

### 포트 번호를 이요한 데이터 전송
- TCP 포트 번호는 0~65535 까지의 숫자를 이용한다.

## 연결 생성
- TCP는 소켓 생성할 때도 중요한 역할을 한다.
- TCP는 연결형 프로토콜로, 연결이라 불리는 가상 경로(버추얼 서킷)를 생성한다. 이것을 TCP가 통신을 시작하면서 통신 상대에게 지금부터 통신한다라고 연락한 후 OK 사인을 받으면 그때 처음 생성된다. 물론, 통신을 받으려면 통신을 받는 애플리케이션 측(서버)이 미리 통신 준비를 하고 있어야 한다.
- 서버 프로세스는 OS에게 포트번호 --에게 통신 의뢰가 오면 나에게 연결해라고 부탁한다. 이렇게 서버 측 소켓은 자신이 지정한 포트 번호에 통신이 오는지를 기다렸다가 받는다. 이 상태를 포트를 리슨(LISTSTEN)하고 있다고 한다.

1. 통신 상대인 서버 측 OS에게 가상 경로를 열도록 의뢰한다.
1. 서버 측에서는 리슨하고 있는 포트 번호로 통신 요구가 온다. 서버는 문제가 없으면 열어도 된다는 응답을 한다.
1. 클라이언트 측도 확인 했다는 메세지를 보내며, 이때 처음으로 통신용 가상 경로가 연린다.
> 이 세번의 대화를 TCP/IP의 3-way handshaking 이라고 한다.

- TCP 통신을 시작할 때 상대 서버에 포트 번호와 연결을 열어 달라고 부탁만 할 뿐 다른 특별한 일은 하지 않는다. 데이터 전송 자체도 IP에 위임하기 때문에 실제 물리적인 경로가 막히거나 통신 상대 서버가 갑작스런 자앵로 전원이 꺼져도 가상적인 경로인 TCP 연결이 끊어지진 않는다. 이런 상태에서는 데이터가 전달되진 않지만, 기본적으로 애플리케이션이 OS에게 연결 절단 의로를 하거나 통신 대상이 에러를 보내오지 않는 이상 TCP 연결 자체가 유지 되기 때문에 주의가 필요하다.
- 통신을 받는 서버 측은 미리 지정한 포트 번호를 리슨하지만, 통신을 시작하는 클라이언트 측에서는 보통 자신이 사용하기 위한 포트번호를 지정할 수 없다. 이때는 클라이언트 측에서 사용하지 않는 포트 번호가 자동적으로 OS에 의해 할당된다.

### 데이터 보증과 재전송 제어
- 연결이 생성된 후에야 데이터 송수신이 시작된다.
- TCP에는 데이터가 확실히 전달되도록 보증하는 기능이 있다.
- 데이터 손실 방지 기능
  - 확인 응답과 재전송에 의해 구현된다.
  - 수신 측에 TCP 세그먼트가 도착하면 수신 측은 송신 측에게 도착했다는 것을 알린다. 이떄 반환하는 것을 ACK라고 하며, TCP 헤더에 ACK 관련 정보를 넣는 TCP 세그먼트를 반환한다. 송신 측은 ACK가 동아온느 것을 보고 전송한 세그먼트가 무사히 도착했다는 것을 알 수 있다. ACK가 돌아오지 않으면 전송한 TCP 세그먼트가 어떤 이유로 사라졌을 가능성이 있다. 이 때문에 언제든지 재전송이 가능하도록 전송이 끝난 TCP 세그먼트라도 ACK가 돌아오기까지는 소켓 버퍼에 남겨 둘 필요가 있다.
- 데이터 순서를 보증하는 구조
  - 각 TCP 세그먼트에 시퀀스(sequence) 번호라고 하는 숫자를 붙여서 구현한다. 시퀀스 번호도 TCP 헤더에 기록되며, 해당 TCP 세그먼트가 가지고 있는 데이터가 전송 데이터 전체 중 몇 바이트째부터 시작하는 부분인지를 가리키고 있다.
  - 순차적인 조합을 위해 수신 측은 ACK를 반환할 때 다음에 필요한 TCP 세그먼트의 시퀀스 번호도 ACK 번호로 전달한다.
- ACK가 오지 않으면 재전송한다고 말햇지만, 어느 시점에 재전송을 하는 것인가?
  - 첫 번째는 타임아웃이다. 
  - 중복 ACK(Duplicate ACK)
    - 1회 중복 ACK로 바로 재전송하맂 않고 3회까지 기다리는 것은 가금 해당 세그먼트만 경로 도중에 지연돼서 도착 순서가 바뀔 수 있기 때문이다.
  - SACK(Selective ACK)
    - 더 상세한 ACK를 반환할 수 있다.
    - 이미 도착했다는 것을 정보로 전달할 수 있다. 이를 통해 송신 측은 도착하지 않은 TCP 세그먼트만 선택해서 재전송할 수 있게 된다.

### 흐름 제어와 폭주 제어
- 데이터를 보내고 ACK를 기다리는 처리를 반복하다 보면 시간이 많이 걸린다.
- 동기로 통신을 하면 효율이 나쁘기 때문에 ACK를 기다리지않고 전송하는 것이 좋다.
- ACK를 기다리지 않고 전송 가능한 데이터 크기를 윈도우 크기라고 한다.
- 윈도우에는 수신 측의 수신 윈도우와 송신 측의 폭주(송신) 윈도우, 두 가지가 있다.
  - 기본적으로는 수신 측이 폭주 윈도우 크기를 조정래서 폭주 윈도우와 수신 윈도우 중 작은 쪽을 송신 윈도우로 채택하며, 이 버위 내에서는 ACK를 기다리지 않고 전송 한다. ACK가 오면 해당 TCP 세그먼트는 재전송할 필요가 없기 때문에 송신용 소켓 버퍼에서 삭제하고 송신 윈도우를 다음으로 이동한다. 이와 같이 윈도우를 이동해 가는 방식을 슬라이딩 윈도우(sliding window)라고 한다. 수신 측은 수신용 소켓 버퍼가 넘쳐서 더 이상 수신이 불가능하게 되면 수신 윈도우 크기를 작게 만들고 이 사실을 송신 측에 알린다. 송신 측은 윈도우 크기 이상의 데이터는 ACK 없이 보낼 수 없게 된다. 이것이 TCP 흐름제어(유량 제어)다.
  - 송신 측 윈도우 크기는 네트워크 폭주 상태(혼잡 상태)에 맞추어 변형 시키기 때문에 폭주 윈도우라고 부른다. 네트워크가 혼잡하면 폭주 윈도우 크기를 작게 해서 전송 데이터 양을 줄인다. 이거이 폭주 제어다. TCP는 주변에 영향을 주지 않도록 자중하는 프로토콜이다. 폭주 윈도우 크기는 통신 시작 시에 1세그먼트에 설정된다. 통신이 문제 없이 시작돼서 수신 측에 도착하면 ACK 반황 시마다 폭주 윈도우 크기를 2세그먼트, 4세그먼트 식으로 지수 함수적으로 늘려나간다. 이 방식을 슬로 스타트(slow start)라고 한다. 어느 정도 크기까지 증가하면 기 이후는 1세그먼트씩 크기를 늘려나간다. 송신 중인 세그먼트가 실패하면, 즉 폭주를 감지하면 폭주 윈도우 크기를 작게해서 송신량을 줄인다. 그리고 다시 폭주 윈도우 크기를 크게 만든다. 이 벼놔를 반복함으로써 주변에 민폐를 끼치지 않고 자신의 전송 속도가 최대가 되도록 조정할 수 있다.
- 송신 측은 받는 수신 윈도우 크기와 폭주 윈도우 크기 중 작은 쪽에 맞추어 전송량을 제어한다. 이와 같은 형식으로 흐름 제어와 폭주 제어가 이루어진다.

## [레이어3]네트워크 계층의 프로토콜 IP
- TCP 세그먼트가 만들어지면 다음은 IP 처리가 시작 된다.
- IP는 Internet Protocol의 약자로, 명칭 그대로 오늘날 인터넷에서 사용되고 있는 가장 중요한 프로토콜이다. IP에는 프로토콜 종류에 따라 다른 버전이 있으며, 현재 폭넓게 사용되고 있는 것은 IPv4라 불리는 것이다. 최근에는 새로운 버전인 IPv6도 사용되고 있지만, 기업형 시스템 등에서는 대부분 IPv4를 사용하고 있다. 
- IPv4와 IPv6는 명칭은 비슷하지만 기본적으로 상호 호환성이 없으면 전혀 다른 종류의 프로토콜이라 보는 것이 맞다. 

### IP의 역할
- 지정한 대상 서버까지 전달받은 데이터를 전해주는 것
- IP에서는 반드시 전달된다는 것을 보장하지 않는다.

#### 중요한 기능
- IP 주소를 이용해서 최종 목적지에 데이터 전송
- 라우팅(routing)

### 커널 공간의 IP 처리 흐름
- 생성된 TCP 세그먼트는 그대로 IP 처리에 돌입한다.
- IP 계층에서는 최종 목적지가 적힌 IP 헤더를 TCP 세그먼트에 추가해서 IP 패킷을 생성한다.
  - IP 사양을 정하고 있는 RFC791에서는 IP 패킷이 아닌 IP 데이터그램(datagram)이라는 명칭으로 정의하고 있다. 일반적으로 IP 패킷이라 부르는 경우가 많기 때문에 이 책에서도 IP 패킷이라 기재하고 있다.
- 헤더에는 목적지 IP 주소 외에 저장하고 있는 데이터 길이, 프로토콜 종류(TCP 등), 헤더 체크섬 등이 기록된다.
- 기본적으로 IP 패킷은 TCP에 의해 링크 계층에서 최대 전송 크기로 분할돼 있기 때문에 여기에 IP 헤더만 추가한 것이다.
  - 사실은 TCP 세그먼트 분할 기능처럼 IP에도 패킷 분할 기능이 있다. IP에 의한 패킷 분할과 재결합 기능을 각각 IP 조각화(fragmentation) 및 재결합(reassemble)이라고 한다.
  - 참고로, TCP 헤더는 20바이트, IP 헤더(IPv4 헤더)도 기본적으로 20바이트이기 때문에 이 시점에 첫 번째 IP 패킷은 1500바이트로 커져 버린다.

### IP 주소로 이용한 최종 목적지로의 데이터 전송
- IP에서는 최종 목적지 서버까지 복수의 네트워크를 경유해서 데이터를 전송한다. 이때 이용되는 것이 대상 서버를 나타내는 IP 주소이다.
- IP 주소는 32비트로 표현된 숫자 집합이다. 8비트 단위로 마침표를 찍어서 표현하는 것을 자주 볼 수 있다.
- IP 주소는 네트워크부와 호스트부로 나뉜다.
  - 네트워크부는 어떤 네트워크인지를 가리키고, 호스트부는 해당 네트워크 내에 있는 컴퓨터(소유자)를 가리킨다.
  - IP 주소에서 어디까지가 네트워크부인지 표시하기 위해서 '/24'와 같은 CIDR(사이더) 표기를 사용한다. 또는 서브넷 마스크(subnet mask)라고 해서 255.255.255.0과 같이 표현하기도 한다.
- 같은 네트워크 내 컴퓨터의 IP 주소는 네트워크부를 동일 값으로 설정해야 한다.
- IP 주소 중 호스트부의 비트가 모두 0인 것을 네트워크 주소, 모두 1인 것을 브로드캐스트(broadcast)주소라고 한다. 이것은 호스트에 할당해서는 안 되는 특별한 IP 주소다.

#### IP 주소 고갈과 IPv6
- IP 주소가 고갈 된다.
- IPv4는 주소를 21비트로 표현하는데 43억 개의 IP 주소를 만들 수 있다.
- IP 주소도 32비트에서 128비트로 늘어나게 되었다. 이것이 IPv6이다. 이진수이기 때문에 알기 어렵지만, 이진수로 32자리가 128자리가 된 것이다.
- IPv6와 IP4는 호환성을 가지고 있지 않다.
- TCP 위의 HTTP는 두 버전의 IP에 모두 대응해서 동작하기 때문에 사용자는 IPv4로 통신을 하고 있는지 IPv6로 통신하고 있는지 의식할 필요가 없다. 이것도 계층 구조의 장점이라 할 수 있다.

### 라우팅
- 송신 및 수신 시 서버 내에서만 처리되는 TCP와 달리 IP는 경로 도중에 다양한 처리가 이루어 진다. 라우팅(routing)도 그중 하나다.
- IP 주소를 이용해 대상 서버를 지정할 수 있다. 다른 네트워크에 있는 경우 라우터에 전송을 부탁해야 한다.
- IP 패킷을 받은 라우터는 해당 IP 패키의 헤더에서 목적지를 확인해서 어디로 보내야 할지를 확인한다. 이때 사용되는 것이 라우팅 테이블(경로표)이라는 것이다. 서버나 라우터는 자신이 알고 있는 목적지 정보를 라우팅 테이블이라 하는 형태로 목록화 한다. 라우팅 테이블은 사람이 직접 입력한 경로 정보나 자신의 서버에 설정된 IP 주소로 파악할 수 있는 정보 등 다양한 정보를 이용해서 구성된다.
- 외부와 접속하는 네트워크는 기본 게이트웨이(default gateway)라는 라우터가 설치돼 있다.
- IP를 이용한 전송은 주변을 신뢰해야만 성립되는 것이다. 특히 인터넷 통신에서는 자신이 관리하지 않는 네트워크를 다수 경유해야지만 패킷이 상대 서버에 도달한다.
- 네트워크에서 패캣이 계속 순환하는 것을 방지하기 위해 IP 헤더는 TTL(Time to Live)이라는 생존 시간 정보를 가지고 있다.

#### IP 헤더에서 체크섬이 사라진 날
- IPv4와 IPv6의 가장 큰 차이는 주소 공간이지만 이외에도 몇 가지 차이가 있다. 그중 하나가 체크섬 유무다.
- IPv6부터는 체크섬이 깔끔하게 제외됐다. 이외에도 가변 길이가 허용되지 않고 40바이트 고정 길이를 사용한느 등 라우터가 처리해야 할 부분을 줄이고 있다.

## [레이어2]데이터 링크 계층의 프로토콜 이더넷
- IP 패킷이 만들어지면 계속해서 링크 계층의 처리가 시작된다.
- 링크 계층에서 사용되는 대표적인 프로토콜은 이더넷(ethernet)이다. 대표적이리고 말한 것은 이더넷 이외에도 프로토콜이 몇 가지 더 있기 때문이다.

### 이더넷의 역할
- 동일 네트워크 내의 네트워크 장비까지 전달받은 데이터를 운반한다.
- TCP/IP 4계층 모델에서는 물리 계층과 함께 하나의 층으로 취급하듯이, 이더넷이란 링크계층 프로토콜은 이른바 OSI 7계층 모델의 물리 계층과 밀접한 관계가 있다. 이더넷은 케이블 통신에서 사용되기 때문에 이더넷 프레임은 전기 신호로 전송된다. 이 때문에 이더넷 프로토콜에는 전기 신호의 특성과 관련된 제어 기능 등 다양한 기능이 포함돼 있다.
- IP는 IP 주소를 사용해서 여러 네트워크를 거쳐 데이터를 전송할 수 있지만, 이더넷은 동일 네트워크 내, 즉 자신이 포함된 링크 내에서만 데이터를 전송할 수 있다. 이때 사용되는 주소가 MAC(맥) 주소다.

### 커널 공간의 이더넷 처리 흐름
- IP 계층에서 라우팅 테이블을 확인하기 어렵기 때문에 어떤 링크(NIC)가 패킷을 보낼지는 정해져 있다. 최종적인 통신 상태가 동일 네트워크 내에 있으면 해당 서버에 직접 전송하지만, 다른 네트워크에 있으면 기본 게이트웨이에 패킷을 보내야 한다. 여기서 MAC 주소라 불리는 링크 계층 주소를 사용해서 첫 번째 목적지로 보낸다.
- 이더넷 헤더에는 이 MAC 주소를 목적지로 기입한다. 단, 여기에 적히는 것은 동일 링크 내에 있는 장비의 MAC 주소다. IP 주소에 라우팅 테이블이 있었던 것처럼 MAC 주소에는 ARP 테이블(MAC 테이블)이라 불리는 표가 있다. 동일 링크 내의 노드에 대해서 IP 주소와 MAC 주소의 대응 관계를 기록한 표다.
- 이렇게 인접한 장비의 MAC 주소를 헤더에 기록한 후 최종적으로는 OS가 버스를 통해 NIC에게 전달한다. NIC는 이것을 다시 네트워크에 전송한다.
- 이더넷 등 링크 층에서 하나의 프레임으로 전송할 수 있는 최대 크기를 MTU(Maximum Transfer Unit)라고 한다. 
- MSS는 링크 계층의 크기에 따라 변동된다고 했는데, 바로 이 MTU 크기에 의해 변동되는 것이다. MTU에서 IP 및 TCP 헤더 크기를 뺀 것이 TCP의 MSS다.
- IP 패킷의 최대 크기는(IP 헤더 + TCP 헤더 + MSS)이다.
- IP 패킷의 최대 크기가 MTU보다 작은 경우 하나의 패킷으로 전달할 수 있는 크기기가 작기 때문에 큰 데이터를 전달하기 위해 통신 횟수가 늘어나 버린다. 그로인해 통신이 느려진다.
- IP 패킷의 최대 크기가 MTU보다 큰 경우 TCP 계층에서 여러 세그먼트로 분할된 후 다시 IP 계층에서도 분할이 이루어진다. 이것은 이중 작업으로 불필요한 처리 시간이 늘어난다.
- MTU는 네티워크 상의 모든 경로에서 동일한 것이 아니다. 경로 도중에 MTU가 작아서 1패킷이 MTU에 들어가지 않으면 필요에 따라 경로 도중에 네트워크 장비에서 패킷이 분할된다. 경로 도중에서의 패킷 분할은 설정이나 환경에 따라서는 실시되지 않는 경우도 있는데, 이 경우에는 안타깝게도 패킷이 파기된다. 이와 같은 사태를 방지하기 위해 송신 측이 Path MTU Discovery라는 방법을 이용해서 송신 전에 경로 상의 최소 MTU를 조사해서 미리 세그먼트 크기를 조정 할 수 있다.
- 경로에서 패킷 분할을 하는 것은 IPv4의 기능으로 IPv6에서는 경로 상의 패킷 분할 기능이 폐지 됐다.

### 동일 네트워크 내의 데이터 전송
- MAC 주소는 네트워크 통신을 하는 하드웨어에 할당된 주소로, 원칙적으로는 세상에 있는 모든 장비가 고유한 물리 주소를 가지고 있다.
  - 실제로는 중복된 MAC 주소가 존재하며 MAC 주소를 변경 가능한 네트워크 장비도 있다. 하지만 MAC 주소를 사용해서 통신을 하는 동일 링크 내에서는 고의적으로 설정을 변경하지 않는 이상 MAC 주소가 서로 충돌하는 경우는 없다.
- MAC 주소는 48 비트로 표현한다. 보통은 16 진수로 표기한다.
- 서버 등이 보낸 이더넷 프레임이 L2 스위치에 도착하면 프레임을 받은 L2 스위치는 MAC 주소를 보면서 적절한 포트에서 프레임을 꺼낸다. 하지만 다른 네트워크(L3 스위치나 라우터)를 거치는 경우는 MAC 주소를 사용한 통신이 불가능하다.
- IP를 이용한 브로드캐스트 주소 통신은 이더넷 상에서의 브로드캐스트 통신으로 전송된다. MAC 주소 FF-FF-FF-FF-FF-FF 이더넷의 브로드캐스트에 해당한다. 물론, 브로드캐스트를 이용한 통신도 ㅌ다른 네트워크를 거쳐서 전송할 수 없기 때문에 하나의 네트워크를 브로드캐스트 도메인이라고도 부른다.

### VLAN
- 네트워크를 구축할 때는 통신이 도달하는 범위를 생각해야 한다. 특히 브로드캐스트 통신 등 전체에 데이터를 전송하는 경우는 불필요한 트래픽을 증가 시킨다. 즉, 브로드캐스트 도메인을 고려해서 네트워크를 적절하게 분할하는 것이 필요하다.
- 네트워크 범위는 네트워크 스위치의 물리 구성에 의해 크게 좌우되기 때문에 유연하게 구성하기가 어렵다. 따라서 물리 구성에 좌우되지 않고 설정만으로 네트워크를 나눌 수 있는 구조가 필요하다. 실제 자주 사용되는 VLAN(Virtual LAN)이 있다.
- VLAN은 물리 구성에 의존하지 않고 가성적인 네트워크를 나누는 구조다. 가상적으로 나눈 네트워크는 VLAN ID라 불리는 숫자로 관리한다. VLAN에는 몇가지 종류가 있지만 자주 사용되는 것은 태그 VLAN이다.
- 태그 VLAN은 IEEE802.1Q로 정의된 사양이다. 이더넷 프레임에 해당 프레임이 소속된 VLAN ID의 태그를 붙여서 하나의 이더넷 케이블 내에서 다른 VLAN에 속하는 프레임을 전송할 수 있게 돼서, 물리적으로 떨어져 있는 네트워크 스위치라도 동일 네트워크에 참가시키는 것이 가능하다. 네트워크 스위치의 포트별로 어떤 VLAN ID와 연결할지를 설정해서 하나의 L2 스위치라도 여러 네트워크를 다룰수 있다.
- 태그 VLAN이 설정된 스위치는 다른 스위치에 프레임을 전송할 때 해당 프레임이 속한 VLAN을 가맄키는 태그를 붙여서 전송한다. 목적지 네트워크에 도착하면 태그를 제거한 후 목적지 컴퓨터로 보낸다.
- 설령 같은 L2 접속된 컴퓨터들이라도 각각 다른 VLAN ID에 설정된 포트를 사용하고 있는 경우는 별도의 L3 스위치나 라우터 없이는 서로 통신 할 수 없다. 같은 L2 스위치에 접속돼 있음에도 불구하고 통신할 수 없다는 것이 이상하게 생각될 수도 있는데, IP와 이더넷 구조를 생각하면 당연한 원리다.

## TCP/IP를 이용한 통신 이후

### 네트워크 스위치 중계 처리

### 최종 목적지 수신 확인
- 전송된 이더넷 프레임은 제일 먼저 서버와 인접하고 있는 L2 스위치에 도착한다.
- L2 스위치는 명칭 그대로 레어이 2에서 처리하는 스위치다.
- 레이어 2는 이더넷 계층이기 때문에 이더넷 헤더를 보고서 대상 MAC 주소를 확인한 후 적절한 포트를 통해 프레임을 전송한다.
- L2 스위치도 컴퓨터이기 때문에 내부에는 스위치용 OS가 동작하고 있다.
  - OS에서는 커널 내에서 프레임을 처리하고 있다.
  - 네트워크 스위치는 일반 서버와 달리 프레임이나 패킷 처리에 특화된 ASIC라 하는 회로를 가지고 있어서 하드웨어 처리만으로 빠르게 프레임이나 패킷을 전송할 수 있다.
- 최종 목적지가 동일 네트워크 서버 일때는 L2 스위치가 하나만 있지만, 따른 네트워크에 전송하는 경우는 L3 스위치나 라우터가 있을 수 있다.
- L2 스위치에서는 이더넷 헤더를 보고 목적지를 정하지만, L3 스위치나 라우터에서는 IP 헤더까지 확인해서 목적지를 결정한다.

### 최종 목적지 수신 확인
- L2 스위치나 L3 스위치를 경유해서 최종 목적지인 서버에 이더넷 프레임이 도착한다.
- NIC로 프레임이 도착하면 일단은 NIC 수신 큐에 저장해서 OS 끼어들기나 OS 폴링을 이용해서 커널 내에 프레임을 복사한다.
- 이더넷 헤더와 푸터를 제거하고 IP 패킷을 꺼낸다. 여기서 IP 주소를 확인해서 자신에게 보낸 패킷이 맞는지 확인한다.
- 자신에게 보낸 패킷이 맞다면 IP 헤더를 제거하고 TCP 세그먼트를 꺼낸다.
- TCP 포트 번호를 확인해서 포트 번호에 대응하는 소켓에 대이터를 전달한다. TCP는 데이터 보증을 하기 때문에 없어진 세그먼트가 있어서는 안 되고 순서가 틀려도 안 된다. 이 때문에 데이터 재구성을 위해 필요한 세그먼트가 모두 도착하기까지 버퍼 내에서 기다리는 경우가 있다.
- 마지막으로 TCP 헤더를 제거하고 안에 있는 애플리케이션 데이터를 재구성하고, 이것을 소켓을 통해 애플리케이션에게 전달 한다.

- 이처럼 TCP/IP를 통해 소켓에 기록한 데이터가 그 형태 그대로 상대 서버의 소켓을 통해 나오는 것이다.

#### NIC의 끼어들기와 패킷 처리
- 하드웨어의 끼어들기(interrupt, 인터럽트) 처리라는 것은 하나의 장치당 하나의 CPU(코어)밖에 처리할 수 없다.
- 최신 NIC에는 RSS(Receive Side Scaling)라는 기능이 탑재돼 있어서 CPU별로 준비된 복수의 큐에 수신한 패킷을 할당할 수 있다. 패킷 헤더를 통해 계산한 값을 기준으로 큐에 할당하기 때문에 CPU 전체에서 수신 처리를 분산할 수 있다.
- RSS는 NIC 측 기능이지만 OS 측 기능도 등장하고 있다. 최신 리눅스 커널에는 RPS(Receive Packet Steering)라는 기능이 탑재돼 있다. 이것은 RSS 기능을 NIC가 아닌 커널 측에서 구현한 것이다.
- NIC에서 패킷을 받은 후의 처리를 복수의 CPU에 분산처리 한다. 할지만 이 구조가 좋다고만 할 수는 없다. CPU들 사이에서 처리가 겉돌게 돼서 불필요한 오버헤드가 발생할 수 있다.
- 이런 문제를 개선하기 위해 RPS에 RFS(Receive Flow Steering)라는 기능이 추가됐다. RFS에서는 RPS로 복수의 CPU에 처리를 분산할 때 해당 패킷 데이터를 최종 수신 프로세스의 CPU에게 전달한다.
