
# 시스템을 연결하는 네트워크 구조

## 네트워크
- 서로 다른 장비가 데이터를 교환 할 때 기본적으로는 네트워크를 경유헤서 데이터를 송수신할 필요가 있다.
- 현재 네트워크 자체가 그 구조를 알지 못해도 사용할 수 있도록 돼 있다.
- 네트워크에서 발생하는 데이터 처리나 교환에는 다양한 구조가 존재한다.

## [기초] 계층 구조란?

### 게층 구조는 역할 분담
- 계층 구조에서는 데이터나 기능 호출 흐름에 따라 계층 간 역할이 나누어진다는 특징이 있다.
- 역할이 나누어져 있기 때문에 각 층은 자신이 담당하는 일만 책임을 지며, 다른 일은 다른 계층이 책임을 진다. 상호 연결돼 있는 계층들에서는 교환 방법, 즉 인터페이스만 정해 두면 된다.
- 각 층은 상호 간에 어떤 일을 하는지(어떤 기능을 가지고 있는지) 알고 있지만, 구체적으로 어떤 방식으로 처리하고 있는지는 알지 못한다. 즉, 은폐화 되어 있다.
- 계층 구조로 나눔으로써 계층 간에 영향을 주지 않고 독립적으로 동작 할 수 있다. 상호 간에 내부 처리를 은폐하고 있기 때문에 인터페이스만 바꾸지 않으면 각 계층이 내부적인 처리를 마음대로 바꾸어도 문제가 없다.
- 단점으로는 작업 효율을 희생해야 한다는 점을 들 수 있다. 컴퓨터에서는 작업 효율은 성능을 의미한다. 교대할 때의 작업 인계를 위한 오버헤드가 발생한다.

### 계층 모델의 대표적인 예 - OSI 7계층 모델
- OSI(Open Systems Interconnection)라는 통신 규격을 만들 때 고안된 것으로, OSI 통신 기능을 7개의 계층으로 나눈 것이다.
- OSI 자체는 현재 사용되고 있지 않지만, 이 계층 구조 개념은 다양한 분야에서공통적으로 참조할 수 있는 참조 모델로 현재도 사용되고 있다. 또한, 참조 모델이 되면서 엔지니어가 서로 공용할 수 있는 일종의 공통 언어 역할도 하고 있다.
 
#### OSI 참조 모델
- 애플리케이션 계층(application layer) : 애플리케이션 처리
- 프레젠테이션 계층(presentation layer) : 데이터 표현 방법
- 세션 계층(session layer) : 통신 시작과 종료 순서
- 전송 계층(transport layer) : 네트워크 통신관리
- 네트워크 계층(network layer) : 네트워크 통신 경로 선택
- 데이터 링크 계층(data linl layer) : 직접 접속돼 있는 기기 간 처리
- 물리 계층(physical layer) : 전기적인 접속

### 계층 구조는 네트워크 외에도 존재한다.
- 3계층형 시스템도 계층 구조다. 시스템 규모가 커질수록 역할별로 계층화하지 않으면 전체 구조가 복잡해져서 개발이 힘들어진다.
- 서버 한 대의 내부를 살펴봐도 역시 계층 구조로 되어 있다. 애플리케이션이나, OS, 하드웨어 조합도 계층 구조하고할 수있기 때문에 부분별로 선택할 수 있다. 휴대전화는 성능이 다양해서 OS나 하드웨어를 자유롭게 변셩할 수 있을 정도로 계층이 나누어져 있지 않다. 따라서 부분별로 선택하는 것이 어렵다.

## [기초]프로토콜이란?
- 프로토콜(protocol)이라는 영어 단어는 사전에 정해 놓은 순서를 의미한다.
- 컴퓨터 용어로는 특히 통신 프로토콜이라는 이름으로 자주 등장하며, 컴퓨터가 서로 소통하기 위해 정한 규약을 가리킨다.

### 컴퓨터에서는 프로토콜이 필수 불가결이다.
- 컴퓨터의 거의 모든 곳에 프로토콜이 사용된다. 떨어진 곳에 있는 두 개의 장비는 사전에 절차를 정해 두지 않으면 서로 통신할 수 없다. 그래서 네트워크와 프로토콜은 뗼래야 뗼 수 없는 관계다.
- 프로토콜은 같은 계층 간의 약속이라고 할 수 있다.
- 네트워크 업계에서는 공통 프로토콜 선정을 위한 IEEEsk IETF 같은 표준화 단체가 존재한다.

#### 표준화 단체에 대해서
- IEEE는 전지전자 기수루 학회이지만, 전기통신을 사용한 프로토콜 표준화 활동도 하고 있다. 그중 우리가 자주 접하는 것은 무선 LAN 프로토콜이다. IEEE 802.11n 대응이라고 쓰여진 무선 LAN 공유기. 이것이 IEEE가 표준화한 규격 중 하나다.
- IETF는 인터넷에서 사용되는 다양한 기술을 표준화한 단체다. 이 단체는 꽤 열려 있는 단체로, 다양한 제조사나 대학 관계자는 물론 통신 전문가들도 참여하고 있으며, 이들이 협의를 거쳐서 표준 규격을 정하고 있다.
- IETF에서 정해진 것은 RFC라는 이름의 문서로 나와 있다. 이것은 Request for Comment(주석 제안)의 약자로, 이것을 통해서도 인터넷 기술이 공개화되고 있다.
- 표준화된 것 중에는 이미 다른 규격이 보급돼 있어서 더는 사용되지 않는 것도 있다. 대표적인 예가 OSI와 이더넷이다.

### 프로토콜은 서버 내부에도 존재한다.
- USB 프로토콜이 존재한다.
- 저장소에서 데이터를 꺼낼 때도 프로토콜이 정해져 있다. 대표적으로 SCSI 프롵토콜이 있다.
- CPU 안에도 프로토콜이 존재한다. 코어들이 서로 통신을 하기 위한 프로토콜도 있다.

## TCP/IP를 이용하고 있는 현재의 네트워크
- 인터넷을 포함해서 현재 네트워크를 지탱하는 것은 TCP/IP 및 관련 프로토콜이다.

### 인터넷의 발전과 TCP/IP 프로토콜
- 인터넷의 시초는 1969년에 미국 국방성의 연구로부터 시작된다. 이때 구축된 실험 네트워크는 ARPANET(아파넷)이라고 불리는 것이다.
- 1980년대까지는 아파넷 외에도 다른 네트워크도 운영되고 있었으며, 이들이 상호간에 접속할 수 있게 됐다. 이 시기에는 네트워크 제조사별로 수많은 독자 프로토콜을 사용하고 있어서 상호 접속에 문제가 있었다. 이런 이유로 국제 규격의 프로토콜을 만들자는 움직임이 시작됐다. 이것이 1982년에 제정된 OSI라는 프로토콜이다.
- 이때는 이미 1970년대에 고안 된 TCP나 IP 프로토콜이 보급되고 있었으며, OSI 자체도 복잡한 사양 때문에 상호 접속성에 문제가 있었다. 국제 규격으로 OSI 사용을 권장했지만, 결국 OSI는 사장되고 말았다.
- 최종적으로는 TCP/IP 프로토콜 슈트를 이용하는 네트워크가 대다수가 됐고, TCP/IP가 인터넷의 사실상 표준이 된 것이다.
- 다양한 네트워크가 상호 산에 협력하면서 인터넷이 발전했고, 그 가운데 TCP/IP가 발전돼 온 것이다.

### TCP/IP 계층 구조
- TCP/IP 슈트는 TCP와 IP의 두 가지 프로토콜을 주축으로 한 프로토콜 집합이다. 주축이라고 하지만 TCP를 반드시 사용해야 하는 것은 아니며, IP는 통신 상대 지정 시에 IP 주소를 이용하기 때문에 반드시 필요하다고 할 수 있다.
- TCP/IP에서는 반드시 이 7계층이 분명하게 나누어지는 것은 아니다. TCP/IP 4계층 모델 등으로 불리며, OSI 7계층의 1~2계층을 모아서 링크 계층, 5~7계층을 모아서 애플리케이션으로 취급하기도 한다.
- HTTP 통신 데이터를 상대방에게 보내기 위해서 TCP에 데이터를 건네지만, 여기서부터 이너넷 계층까지는 OS 커널이 담당한다. 커널 내에서 TCP, IP, 이더넷을 담당하는 기능이 필요한 정보를 데이터에 부여해서 최종적으로 이더넷 프레임이 생성된다. 이것이 NIC에 전달돼서 이더넷 케이블 등을 통해 인접 노드를 경유해서 최종 위치까지 전달된다.
- 계층 구조로 나누어져 있어서 통신하고 싶은 애플리케이션은 독자적으로 통신 구조를 만들 필요 없이 TCP/IP에게 위임할 수 있다.
- 각 계층을 담당하고 있는 것도 쉽게 변경할 수 있다. (TCP 대신에 신뢰성이 낮지만 간단하게 데이터를 송수신할 수 있는 UDP를 사용하거나, 유선이 아닌 무선으로 통신을 하는 등 용도에 맞게 변경할 수 있는 점도 계층 구조의 장점이다.)
- TCP/IP는 4계층이라고 하짐ㄴ, 실제 현장에서 계층을 숫자로 부를 때는 OSI 참조 모델의 7계층 방식으로 부르는 경우가 많다. 링크 계층, 즉 이더넷 계층을 레이어 2나 L2로 IP 계층을 레이어 3나 L3, 전송 계층(TCP 계층) 레이어 4나 L4라고 부른다.
- 각 계층별 처리를 하는 네트워크 스위치를 L2 스위치나, L3 스위치라고 부르는 경우도 있다.
- L5, L6, L7을 모아서 애플이케이션 게층으로 취급하기 때문에 TCP/IP 이야기를 할 때는 거의 등장하지 않는다.

## [레이어]애플리케이션 계층의 프로토콜 HTTP
- 애플리케이션이 사용하는 프로토콜을 모두 애플리케이션 계층 프로토콜이라 부른다.
- 애플리케이션 계층 프로토콜은 자신이 통신을 하는 것이 아니라 통신 자체는 모두 OS, 즉 TCP/IP에 맡긴다.
- HTTP 사양은 RFC2616에서 정하고 있다.

### 요청과 응답의 구체적인 내용

#### 요청(요구)
- 요청 : 서버에 대한 요구 명령, 대상 데이터를 지정한다.
- 메세지 헤더 : 브라우저에 상세한 정보를 전달한다.(표시 대응 브라우저, 데이터 형식, 접속 방식 등)
- 메세지 바디 : 브라우저에 입력한 내용이 포함된다.
- 요청 시 중요한 것은 서버에 던지는 명령이다. GET은 파일 요구이고, POST는 데이터를 전송한다는 의미다.
- 헤더 부분에는 다양한 부가 정보가 들어가면 세밀한 제어를 위해 사용한다. User-Agent는 브라우저 식별 정보를 가지고 있으며, Cookie는 세션 식별자로 사용된다.

#### 응답(전송)
- 상태 : 결과가 정상인지 에러가 있는지 등의 상태 정보를 가진다.
- 메시지 헤더 : 브라우저에 상세한 정보를 전달한다.(표시 대응 브라우저, 데이터 형식, 접속 방식 등)
- 메시지 바디 : HTML 데이터 등 실제 데이터가 저장된다.

### -
- HTTP가 그 하위 계층인 IP나 유선을 통해 명령을 보내거나 통신 제어를 하지는 않는다. 이 때문에 HTTP 요청은 여러 가지 명령만으로 구성돼서 매우 간단한 구조라는 것을 알 수 있다.

### 애플리케이션 프로토콜은 사용자 공간에서 처리
- 애플리케이션 자체가 통신 구조를 가지지 않고서도 원격지에 있는 서버 애플리케이션과 통신할 수 있다.(소켓같은 것을 이용해서)
- 애플리케이션 프로토콜으 기본적으로 애플리케이션 프로세스 내부에서 모두 구현된다.

### 소켓 이하는 커널 공간에서 처리
- 의뢰 방법은 시스템 콜이다. 이때 접속 대상 서버의 IP 주소와 TCP 포트의 두 가지 정보가 필요하다. 이 두가지 정보는 각각 IP 도착 위치와 TCP 도착 위치다.
- 의뢰를 받은 커널은 소켓을 만들어 준다. 소켓을 만든 것뿐으로 데이터를 보내기 위해 구멍을 연 것이다.
- TCP를 사용하기 때문에 TCP를 사용한다는 것과 IP 주소 및 포트 번호 정보를 시스템 콜 경유로 커널에 전달하면, 접속 대상 서버와의 연결이 생성된다. 이때 상대방 서버에서도 소켓이 만들어지며, 상대 서버와의 사이에 가상 경로(버추얼 서킷)가 생성 된다.
- 프로세스 관점에서는 소캣으라니느 구멍에 넣은(기록한) 데이터가 가상 경로를 통해서 상대 통신 소켓 구멍으로 나오는 것이다. 매우 간단한 것 같지만, 커널이 열심히 여러 처리를 해 주고 있다.

#### 한번 잡으면 놓아주지 않는다
- HTTP는 한 번 요청/응답 관계가 끝나면 세션을 종료한다.
- 하위 계층인 3way-handshaking 등의 오버헤드가 발생해서 전체 화면의 응답에 영향을 끼치게 된다.
- 세션을 남겨 두는 기능을 Keep-Alive라고 한다.
- 웹 서버 측에 세션 잔존 시간 등을 설정한다.
- 프로토콜 헤더의 Connection에 keep-alive가 있으면 이 기능이 켜진 것이고, close라고 쓰여 있으면 꺼진 것이다.
- 무의미하게 세션을 길게 유지하면 HTTP 프로세스/응답이 세션을 놓지 못해서 신규 요청을 접수할 수 없게 되니 주의가 필요하다.

## [레이어4] 전송 계층 프로토콜 TCP
- 소케에 기록된 애플리케이션 데이터는 커널 내에서 통신 대상에게 전달하기 위한 준비를 시작한다. 제일 먼저 임무를 수행하는 것이 전송 계층 프로토콜인 TCP다. TCP(Transmission Control Protocol)는 명칭 그대로 전송을 제어하는 프로토콜로, 신뢰도가 높은 데이터 전송을 가리킨다.

### TCP의 역할
- 애플리케이션이 보내 데이터를 그 형태 그대로 상대방에게 확실하게 전달하는 것이다. 단, 가능한 주변에는 민폐를 끼치지 않는다. 원래 신뢰도가 낮은 인터넷에서 사용하기 위해 만들어졌기 떄문에 이런 역할이 주어졌다고 할 수 있다.
- TCP가 담당하는ㄱ ㅓㅅ은 어디까지나 서버가 송신할 때와 서버가 수신한 후 애플리케이션에게 전달할 때로, 상대 서버까지 전송하는 부분은 하위 계층인 IP에 모두 위임한다. 물론 TCP에 의존하지 않고 IP만으로도 통신 할 수 있지만, IP에는 데이터가 상대방에게 확실히 전달됐는지 확인하는기능이나 도착한 순서를 확인하는 기능 등이 없다.

#### TCP 중요한 기능
- 포트 번호를 이용해서 데이터 전송
- 연결 생성
- 데이터 보증과 재전송 제어
- 호름 제어와 폭주 제어

#### 인터넷의 주인은 누구?
- 인터넷에서는 양자 간(end-to-end) 신뢰성을 담보한 TCP 같은 구조가 필요하다.
- 인터넷은 모두가 공유하는 것으로 공평성도 매우 중요하다.
- 공평성과 공평성에 대한 정신을 강조하고 있다.

### 커널 공간의 TCP 처리 흐름
- 소켓에 기록된 애플리케이션 데이터는 소켓의 큐를 경유해서 소켓 버퍼라 불리는 메뫼 영역에서 처리 된다. 소켓 버퍼는 소켓별로 준비된 전용 메모리 영역으로, 이후 계속되는 IP나 이더넷까지의 일련의 처리도 소켓 버퍼 내에서 이루어진다.
- TCP는 세그먼트(segment)라고 하는 단위(TCP 패킷이라 불리는 경우도 있지만 정의상 적합하지 않다)로 데이터를 관리하고 있다. 이 떄문에 애플리케이션 데이터에 TCP 헤더를 붙여서 TCP 세그먼트를 작성한다.
- 헤더에는 도착 지점 포트 번호를 포함해서 TCP 기능을 표현하기 위한 수많은 정보를 기록된다.
- 하나의 TCP 세그먼트로 전송할 수 있는 최대 데이터 크기를 MMS(Maximum Segment Size)라고 한다.
- 최종적으로 링크 계층을 사용해서 데이터를 전송하기 때문에 MMS는 링크 계층에서 전송 할 수 있는 최대 크기에 의존하며, 환경이나 설정에 따라 달라진다.
- 링크 계층의 최대 데이터 크기를 MTU(Maximum Transger Unit)라고 한다.

### 포트 번호를 이요한 데이터 전송
- TCP 포트 번호는 0~65535 까지의 숫자를 이용한다.

## 연결 생성
- TCP는 소켓 생성할 때도 중요한 역할을 한다.
- TCP는 연결형 프로토콜로, 연결이라 불리는 가상 경로(버추얼 서킷)를 생성한다. 이것을 TCP가 통신을 시작하면서 통신 상대에게 지금부터 통신한다라고 연락한 후 OK 사인을 받으면 그때 처음 생성된다. 물론, 통신을 받으려면 통신을 받는 애플리케이션 측(서버)이 미리 통신 준비를 하고 있어야 한다.
- 서버 프로세스는 OS에게 포트번호 --에게 통신 의뢰가 오면 나에게 연결해라고 부탁한다. 이렇게 서버 측 소켓은 자신이 지정한 포트 번호에 통신이 오는지를 기다렸다가 받는다. 이 상태를 포트를 리슨(LISTSTEN)하고 있다고 한다.

1. 통신 상대인 서버 측 OS에게 가상 경로를 열도록 의뢰한다.
1. 서버 측에서는 리슨하고 있는 포트 번호로 통신 요구가 온다. 서버는 문제가 없으면 열어도 된다는 응답을 한다.
1. 클라이언트 측도 확인 했다는 메세지를 보내며, 이때 처음으로 통신용 가상 경로가 연린다.
> 이 세번의 대화를 TCP/IP의 3-way handshaking 이라고 한다.

- TCP 통신을 시작할 때 상대 서버에 포트 번호와 연결을 열어 달라고 부탁만 할 뿐 다른 특별한 일은 하지 않는다. 데이터 전송 자체도 IP에 위임하기 때문에 실제 물리적인 경로가 막히거나 통신 상대 서버가 갑작스런 자앵로 전원이 꺼져도 가상적인 경로인 TCP 연결이 끊어지진 않는다. 이런 상태에서는 데이터가 전달되진 않지만, 기본적으로 애플리케이션이 OS에게 연결 절단 의로를 하거나 통신 대상이 에러를 보내오지 않는 이상 TCP 연결 자체가 유지 되기 때문에 주의가 필요하다.
- 통신을 받는 서버 측은 미리 지정한 포트 번호를 리슨하지만, 통신을 시작하는 클라이언트 측에서는 보통 자신이 사용하기 위한 포트번호를 지정할 수 없다. 이때는 클라이언트 측에서 사용하지 않는 포트 번호가 자동적으로 OS에 의해 할당된다.

### 데이터 보증과 재전송 제어
- 연결이 생성된 후에야 데이터 송수신이 시작된다.
- TCP에는 데이터가 확실히 전달되도록 보증하는 기능이 있다.
- 데이터 손실 방지 기능
  - 확인 응답과 재전송에 의해 구현된다.
  - 수신 측에 TCP 세그먼트가 도착하면 수신 측은 송신 측에게 도착했다는 것을 알린다. 이떄 반환하는 것을 ACK라고 하며, TCP 헤더에 ACK 관련 정보를 넣는 TCP 세그먼트를 반환한다. 송신 측은 ACK가 동아온느 것을 보고 전송한 세그먼트가 무사히 도착했다는 것을 알 수 있다. ACK가 돌아오지 않으면 전송한 TCP 세그먼트가 어떤 이유로 사라졌을 가능성이 있다. 이 때문에 언제든지 재전송이 가능하도록 전송이 끝난 TCP 세그먼트라도 ACK가 돌아오기까지는 소켓 버퍼에 남겨 둘 필요가 있다.
- 데이터 순서를 보증하는 구조
  - 각 TCP 세그먼트에 시퀀스(sequence) 번호라고 하는 숫자를 붙여서 구현한다. 시퀀스 번호도 TCP 헤더에 기록되며, 해당 TCP 세그먼트가 가지고 있는 데이터가 전송 데이터 전체 중 몇 바이트째부터 시작하는 부분인지를 가리키고 있다.
  - 순차적인 조합을 위해 수신 측은 ACK를 반환할 때 다음에 필요한 TCP 세그먼트의 시퀀스 번호도 ACK 번호로 전달한다.
- ACK가 오지 않으면 재전송한다고 말햇지만, 어느 시점에 재전송을 하는 것인가?
  - 첫 번째는 타임아웃이다. 
  - 중복 ACK(Duplicate ACK)
    - 1회 중복 ACK로 바로 재전송하맂 않고 3회까지 기다리는 것은 가금 해당 세그먼트만 경로 도중에 지연돼서 도착 순서가 바뀔 수 있기 때문이다.
  - SACK(Selective ACK)
    - 더 상세한 ACK를 반환할 수 있다.
    - 이미 도착했다는 것을 정보로 전달할 수 있다. 이를 통해 송신 측은 도착하지 않은 TCP 세그먼트만 선택해서 재전송할 수 있게 된다.

### 흐름 제어와 폭주 제어
- 데이터를 보내고 ACK를 기다리는 처리를 반복하다 보면 시간이 많이 걸린다.
- 동기로 통신을 하면 효율이 나쁘기 때문에 ACK를 기다리지않고 전송하는 것이 좋다.
- ACK를 기다리지 않고 전송 가능한 데이터 크기를 윈도우 크기라고 한다.
- 윈도우에는 수신 측의 수신 윈도우와 송신 측의 폭주(송신) 윈도우, 두 가지가 있다.
  - 기본적으로는 수신 측이 폭주 윈도우 크기를 조정래서 폭주 윈도우와 수신 윈도우 중 작은 쪽을 송신 윈도우로 채택하며, 이 버위 내에서는 ACK를 기다리지 않고 전송 한다. ACK가 오면 해당 TCP 세그먼트는 재전송할 필요가 없기 때문에 송신용 소켓 버퍼에서 삭제하고 송신 윈도우를 다음으로 이동한다. 이와 같이 윈도우를 이동해 가는 방식을 슬라이딩 윈도우(sliding window)라고 한다. 수신 측은 수신용 소켓 버퍼가 넘쳐서 더 이상 수신이 불가능하게 되면 수신 윈도우 크기를 작게 만들고 이 사실을 송신 측에 알린다. 송신 측은 윈도우 크기 이상의 데이터는 ACK 없이 보낼 수 없게 된다. 이것이 TCP 흐름제어(유량 제어)다.
  - 송신 측 윈도우 크기는 네트워크 폭주 상태(혼잡 상태)에 맞추어 변형 시키기 때문에 폭주 윈도우라고 부른다. 네트워크가 혼잡하면 폭주 윈도우 크기를 작게 해서 전송 데이터 양을 줄인다. 이거이 폭주 제어다. TCP는 주변에 영향을 주지 않도록 자중하는 프로토콜이다. 폭주 윈도우 크기는 통신 시작 시에 1세그먼트에 설정된다. 통신이 문제 없이 시작돼서 수신 측에 도착하면 ACK 반황 시마다 폭주 윈도우 크기를 2세그먼트, 4세그먼트 식으로 지수 함수적으로 늘려나간다. 이 방식을 슬로 스타트(slow start)라고 한다. 어느 정도 크기까지 증가하면 기 이후는 1세그먼트씩 크기를 늘려나간다. 송신 중인 세그먼트가 실패하면, 즉 폭주를 감지하면 폭주 윈도우 크기를 작게해서 송신량을 줄인다. 그리고 다시 폭주 윈도우 크기를 크게 만든다. 이 벼놔를 반복함으로써 주변에 민폐를 끼치지 않고 자신의 전송 속도가 최대가 되도록 조정할 수 있다.
- 송신 측은 받는 수신 윈도우 크기와 폭주 윈도우 크기 중 작은 쪽에 맞추어 전송량을 제어한다. 이와 같은 형식으로 흐름 제어와 폭주 제어가 이루어진다.

## [레이어3]네트워크 계층의 프로토콜 IP
- TCP 세그먼트가 만들어지면 다음은 IP 처리가 시작 된다.
- IP는 Internet Protocol의 약자로, 명칭 그대로 오늘날 인터넷에서 사용되고 있는 가장 중요한 프로토콜이다.





