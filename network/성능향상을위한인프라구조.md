
# 성능 향상을 위한 인프라 구조

## 응답과 처리량

### 성능 문제의 두 가지 원인
- 시스템 성능을 가리킬 때 응답(response)과 처리량(throughput)이라는 지표가 자주 사용된다.
  - 응답은 처리 하나당 소요 시간을 의마한다.
  - 처리량은 단위 시간당 처리 하는 양을 의미한다.
  - 실제 시스템에서는 단일 사용자 응답 시간만으로는 부족하기 때문에 여러 사용자의 평균값을 이용한다. 이때 통계학에서 이용되는 퍼센타일 개념을 이용한다. 극단적으로 응답 시간이 긴 사용자는 다른 문제를 내포하고 있기 때문에 오차라고 생각하고 평균값에 포함하지 않는다. 10% 사용자 값을 버리고 나머지 90% 사용자의 평균 응답 시간을 이용하는 형태다.

### 응답 문제
- 모든 응답 시간에는 반드시 물리적 제약이 존재한다.
- 응답 시간 개선에 한계가 보일 때는 처리량 개선을 통해서 시스템 전체 사용률을 개선하는 것이 일반적이다.

### 처리량 문제
- 처리량이란 다수의 요청이 동시에 발생하면 막히기 쉽다.
- 응답과 처리량이 밀렂ㅂ한 관계가 있다. 응답이 매우 느린 시스템에서는 다수의 사용자 요청이 시스템 내에 누적되므로 전체 처리량도 낮아진다. 또한, 처리량이 포화 상태가 되면 리소스가 부족해져서 응답도 함께 악화 된다. 성능 병목 현상을 개선하려면 반드시 양쪽을 고려해서 진행 해야 한다.

## 병목 현상이란?
- 처리량을 제한하고 있는 요인을 가리키며 병(bottle)의 목(neck) 부분을 생각하면 된다.

### CAP 정리
- Consistency(일관성) : 특정 시점에 반드시 동일 데이터가 존재해야 하는 것을 의미한다.
- Availability(가용성) : 하나의 서버가 다운돼도 다른 서버가 처리를 계속하는 것을 가리킨다.
- ParitionTolerance(분할 허용성) : 서버를 늘림으로써 성능을 확장할 수 있는 것을 의미한다.
- 이 중 두가지를 만족하면 마지막 한 가지는 희생해야 한다는 법칙이다.
- RDBMS는 CA : C가 병목지점이다.
- 키-벨류 저장(KVS)은 AP : P가 병목지점이 되기 쉽다.
- 시스템 아키텍처가 CAP 정리를 어느 부분을 중시하는지를 파악해 두면 시스템 구성도만 보고도 병목 지점을 찾아서 개선안을 도출할 수 있다.
- 근거가 되는 자료를 확인한다는 측면에서라도 로그를 잘 확인하는 것이 좋다.

### 병목현상을 어떻게 해결하는가?
- 로그를 취득해서 어느 서버가 병목 지점이 되고 있는지를 찾아내는 것부터 시작해야 한다.
- 해결 방안
  - 첫 번째는 병목 위치를 파악해서 어떻게든 해결하는 것이다. 이것을 튜닝이라고 한다. 튜닝 시에는 병목 위치를 작은 단위로 세분화해서 병목 영역을 더 집중저긍로 파헤치는 접근법이 유효하다. 서버 내에서는 여러 가지 하드웨어와 소프트웨어가 동작하고 있기 때문에 각 컴포넌트의 로그를 확인해 갈 필요가 있다.
  - 다른 한 가지 방법은 시스템 이용자 수를 제한하는 것이다. 이것은 유량 제어라는 이름이 붙어 있을 정도로 매우 직관적인 방법이다. 단, 유량 제어에서는 사용자에게 에러를 반환하는 것이 전부라서 근본적인 해결책은 되지 못한다. 이때는 수평 분할을 통해 서버를 증설함으로써 시스템 전체 허용량을 늘리는 접근법을 병용할 필요가 있다.

### 병목지점은 반드시 존재한다
- 모든 서버, 소프트웨어, 물리 장비가 균등하게 처리량을 분배하는 것은 이론상으로 불가능하기 때문이다.
- 하나의 계층에서 병목 현상이 해결되면 반드시 다른 위치에서 병목 현상이 발생한다.

#### 병목 현상의 숙명의 적, 데이터베이스
- 최종적으로는 DB 서버가 병목 지점이 되는 경우가 대부분이다. 이런 이유로 DB 엔지니어는 매일 같이 튜닝에 시달리고 있다.

## 3계층형 시스템 그림을 통해 본 병목 현상
- CPU 병목 현상
- 메모리 병목 현상
- 디스크 I/O 병목 현상
- 네트워크 I/O 병목 현상
- 애플리케이션 병목 현상

### CPU 병목 현상 예
- 프로세스가 효율적으로 처리를 진행하다 보면 CPU 사용률이 100%가 될 수 있다. 이것은 시스템 관점에서 비효율적인 상태가 아니라 오히려 그 반대다. 이 상태는 다른 계층의 처리량이 매우 좋아서 최종적으로는 CPU에서 병목 현상이 발생한다는 것을 의미하기 때문이다. CPU가 유용하게 활용되고 있어서 시스템 투자 효과가 높다고 CIO(최고 정보 책임자)로부터 칭찬을 받은 것이다. CPU 병목 현상이 있다고 해도 사용자가 만족하고 있다면 이 상태는 아무런 문제가 되지 않는다.
- CPU 사용률은 하나의 상태를 가리키는 지표일 뿐이다. CPU 사용률이 급증해서 문제가 있는지 없는지를 판단 하려면 사용자 관점의 응답 속도나 시스템 전체 처리량을 확인해야 한다. 사용자가 만족하지 못한다면 CPU 사용률이 높은 상태 자체를 문제로 생각하지 말고 근복적인 원인을 조사하도록 하자.
- CPU에 기인한 성능 문제
  - CPU를 이용하는 처리가 많아서  대기 행렬이 발생하고 있다.
  - CPU 응답이 느리다.
- CPU 코어 수를 늘리거나 수평 분할을 통해 서버 수를 늘리는 것을 스케일아웃(scale-out)이라고 한다.
- 응답의 병목 현상
 - 대기 행렬을 듀닝하면 처리량 문제는 해결된다. 하지만 처리량 문제를 해결해도 반드시 응답 문제가 해결되는 것은 아니다.
- 처리 능력을 향상 시킨다. 
  - 첫 번째는 처리 능력을 향상 시키는 방법이다. 이것을 스케일업(scale-up)이라고 한다. 하지만 최근의 CPU는 클럭 차이가 크지 않아서 이를 통한 극적인 개선 효과는 기대하기 어렵다.
- 병렬로 처리 한다.
  - 두 번째는 분할해서 다수의 CPU 코어에게 동시 처리를 시키는 것이다. 병렬화, 멀티 프로세스화, 멀티 스레드화해서 복수의 CPU 코어를 이용함으로써 전체적인 처리 응답 시간을 향상 시킬수 있다.
  - 처리를 병렬화 할 수 있는가가 중요 사항이 된다. 처리에 따라서는 병렬화하는 것이 매우 어려운 경우도 있으며, 병렬화가 안 되는 경우는 CPU 코어 수를 늘리거나 서버를 늘려서 스케일아웃한다고 해도 큰 효과를 보기 어렵다. 벙렬화 검토는 인프라만으로 한계가 있기 때문에 애플리케이션 개발자의 협조가 필요하다.
- CPU 사용률이 오르지 않는다.
  - 대분은 애플리케이션에서는 CPU 사용률이 100%에 도달하는 경우가 거의 없다. 그 전에 디스크 I/O나 네트워크 I/O에서 막히는 경우가 많기 때문이다.
  - 동기 I/O는 시스템 콜로 커널에 명령이 가지만, 이것이 완료되지 않으면 프로세스가 다음 처리를 진행하지 않는다. 이 상태의 프로세스는 대기 상태가 되며, CPU를 이용할 수 없기 때문에 CPU 사용률은 올라가지 않는다. 이런 경우는 CPU 사용률이 낮아도 I/O 대기 큐에서 대기하는 프로세스 수가 증가한다.
  - 애플리케이션이 CPU, 메모리, I/O 등의 하드웨어 리소스를 제대로 활용하지 못하는 것이 문제다.
  - 개선 방법
    - 첫 번째는 처리를 다중화해서 CPU를 적절하게 활용하는 것이다.
    - 다른 한 가지는 I/O를 비동기화 하는 것이다.

### 메모리 병목 현상 예
- 영역 부족에 의한 병목 현상
  - 프로세스가 가동해서 어떤 처리를 하려면 반드시 전용 메모리 영역이 필요하다. 하지만 서버 상의 메모리 영역은 제한돼 있다.
  - 이 제한된 메모리 영역이 부족하지 않도록 OS 커널 츠겡서 페이징(paging) 또는 스와핑(swapping)이라고는 처리를 해서 빈 메모리를 확보하는 구조가 있다. 즉, 부족한 부분은 디스크 영역으로 보완해서 가성적인 메모리가 있다는 것을 보여 주는 기술이다. 가상 메모리(virtual memory)라고 한다.
  - 메모리와 디스크에는 압도적인 성능 차이가 있으므로 조금이라도 디스크에 저장하거나 메모리로 되돌리는 처리가 발생하면 성능 저하가 발생한다. 이것을 허세를 부린 것에 대한 벌이라고 할 수 있다.
- 동일 데이터에 대한 병목 현상
  - 디스크 I/O 시간응ㄹ 단툭하기 위해서는 메모리에 캐시로 데이터를 배치해 두는 것도 일례가 될 수 있다.
  - 메모리에 데이터를 캐시해도 메모리 경ㄹ합이 발생하는 경우도 있다. 메모리 영역에 액세스하는 것은 매우 빠르다. OS의 프로세스나 스레드가 액세스하는 경우, 나노초 단위의 액세스가 된다. 특정 영역을 복수의 프로세스가 공유하는 경우, 메모리 영역을 참조 또는 갱신할 때 누군가가 그 영역을 관리할 필요가 생긴다. 빠른쪽이 이기는 방식은 각각의 프로세스나 스레드가 경합하는 만큼 모두가 사이 좋게 줄을 서 있으면 되는데 관리 영역이 데이터 영역보다 커질 수 있다.
  - 이런 문제를 해결하려면 애초에 경합이 발생하지 않도록 

