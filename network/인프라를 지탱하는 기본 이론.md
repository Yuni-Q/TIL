
# 인프라를 지탱하는 기본 이론

## 웹 데이트의 흐름

### 직렬 / 병렬
- 직렬 처리로 속도를 올리는 데는 한계가 있다.
- 병렬화를 통해 속도는 빨라지지 않지만, 단위 시간당 처리량을 늘릴 수 있다.
  - 병렬 처리에서는 합류점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다.
  - 별렬화할 때는 일을 분담해서 처리를 한 후 다시 집약할 때 오버헤드가 걸린다. 그러므로 이 오버헤드를 감안하더라도 효과가 있을 경우에 병렬화 한다.

||장점|단점
|-|--|---
|직렬|구조가 간단해서 설계나 구현 난이도가 낮다|복수의 리소스(컴퓨터나 프로세서 등)를 유용하게 이용할 수 없다.
|병렬|복수의 리소스(컴퓨터나 프로세서 등)를 유용하게 이용할 수 있으며, 직렬에 비해 동일 시간당 처리할 수 있는 양이 증가한다. 또한 일부가 고장 나더라도 처리를 계속할 수 있다.|처리 분기나 합류를 위한 오버헤드가 발생한다. 배타 제어 등을 고려해야 하고 구조가 복잡해서 설계나 구현 난이도가 높다.

- 병렬화의 장점으로 처리 능력 향상을 들었지만, 이중화라는 관점에서도 장점이 있다.

### 병렬과 병행
병렬 : 동시에 복수의 처리를 실행하는 것  
병행 : 복수의 처리가 실행 상태에 있는 것  
즉, 병행은 병렬을 내포하고 있는 개념이다.  

## 동기 / 비동기
동기 : 누군가에게 일을 부탁하고 그 일이 끝나기까지 잠자코 기다리는 것  
비듕기 : '끝나면 말해'라고 하고 다른 일을 하는 것. 즉, 비동기에서는 처리를 병행해서 진행할 수 있다.  

- 동기는 다른 사람에게 일을 부탁한 후 끝날 때까지 아무것도 하지 않고 기다리기 때문에 그 사이에 다른 것을 할 수 없다. 하짐나 의뢰한 것이 끝났는지 여부를 확실하게 확인할 수 있다.
- 비동기는 끝날 때까지 기다리지 않기 때문에 병렬로 다른 일을 할 수 있다. 하지만 의뢰한 일이 끝났는지 여부를 확인하고 싶으면 별도의 방법을 이용해야 한다.

- 비동기로 요구한 처리가 끝나지 않은 상태에서 다음 처리를 진행해도 문제가 없는가
- 비동기로 요구한 처리가 끝났는지 확인할 필요가 있는가

### C10K 문제
하드웨어 성능상에 문젝 ㅏ없어도 클라이언트 수가 많아지면 서버가 고장 나는 문제  
무제를 해결하는 방법으로, 하나의 프로세스로 복수의 접속을 처리하는 방법  
이런 기법을 논블로킹(non-blocking) I/O 라고 한다.  
논 블로킹 I/O는 OS 시스템 콜로 구현돼 있어서, 그것을 그대로 사용한다.  
주의점은 모든 접속을 완저한 동기로 처리할 수 없기 때문에 동기 처리수를 고려해야 한다.  
node.js, Nginx, GlassFish 등이 논블로킹 I/O를 채택하고 있는 제품이다.  

## 큐

### 큐란?
큐(Queue)는 우리말로 대기 행렬이라 표현할 수 있다.  
FIFO(First In First Out, 선입선출)

- 큐(대기 행렬)에서는 줄을 설 때는 갖아 마지막에 서고, 처리는 선두부터 순서대로 된다.
- 먼저 들어온 데이터가 먼저 나가는 큐 동작을 FIFO 방식이라고 한다.

- CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
- 하드 디스크 등의 읽기 처리를 기다리고 있는 I/O 요구 행렬
- 네트워크 접속 성립을 기다리고 있는 접속 요구 행렬

CPU나 저장소와 같이 복수의 처리가 동시에 진행되는 부분에서는 큐를 많이 이용하기 때문에 성능 문제가 발생하기 쉽다.  
성능 문제에서는 큐의 길이, 즉 해열ㄹ의 길이를 확인하는 것이 중요하다.  

## 배타적 제어
배타적 제어는 문자 그대로 다른 것을 배제하는 제어다.  
여러 사람이 공유하기 때문에 배타적 제어가 필요하다.  
직렬 처리에서는 배타적 제어가 필요없지만, 병렬 처리에서는 필요하다.  

- 복수의 처리가 공유 자원(CPU, 메모리, 디스크 등)에 동시에 액세스(주로 갱신)하면 불일치가 발생할 수 있기 때문에 배타적 제어로 보호해 주어야 한다.
- 배타적 제어에서는 특정 처리가 공유 자원을 이용하고 있는 동안 다른 처리가 이용 할 수 없게 해서 불일치가 발생하지 않도록 한다. 
- 이런 부분에서는 병목 현상이 발생하기 쉽다.

||장점|단점
|-|--|---
|배타적 제어를 사용하는 경우|공유 데이터의 일관성을 유지할 수 있다|병렬 처리가 안 된다
|배타적 제어를 사용하지 않는 경우|병렬로 빠르게 처리할 수 있다데이터 불일치가 발생할 가능성이 있다(동시에 공유 데이터를 변경하는 경우 등)

## 상태 저장 / 상태 비저장
- ssh는 상태 저장 프로토콜  
- http는 상태 비저장 프로토콜 

- 상태저장 : 병원
- 상태비저장 : 슈퍼마켓

- 상태 저장은 부여된 정보에 따라 상태가 전이 된다, 이것을 그림으로 표현한 것이 상태 전이도다. 상태 저잦ㅇ 구조를 사용하는 이점은 과거 정보를 가져올 수 있어서 정보에 따른 복잡한 처리를 할 수 있다는 것이다. 단점으로는 약간이나마 시스템 복잡성이 커진다는 점을 들 수 있다. 또한, ㅇ;ㅣ

- 상태 저장은 상태를 고려하기 때문에 복잡한 처리가 가능하지만, 시스템 복잡성이 커진다. 
- 상태 비저장은 상태를 고려하지 않기 때문에 간단하며, 성능이나 안정성 측면에서 우수하다.

## 가변길이 / 고정길이
- 가변 길이는 공간을 유용하게 활용할 수 있지만 서능 면에서 불안정하다.
- 고정 길이는 쓸데없는 공간이 생기지만 성능 면에서는 안정적이다.

## 데이터구조(배열과 연결리스트)
- 배열은 데이터를 빈틈없이 순서대로 나열한 데이터 구조
- 연결 리스트는 데이터를 선으로 연결한 테이터 구조
- 탐색이 빠른 것은 배열이고, 느린 것은 연결 리스트
- 데이터 추가, 삭제가 빠른 것은 연결 리스트이고, 느린 것은 배열 

||장점|단점
|배열|N번째 요소 탐색이 빠르다|데이터 추가, 삭제가 느리다
|연결 리스트|데이터 추가, 삭제가 빠르다|N번째 요소 탐색이 느리다
> 해시 테이블은 배열과 연결 리스트의 상호 장점만 조합해서 약점을 보완한 데이터 구조이다.  
> 이외에도 큐, 스택 등의 데이터 구조도 배열인 ㅏ연결 리스트로 구현돼 있다.  

## 탐색 알고리즘(해시/트리)
데이터 정리 방법을 데이터 구조, 찾는 방법을 탐색 알고리즘이라고 한다.  

- 필요한 때에 필요한 데이터를 빠르게 찾기 위해서 데이터를 정리해 둘 필요가 있다.
- 데이터를 찾을 때의 데이터 구조와 데이터 구조와 데이터 저장 방식(메모리, HDD, SSD 등) 특성에 따라 적합한 데이터 정리 방법이 달라진다.
- 데이터 정리 방법을 데이터 구조, 처리 순서를 알고리즘이라고 한다.
- 처리 상대에 맞추어 데이터 구조를 정리할 필요가 있기 때문에 알고리즘과 데이터 구조는 자주 함께 다루어진다.

- 등호 검색에 강한 해시 테이블을 사용한 탐색과, 등호 검색은 물론 범위 검색에도 강한 만능형 B 등이 있다.
- 풀 스캔처럼 100건 데이터가 있으면 100건을 모두 보는 것을 선형 탐색이라고 한다. 모든 데이터가 필요한 경우에는 선형 탐색이 적합하다.
- DBMS에서 인덱스를 만들면 빨리지지만 갱신 시에 오버헤드가 걸린다는 단점도 있기 때문에 함께 고려해야 한다.
