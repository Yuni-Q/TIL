# 11. 객체의 변경 권한

- 우리가 접근할 수 있는 객체는 모두 수정할 수 있습니다.
- 개발자가 정의한 객체이든 기본 실행 환경의 일부분이든 접근할 수만 있으면 모두 변경할 수 있습니다.

## 변경 권한이 있는 객체란?

- 코드를 직접 작성했다면 당연히 자기 소유의 객체로써 변경 권한이 있습니다. 또 직접 작성하지 않더라도 유지보수를 맡고 있다면 이 역시 변경 권한이 있는 객체 입니다.
- 다음 목록을 포함해서 직접 정의하지 않은 객체는 수정하면 안 됩니다.
  - 네이티브 객체(Object, Array 등등)
  - DOM 객체(예: document)
  - 브라우저 객체 모델(BOM) 객체(예: window 객체)
  - 라이브러리 객체
- 이 객체는 프로젝트 실행 환경에 관련된 객체입니다. 기존에 있던 기능이든 새로 제공하는 기능이든 객체를 있는 그래로 사용해야지 변경하면 안 됩니다.

## 객체 변경 금지 규칙

- 유지보수가 중요한 엔터프라이즈 소프트웨어는 일관되고 신뢰할 수 있는 실행 환경이 필수적입니다.
- 이제 다음 규칙에 따라 자바스크립트 객체도 다른 언어에서처럼 유틸리티 라이브러리로 다뤄야 합니다.
  - 메서드를 오버라이드하지 않는다.
  - 새로운 메서드를 추가하지 않는다.
  - 디존 메서드를 삭제하지 않는다.

### 메서드 오버라이드 금지

- 자신이 소유하지 않은 객체의 메서드를 오버라이드하는 것은 자바스크립트에서 매우 나쁜 개발 습관입니다.

### 새운 메서드 추가 금지

- 자바스크립트에서 기존 객체에 새로운 메서드를 추가히각 굉장히 쉽습니다. 기존 객체에 새로운 메서드를 추가하려면 함수를 할당하기만 하면 되는데 이 방버븡로 모든 객체를 변경할 수 있습니다.
- 소유하지 않은 객체에 메서드를 추가할 때 생기는 가장 큰 문제는 이름 충돌 입니다. 단지 현재 메서드가 없다고 해서 앞으로도 같은 이름의 메서드가 없으리라고는 보장할 수 없습니다.
- 설상가상으로 나중에 우리가 임의로 추가한 메서드와 네이티브 메서드가 이름만 같고 동작이 다르면 유지보수의 악몽이 시작됩니다.
- 많은 자바스크립트 라이브러리가 플러그인 아키텍처로 구현되어 있어 라이브러리에 새로운 기능을 안전하게 추가할 수 있습니다. 라이브러리를 수정해야 한다면 플러그인을 만든느 편이 유지보수 측면에서 가장 좋습니다.

### 메서드 삭제 금지

- 자바스크립트에서 메서드를 제거하는 건 메서드를 추가하는 것처럼 쉽습니다.
- 물론 메서드를 오버라이드하는 것도 기존 메서드를 제거하는 것이라 볼 수 있습니다.
- 메서드 이름에 null을 할당하면 메서드를 가장 간편히 제거할 수 있습니다.
- 그러나 null을 할당하면 메서드가 어떤 방식으로 정의됐는지에 상관없이 호출할 수 없게 됩니다.
- 메서드가 객체의 프로토타입이 아닌 객체의 인스턴스에 정의되었다면 delete 연산자로 제거 할 수 있습니다.
- 기존 메서드를 삭제하는 일은 분명히 나쁜 습관입니다. 삭제하려는 메서드를 즐겨 사용ㅇ하는 개발자가 있을 수도 있고 기존 코드에서 그 메서드를 사용하고 있을 수도 있습니다. 게다가 메서드를 삭제하면 런타입 에러가 발생할 수 있습니다.
- 만약 팀에서 특정 메서드 사용을 금지할 거라면 문서화 주석이나 정적 코드 검사를 통해 '더 이상 사용하지 않음(deprecated)'이라고 표시해야 합니다. 그렇더라도, 메서드 삭제는 부가피한 상황에서만 사용하는 극약처방으로 생각해야 합니다.

## 더 나은 접근법

- 보통 어떤 문제를 해결하려고 변경 권한이 없는 객체를 변경합니다. 다른 기능과 유기적인 동작은 고려하지 않은 채, 기존 객체를 변경하면 문제를 해결할 수 있으리라 생각하기 때문입니다.
- 기존 객체를 변경하지 않으면서 객체를 확장하는 접근법을 디자인 패턴이라 합니다.
- 자바스크립트 외에 다른 언어에서 객체를 확장할 때 가장 많이 쓰는 방법이 상속입니다.
- 자바스크립트에는 2가지 기본적인 형태의 상속이 있는데 객체 기반 상속과 타입 기반 상속입니다.
  - 자바스크립트 상속은 심각한 한계가 있습니다. 첫째로 DOM이나 BOM 객체를 상속 받으면 동작하지 않습니다. 둘째로 Array는 length 프로퍼티와 관련 있는 숫자 인덱스 처리 방법이 복잡해서 Array를 상속 받으면 제대로 동작하지 않습니다.

### 객체 기반 상속

- 객체 기반 상속은 프로토타입 상속(prototypal inheritance)으로도 불리며 객체가 다른 객체의 생성자 함수를 호출하지 않고 그 객체를 상속하는 방법입니다.
- ECMAScript5의 Object.create()를 이용하면 가장 쉽게 다른 객체를 상속 받을 수 있습니다.
- 이 방법으로 새로운 객체를 생성하서 우리가 원하는 대로 자유롭게 수정할 수 있습니다. 어차피 우리가 새로운 객체의 소유자이므로 마음대로 기존 메서드를 오버라이드하거나 삭제할 수 있고 접근하지 못하게 막을 수도 있으며 새로운 메서드를 추가할 수도 있습니다.

### 타입 기반 상속

- 타입 기반 상속은 기존 객체의 프로토타입을 상속받는다는 점에서는 객체의 기반 상속과 방법이 유사합니다.
- 객체 대신생성자를 이용하는데 이는 상속받으련느 개체의 생성자에 접근해야 한다는 의미입니다.
- 자바스크립트가 자체적으로 제공하는 생성자 함수보다는 사용자 정의 생성자를 상속받을 때 가장 많이 사용되는 방법입니다. 이 방식을 사용하려면 먼저 프로토타입을 상속한 뒤 생성자 상속을 합니다. 생성자 상속은 새로 생성할 객체를 가리키는 this를 인자로 해서 슈퍼 타입의 생성자를 호출하는 방법 입니다.

### 퍼사드 패턴

- 퍼사트 패턴은 기존 객체에 새로운 인터페이스를 만들 때 사용하는 인기 있는 디자인 패턴 입니다.
- 퍼사드는 시존 객체를 보이지 않는 곳에 두고 이용하는 완전히 새로운 객체 입니다.
- 다른 말로 래퍼(wrapper)라고도 불리는데 기존 객체를 감싸 다른 인터페이스를 제공하기 떄문입니다.
- 상속을 사용할 수 없을 때는 퍼사드를 만드는 것이 좋습니다.
- 퍼사드는 인터페이스를 통해 기반 객체를 완벽하게 제어할 수 있어서 유지보수가 수월한 자바스크립트 코드를 작성하는 데 좋은 패턴입니다.
- 기반 객체의 프로퍼티나 메서드에 접근 허용 여부를 효과적으로 제어할 수도 있고 새로운 메서드를 추가해 기존 객체를 그대로 사용할 때보다 원하는 동작을 더 간단하게 수행할 수도 있습니다.
- 기반 객체가 변경되어도 애플리케이션에 영향 없이 퍼사드만 수정하면 되는 장점도 있습니다.
- 퍼사드는 한 객체에 다른 인터페이스를 구현한다는 면에서 어댑처와 유사합니다. 그러나 퍼사드는 새로운 인터페이스를 생성하지만 어댑터는 기존 인터페이스를 재활용한다는 점이 다릅니다.

## 폴리필이란?

- 자바스크립트에서 심(shim)으로도 알려진 폴리필(pollyfill)은 브라우저에서 ECMAScript5와 HTML5의 기능을 지원하면서부터 유명해졌습니다.
- 폴리필은 최신 브라우저에 이미 구현된 기능을 따로 구현하는 것을 의미합니다.
- 폴리필은 객체에 새로운 메서드를 추가해 객체의 목적과 다르게 할 수도 있습니다.
- 유지보수를 위해서는 폴리필 보다는 기존 네이티브 객체에 퍼사드를 사용하는 편이 좋습니다.
- 퍼사드는 기존 객체를 유연하게 처리할 수 있는 장점이 있어 네이티브 기능에 버그가 있을 때 사용하면 좋습니다. 구현 상의 버그가 있는 네이티브 API를 그대로 사용했다가는 문제가 발생할 수 있기 때문입니다.

## 객체 변경을 방지하는 방법

- 변경 방지를 위한 잠금 타입으로는 총 3단계가 있습니다.
  - 확장 방지(Prevent Extension) : 객체에 새로운 프로퍼티나 메서드를 추가할 수는 없지만 삭제와 수정은 가능합니다.
  - 봉인(Seal) : 확장 방지 단계와 같지만 프로퍼티와 메서드를 삭제할 수 없습니다.
  - 불변(Freeze) : 봉인 단계와 같지만 모든 필드가 읽기 전용으로, 프로퍼티오하 메서드를 변경할 수 없습니다.
- 잠금 타입마다 두 개의 메서드가 있는데 하나는 특정 단계로 객체를 잠그는 메서드 이고 다른 하나는 잠겨 있는지 확인하는 메서드 입니다. 하ㅗㄱ장 방지 단계를 Object.preventExtensio()와 Object.isExtensible()이 있습니다.
- ECMAScript5 메서드를 이용한 객체 변경 방지는 객체가 우리도 모르는 사잉 ㅔ변경되는 것을 막을 수 있는 확실한 방법입니다.
- 일단 객체를 잠그면 되돌릴 수 없습니다.
- 객체를 잠그기로 결정했다면 strict 모드를 사용할 것을 강력하게 권장합니다. strict 모드가 아닐 때는 잠긴 객체를 변경해도 아무런 경고 메시지 없이 변경하려는 내용이 적용되지 않아 디버깅이 힘들어 질 수 있습니다.
