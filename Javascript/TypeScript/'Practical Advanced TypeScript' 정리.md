# 'Practical Advanced TypeScript' 정리

- 내용이 너무 어려워 대충 정리만 해서 나중에 자세히 읽어보고 수정할 필요를 많이 느낀다 ...

## Numeric Separator를 사용하여 큰 수를 다루기

- 사용하기 위해서 number 타입의 숫자에 구분을 하고 싶은 부분에 \_ (언더스코어)를 넣으면 된다.

## 더욱 철저한 속성 초기화

```javascript
class Library {
  titles: string[];

  constructor() {}
}
const library = new Library();
```

- 기본값을 입력하지 않을 것이라면 titles: string[] | undefined 같은 식으로 타입을 정의하고 받아 쓰는 쪽에서 타입 가드를 할 필요가 있다. 아니면 제대로 constructor 쪽에서 titles 를 정의해주는게 나을 수 있다.
- 의존성 주입 등으로 인해 런타임에서 titles 가 결정되고, 컴파일러가 이 사실을 신경 쓸 필요가 없다면 느낌표(!)를 속성 뒤에 붙여서 명시적으로 ‘이 속성은 지금 신경쓰지 않아도 된다’ 라고 표시할 수도 있다.

## in 연산자를 활용한 자동 타입 추론

- 일일이 타입 가드를 정의하는 것도 좀 귀찮은 일이다. 원래 자바스크립트에는 in 이라는 연산자가 있다. prop in object 같은 방식으로 사용하면 “이 object 에 prop 이라는 속성이 있는가?” 여부를 boolean 값으로 리턴한다. 타입스크립트에서 조건문에 in 연산자를 활용하면 자연스럽게 타입 가드를 해 준다.

## Switch 문에서 자동으로 타입 추론하기

- 타입스크립트 컴파일러는 case 'Add' 를 거쳐 왔음에도 payload 라는 속성이 있다는 사실을 받아들이지 못한다. 보통은 이런 경우 Action 이라는 인터페이스를 확장하겠지만, payload 에 들어올 수 있는 타입의 추론이 또 문제가 된다.
- 여기서 재밌는 사실이 있는데, readonly type: string = 'Add' 같이 되어있는 부분에서 string 이라고 타입 선언을 제거해주면 type 이라는 속성은 'Add' 라는 상수 타입이 된다.
- 여기서 readonly 를 빼면 다시 string 타입으로 바뀐다. 왜냐면 readonly 는 바뀔 일이 없는 속성이지만, 그게 아니라면 외부의 요인에 의해 바뀔 수 있기 때문이다. 그럼 이제 상수 타입을 활용하여 액션을 확장해보자.
- 이 상태에서는 switch 문 분기마다 action 의 타입이 정확하게 추론된다. 반사이익으로 TodoActions 에 새로운 타입이 추가되었다고 할 때 switch 문에서 제대로 다 다루지 않거나 하면 오류가 나타난다.
- 좌에서는 언급되지 않았으나 enum 을 활용하는게 더 낫다.

## Mapped Type을 수정하기

- 대개 하나의 객체가 어떤 속성의 집합으로 이루어질 수 있는지 쉽게 정의할 수 있다.
- 아래와 같이 Pet 이라는 타입을 정의하고 그 모든 속성이 readonly 인 ReadonlyPet 으로 확장할 수도 있다.
- Pet 에 새로운 옵셔널 속성을 추가하되 ReadonlyPet 에서는 모든 속성이 반드시 있어야 한다고 정의하려면 어떻게 해야 할까? Mapped Type을 정의할 때 특수하게 +, ? 연산자를 사용하여 특정 심볼을 더하거나 제거할 수 있다.
- \+ 연산자는 특별할 것은 없지만 읽는 사람에게 ‘이 속성을 추가한다’ 는 것을 더 명시적으로 보여줄 수는 있을 것이다.

## 타입과 인터페이스의 차이

- 두 가지 모두 무언가 구조를 정의할 때 사용할 수 있습니다. 서로 다른 타입과 결합도 가능합니다(interface - extends, type - &).
- 두 형태의 타입 정의 방식을 교차해서 사용할 수도 있습니다. type이 interface나 다른 type과 함께 결합될 수도 있고, 클래스에 extends, implements 를 쓸 때 interface뿐 아니라 type도 가져올 수 있습니다. 하지만 유니언 타입은 extends, implements 에 사용될 수 없습니다.
- type은 같은 파일 안에서 두 번 선언 될 수 없지만, interface는 중복 선언될 경우 타입 결합과 동일하게 동작합니다. 이 원리를 활용하여 라이브러리의 타입을 확장하는데도 사용할 수 있습니다.
- 따라서 당신이 라이브러리 작성자라면 공개되는 타입 형태를 interface로 내보내어 사용자들이 필요할 경우 확장하기 쉽게 만들어 주세요.

## 자기 자신을 참조하는 타입 만들기

- 일반적으로 타입을 정의할 때 하나의 계층, 좀 크면 두개의 계층 정도까지 생각하게 된다.
- 그런데 트리나 연결 리스트같은 자료구조라면 사용하기에 따라 아주 깊은 계층까지 형성될 수 있다. 그리고 참조하는 노드의 구조(타입)은 동일하다.
- 이 원리를 어떻게 활용할 수 있을까? 리덕스의 개발자 도구나 리덕스의 장점 중 하나인 undo/redo 가 용이하다는 것을 떠올려보면 되겠다. 만약 내가 이전에 사용했던 액션으로 돌아가보고 싶다면? 위에 정의한 것과 비슷하게 ListNode 타입을 만들어볼 수 있겠다.
- 하지만 .next 를 마구마구 찍어볼 수 있기 때문에 어느 순간에 undefined 가 나올 수 있다. 안전하게 호출하고자 한다면 do/while 문 같은것을 활용하여 다음 노드가 있는지 확인하면서 탐색을 할 수 있겠다.

## 이터레이터를 이용하여 커스텀 자료 구조의 순회를 단순하게 만들기

- 아만들어둔 이터레이터를 이용한다면 next 메서드 호출 뿐 아니라 for..of, 전개 연산자같이 이터러블 프로토콜을 사용하는 조작은 모두 사용할 수 있다. 다만 컴파일 할때는 타겟을 ES6 이상으로 해 주어야 한다. 하위 호환성을 챙기려면 바벨과 함께 사용해야 한다.

## unknown 타입 활용하기

- 점진적으로 타입스크립트를 도입하는 환경이나 어떤 값이든 될 수 있는 변수의 타입을 정의할 때 any 타입을 많이 사용하게 된다. 하지만 이후 컴파일러가 이 변수에 대한 타입 체킹을 전혀 하지 않기 때문에 문제가 될 수 있는데, 타입스크립트 3.0부터 추가된 unknown 타입이 많은 문제를 해결해줄 수 있다.
- 꼭 알아두어야 할 핵심은 어떤 변수에 unknown 타입을 할당한 경우 그 변수는 반드시 어떤 타입인지 타입 가드를 거치거나 타입 지정을 해 주어야 오롯이 지정된 타입으로 사용할 수 있다는 것이다.

## 조건부 타입을 사용하여 함수의 타입을 동적으로 할당하기

## 조건부 타입을 활용하여 재사용할 수 있는 평탄한 타입(Flatten Type) 만들기

- 조건부 타입은 삼항 연산자의 연산 방식과 비슷하게 동작하기 때문에 중첩하여 사용할 수 있다. 따라서 두 가지 이상의 조건을 결합하여 타입을 계산하게 만들 수 있다.

## 제네릭 함수 타입이 어떤 타입으로 리턴되는지 추측하기

- 여기서 infer 키워드가 유용하게 사용된다. 키워드를 사용하여 ‘해당 타입의 추론을 하라’고 타입스크립트 엔진에게 시키는 것이다. 아래의 ReturnType 을 보자. 이 타입은 원래 타입스크립트 2.8버전부터 기본으로 들어있기 때문에 직접 구현할 필요는 없다.
- 함수 타입 F 의 리턴 타입을 추론할 수 있다면 추론된 R 이라는 타입을 리턴하고, 할 수 없다면 any 를 리턴하게 만드는 타입이다. 좀 더 빡빡한 타입 정의를 하고자 한다면 any 를 never 로 만들 수도 있겠다.
- 다른 사용 예로 프라미스(Promise) 객체 안에 있는 값의 타입을 편하게 꺼내려 할 때도 infer 키워드를 사용하면 런타임에서 결정되는 타입을 손쉽게 정의할 수 있다.

## 중첩된 객체의 모든 속성을 read-only 타입으로 만들기

- 리덕스(Redux)를 사용하다 보면 state 는 불변(이뮤터블) 객체여야 한다. 그렇다면 같이 일하는 팀원이나 내가 만든 리덕스 관련 라이브러리를 사용하는 사람이 이 값을 실수로 재할당하는 일이 없으면 좋을 것이다. (물론 타입스크립트 사용자여야겠지만)

## 데코레이터를 사용하여 클래스의 속성을 동적으로 초기화하기

- 이 강좌는 데코레이터 중에서도 속성 데코레이터를 다루고 있다. 데코레이터를 어떻게 만드는지 문서를 간단히 참고해보는 것을 추천한다.
  또한 공식 문서에서는 reflect-metadata 를 활용하고 있다. 데코레이터 제안이 Stage 2에 머물러 있긴 하지만, 정식으로 채용되면 자연스럽게 Reflect.metadata 도 사용 가능하기 때문이다.

---

참조 : ['Practical Advanced TypeScript' 정리](https://rinae.dev/posts/practical-advanced-typescript-summary)
