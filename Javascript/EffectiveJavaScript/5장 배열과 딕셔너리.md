# 5장 배열과 딕셔너리

## 아이템 43. 직접적인 객체의 인스턴스로 가벼운 딕셔너리를 만들어라

- 객체 리터럴을 사용해 가벼운 딕셔너리를 만들어라.
- 가벼운 딕셔너리는 for...in 반복문 내에서의 프로토타입 오염을 막기 위해 Object.prototype의 직접적인 자손이어야만 한다.

## 아이템 44. 프로토타입 오염을 막기 위해 null 프로토타입을 사용하라

- ES5에서는, Object.create(null)을 사용해서 프로토타입이 없고 오염에 덜 민감한 빈 객체를 생성하라.
- 오래된 실행 환경에서는 , {\_\_proto\_\_: null}의 사용을 고려하라.
- 하지만 \_\_proto\_\_가 비표준이고 이식성이 좋지 않으며 미래의 자바스크립트 환경에서 제거될 수 있다는 점에 주의하라.
- 딕셔너리의 키로 "\_\_proto\_\_"라는 이름을 절대 사용하지 마라. 몇몇 실행 환경에서는 이 프로퍼티를 특별하게 처리할 수 있다.

## 아이템 45. 프로토타입 오염을 막기 위해 hasOwnProperty를 사용하라

- 프로토타입 오염을 막기 위해 hasOwnProperty를 사용하라.
- hasOwnProperty 메서드의 오버라이딩을 막기 위해 어휘적인 스코프와 call 메소드를 사용하라.
- 딕셔너리의 연산들을 본문 내용 중에 설명한 has-메서드 같은 hasOwnProperty 테스트 상용문(boilerplate code)을 포함한 클래스로 구현하는 것을 고려하라.
- "\_\_proto\_\_"가 키로 사용되는 것을 막기 위해 딕셔너리 클래스를 사용하라.

## 아이템 46. 순서가 정해진 컬렉션에는 딕셔너리 대신 배열을 사용하라

- for...in 반복문이 객체의 프로퍼티를 열거할 때 순서에 의존하지 않도록 하라.
- 딕셔너리 안의 데이터를 합한다면, 그 연산이 순서에 민감하지 않은지 확인하라.
- 순서가 정해진 컬렉션을 위해서는 딕셔너리 객체 대신 배열을 사용하라.

## 아이템 47. Object.prototype에 열거 가능한 프로퍼티를 절대 추가하지 마라

- Object.prototype에 프로퍼티를 추가하지 마라.
- Object.prototype에 메서드를 작성하는 대신 함수를 고려하라.
- Object.prototype에 프로퍼티를 추가한다면, ES5의 Object.defineProperty를 사용해서 열거할 수 없는 프로퍼티로 정의하라.

```javascript
Object.defineProperty(Object.prototype, 'allKeys', {
  value: function() {
    var result = [];
    for( var key in this) {
      result.push(key);
    }
    return result;
  }
  writable: true,
  enumerable: false,
  configurable: true
});
```

## 아이템 48. 열거하는 동안 객체를 수정하지 마라

- for...in 반복문으로 객체의 프로퍼티를 열거하는 동안 객체를 수정하지 마라.
- 반복문 내에서 내용이 변경될 수 있는 객체를 반복할 때는 for...in 대신 while이나 전통적인 for 반복문을 사용하라.
- 데이터 구조가 변경될 수도 있는 열거에는, 딕셔너리 객체 대신에 배열 같은 순차적인 데이터 구조의 사용을 고려하라.

## 아이템 49. 배열을 반복할 때 for...in 대신 for 반복문을 사용하라

- 인덱스가 지정된 배열의 프로퍼티를 반복할 때는 for...in eotls for 반복문을 사용하라.
- 프로퍼티 검색을 재계산하지 않기 위해 벼열의 length 프로퍼티를 반복문 앞에 지역 변수로 저장하는 것을 고려하라.

## 아이템 50. 반복문 대신 반복 메서드를 사용하라

- 코드를 더 가독성 높에 만들고 loop 제어 로직의 복제를 막기 위해서 for 반복문 대신에 Array.prototype.forEach와 Array.prototype.map과 같은 반복 메서드를 사용하라.
- 표준 라이브러리가 제공하지 않는 공통적인 반복 패턴을 추상화하기 위해 사용자 정의 반복 함수를 사용하라.
- 이른 종료가 필요한 경우에는 전동적인 반복문이 여전히 유용한데, 이를 위한 대안으로 some과 every 메서드를 사용할 수도 있다.

## 아이템 51. 유사 배열 객체에 범용적인 배열 메서드를 재사용하라

- 범용적인 Array 메서드들을 메서드 객체로 추출하고 call 메서드를 사용하여 유사 배열 객체에 재사용하라.
- 어떤 객체든 인덱싱된 프로퍼티와 적절한 length 프로퍼티를 가진다면 범용적인 Array 메서드를 사용할 수 있다.

## 아이템 52. Array 생성자 대신 배열 리터럴을 사용하라

- Array 생성자는 첫 번째 인자가 숫자일 때 다르게 동작한다.
- Array 생성자 대신에 배열 리터럴을 사용하라.
