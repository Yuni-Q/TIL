# 4장 객체와 프로토타입

## 아이템 30. prototype, getPrototypeOf, \_\_proto\_\_의 차이점을 이해하라

- C.prototype은 new C()로 생성된 객체의 프로토타입을 결정한다.
- Object.getPrototypeOf(obj)는 객체의 프로토타입을 가져오기 위한 표준 ES5 함수이다.
- obj.\_\_proto\_\_는 객체의 프로토타입을 가져오기 위한 비표준 메커니즘이다.
- 클래스는 생성자 함수와 연관된 프로토타입으로 구성된 설계 패턴이다.

## 아이템 31. \_\_proto\_\_보다 Object.getPrototypeOf를 사용하라.

- 비표준 \_\_proto\_\_ 프로퍼티를 사용하기 보다 표준을 준수하는 Object.getPrototypeOf를 사용하라.
- \_\_proto\_\_를 지원하고 ES5를 지원하지 않는 실행 환경에 Object.getPrototypeOf를 구현하라.

```javascript
if(typeof Object.getPrototypeOf === 'undefined') {
  Object.getPrototypeOf = function(obj) {
    var t= typeof obj;
    if(!obj || (t ! == 'object' && t !== 'function')) {
      throw new TypeError('not an object');
    }
    return obj.__proto__;
  };
}
```

## 아이템 32. \_\_proto\_\_를 절대 수정하지 마라

- 객체의 \_\_proto\_\_를 절대 수정하지 마라.
  - 모든 플랫폼이 객체의 프로토타입 수정을 지원하지는 않기 때문에 간단하게 이식성 있는 코드를 작성할 수가 없다.
  - \_\_proto\_\_를 수정하는 행위는 시렞로 상속 구조 자체를 변경하는 행위이고, 실행 가능한 가장 파괴적인 수정이다. 일반적인 프로퍼티를 수정하는 것보다 훨씬 더 많은 최적화를 무효화 시킬 수 있다.
  - 예측 가능한 동작을 유지할 수 없다.
- 새로운 객체에 임의ㅗㄹ 지정된 프로토타입을 제공하기 위해 Object.getPrototypeOf을 사용하라.

## 아이템 33. 생성자가 new와 관계 없이 동작하게 만들어라

- 자기 자신을 new로 다시 호출하거나 Object.create를 사용해서 생성자가 호출자의 무법에 관계없이 동작할 수 있게 하라.

```javascript
function User(name, passswprdHash) {
  if (this instanceof User) {
    return new User(name, passwordHash);
  }
  this.name = name;
  this.passwordHash = passwordHash;
}
```

- 함수가 new로 호출되기를 기대한다면, 이에 대해 명백하게 문서화하라.

## 아이템 34. 메서드를 프로토타입에 저장하라

- 인스턴스 객체에 메서드를 저장하면 인스턴스 객체당 함수가 하나씩 복사되어, 여라개가 복사된다.
- 인스턴스 객체에 메서드를 저장하기보다 프로토타입에 메서드를 저장하라.

## 아이템 35. 비공개 데이터를 저장하기 위해 클로저를 사용하라

- 클로저 변수는 비공개이고, 지역적인 참조로만 접근할 수 있다.
- 메서드 안에 강제로 정보를 숨기기 위해 비공개 데이터로써 지역 변수를 사용하라

## 아이템 36. 인스턴스의 상태는 인스턴스 객체에만 저장하라

- 수정 가능한 데이터는 공유 시 문제의 소지가 있으며, 프로토타입은 모든 인스턴스 간에 공유된다.
- 각 인스턴스의 수정 가능한 상태 값은 인스턴스 객체에 저장하라.

## 아이템 37. this의 명시적인 바인딩에 대해 이해하라

- this의 스코프는 항상 가장 가까이서 둘러싼 함수에 의해 결정된다.
- 내부 함수에서 this 바인딩을 사용할 수 있도록, 보총 self, me, that 같은 이름의 지역 변수를 사용하라.

## 아이템 38. 하위 클래스 생성자에서 상위 클래스 생성자를 호출하라

- 하위 클래스 생성자에서 상위 클래스 생성자를 명시적으로 호출하라. 이때 this를 명시적인 수신자 객체로 전달하라.
- 상위 클래스 생성자를 호출하지 않기 위해 Object.create를 사용해 하위 클래스의 프로토타입 객체를 생성하라.

## 아이템 39. 상위 클래스 프로퍼티 이름을 절대 재사용하지 마라

- 상위 클래스가 사용하는 모든 프로퍼티 이름에 대해 알아두어라.
- 상위 클래스의 프로퍼티 이름을 절대로 하위 클래스에서 재사용하지 마라.

## 아이템 40. 표준 클래스를 상속하지 마라

- 표준 클래스를 상속하면 \[[Class]] 같은 특별한 내부 프로퍼티 때문에 오동작할 수 있다.
- 표준 클래스를 상속하는 대신 프로퍼티로 위임하라.

## 아이템 41. 프로토타입을 세부 구현 사항처럼 처리하라

- 객체는 인터페이스다. 프로토타입은 구현 세부 사항이다.
- 직접 제어하지 않는 객체의 프로토타입 구조를 검사하지 마라.
- 직접 제어하지 않는 객체의 내부를 구현하는 프로퍼티를 검사하지 마라.

## 아이템 42. 무모한 몽키 패칭을 하지 마라

- 무모한 몽키 패칭을 삼가하라.
- 라이브러리가 수행하는 모든 몽키 패칭에 대해 문서화 하라.
- 몽키 패칭을 선택적으로 가능하도록, 노출된 함수에서 변경을 실행하게 만드는 것을 고려하라.
- 표준 API가 없는 경우에 폴리필을 제공하기 위해 몽키 패칭을 사용하라.
