# 2장 변수 스코프

## 아이템 8. 전역 객체의 사용을 최소화 하라

- 전역 변수를 선언하지 마라.
- 가능하면 변수를 지역적으로 선언하라.
- 전역 객체에 프로퍼티를 추가하지 마라.
- 플랫폼의 기능 탐지를 위해 전역 객체를 사용하라.

## 아이템 9. 항상 지역 변수를 선언하라

- 새로운 지역 변수는 항상 var를 사용해서 선언하라(ES2015 이후에는 let과 const를 활용)
- 바인딩되지 않은 변수를 확인하는 데 도움을 주는 lint 도구의 사용을 고려해 보라.

## 아이템 10. with를 사용하지 마라

- with 선언문을 사용하지 마라.
- 객체로의 반복되는 접근을 위해 짧은 변수 이름을 사용해라.
- with 선언문으로 암묵적인 바인딩하는 대신 명시적으로 지역 변수를 객체 프로퍼티에 바인딩하라.

## 아이템 11. 클로저에 익숙해져라

- 자바스크립트는 현재 함수 외부에서 선언된 변수를 참조할 수 있다.
- 함수는 외부 함수가 무언가를 리턴한 이후에도 이 외부 함수에 선언 된 변수를 참조할 수 있다.
  - 이 사실이 이해하기 힘들다면, 자바스크립트 함수가 일종 객체(first-class object)라는 사실을 기억하라
  - 이는 내부 함수를 리턴할 수 있고, 이 함수가 나중에 다시 호출될 수 있다는 뜻이다.
- 클로저가 외부 변수의 값을 변경 할 수 있다는 점이다.
  - 클로저는 실제로 외부 변수의 값을 복사하지 않고 참조를 저장한다. 따라서 그들에게 접근하는 어떤 클로저도 변경사항을 볼 수 있다.

### 기억할 점

- 함수는 외부 스코프에 선언된 변수를 참조할 수 있다.
- 클로저는 자신을 생성한 함수보다 더 오래 지속된다.
- 클로저는 내부적으로 외부 변수에 대한 참조를 저장하고, 저장된 변수를 읽고 갱신 할 수 있다.

## 아이템 12. 변수 호이스팅에 대해 이해하라

- 블록 내에서의 변수 선언은 암묵적으로 그 변수를 포함하는 함수의 맨 윗부분으로 호이스팅 된다.
- 변수의 재선언은 하나의 변수처럼 처리된다(var 기준 / let, const는 재선언이 불가능 하다)
- 혼란을 막기 위해 지역 변수 선언을 직접 호이스팅하는 것을 고려하라(var의 경우)
- trt...catch는 exception을 잡아 변수로 바인딩하고, 해당 변수는 catch 블록 안에서만 스코프가 적용 된다.

## 아이템 13. 지역 변수 스코프를 만들기 위해 즉시 실행 함수 표현식을 사용하라

- 바인딩과 할당의 차이점을 이해하라.
- 클로저는 외부 변수의 값이 아닌 참조를 저장한다.
- 지역 스코프를 만들기 위해 즉시 실행 함수 표현식을 사용해라.
- IIFE에서 블록으로 감쌌을 때 변화하는 상황에 주의하라.

## 아이템 14. 기명 함수 표현식의 스코프에 주의하라

- Error 객체와 디거거에서 스택 추적을 개선하기 위해 시명 함수 표현식을 가용하라.
- ES3과 버그가 있는 자바스크립트 실행 환경에서 함수 표현식이 스코프를 Object.prototype를 오염시킨다는 점을 주의하라.
- 버그가 있는 자바스크립트 실행 환경에서 기명 함수 포현식의 호이스팅과 중복 할당을 주의하라.
- 기명함수 표현식의 사용을 자제하고, 배포하기 전에 제거하라.
- ES5를 제대로 구현한 실행 환경에 배포한다면, 아무런 걱정을 할 필요가 없다.

## 아이템 15. 블록-지역 함수 선언문의 스코프에 주의하라.

- 실행 환경에 따라 다르게 동작할 수 있는 여지가 있으므로, 함수 선언문은 이르 포함하는 함수나 프로그램의 가장 바깥에 두어라.
- 조건적인 함수 선언문 대신, 조건적인 할당문을 이용해 var 선언문을 사용하라.

## 아이템 16. eval을 이용해 지역 변수를 생성하지 마라

- 호출자의 스코프를 어지럽힐 수 있으므로 eval을 통한 변수 생성을 자제하라.
- eval 코드가 전역 변수를 생성할 가능성이 있다면, 스코프 오염을 막기 위해 감싸진 함수 안에서 호출하라.

## 아이템 17. 직접적인 eval보다 간접적인 eval을 사용하라

- eval을 무의미한 리터럴과 함께 연속 표현식으로 감싸서 간접적인 eval로 사용되도록 강제하라.
- 언제든지 가능하다면 직접적인 eval보다는 간접적인 eval을 사용하라.
