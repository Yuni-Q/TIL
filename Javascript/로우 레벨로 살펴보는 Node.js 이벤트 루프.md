# 로우 레벨로 살펴보는 Node.js 이벤트 루프

## 대표적인 잘못된 개념들

# 이벤트 루프는 자바스크립트 엔진 내부에 있다

- 대표적인 잘못된 개념들 중 하나는 바로 이벤트 루프가 자바스크립트 엔진(V8, Spider Monkey 등)의 일부라는 것이다. 하지만 이벤트 루프는 단지 자바스크립트 코드를 실행하기위해 자바스크립트 엔진을 이용하기만 할 뿐이다.(역주: 실제로 V8 엔진에는 이벤트 루프를 관리하는 코드가 없다. Node.js나 브라우저가 이벤트 루프를 담당하는 것)

## 이벤트 루프는 하나의 스택 또는 하나의 큐로만 작동한다

- 먼저, 이벤트 루프에 작업을 담아놓는 스택 같은 것은 존재하지 않는다. 그리고 이벤트 루프가 작동하는 과정은 여러 개의 큐(자료구조에서의 그 큐 맞다.)를 사용하는 복잡한 과정이다. 그러나 대부분의 개발자들은 자바스크립트의 모든 콜백이 단 하나의 큐만 사용하여 수행된다고 알고 있는데, 이것은 완전히 잘못된 생각이다.

## 이벤트 루프는 여러 개의 스레드에서 실행된다

- Node.js 이벤트 루프의 잘못된 다이어그램들 때문에 우리는 한 개의 스레드가 자바스크립트의 실행을 담당하고 다른 한 개는 이벤트 루프를 담당하는, 총 두 개의 스레드가 있다고 생각하게 되었다.(필자도 자바스크립트 뉴비 시절에 그렇게 생각했다.)
- 그러나 실제로는 단일 스레드로 이 모든 것을 처리한다.

## setTimeout은 일부 비동기 OS API와 관련있다.

- 또 다른 큰 오해는 setTimeout의 딜레이가 끝났을 때 콜백이 외부의 요인으로 인해(OS나 커널 같은) 의해 어떤 작업 큐에 들어가게 된다고 생각하는 것이다. 하지만 이벤트 루프에 이런 외부의 요인 같은 건 없다. 우리는 밑에서 이 메커니즘에 대해서 좀 더 자세히 알아볼 것이다.

## setImmediate의 콜백은 작업 큐의 가장 첫번째에 위치한다

- 보통 일반적인 이벤트 루프에 대한 설명들은 하나의 큐만 가지고 설명을 진행하기 때문에, 몇몇 개발자들은 setImmediate()가 콜백을 작업 큐의 가장 앞쪽에 배치하는 API라고 생각하게 된다. 하지만 이것은 완전히 틀린 생각이며, 모든 작업 큐들은 FIFO(First In First Out)로만 작동한다.(역주: 큐에 들어있는 작업의 포지션을 절대 변경하지 않는다는 것이다. 무조건 큐에 먼저 들어간 작업이 먼저 실행된다.)

## 이벤트 루프의 구조

- 일단 이벤트 루프의 구조를 이해하기 위해서는 이벤트 루프의 흐름에 대해서 알고 있어야 한다. 이미 한번 언급했듯이, 거시적인 하나의 큐만 보는 것은 이벤트 루프를 이해하는 데 별로 도움이 되지 않는다. 아래 그림이 이벤트 루프를 제대로 설명한 그림이다.

## 짧은 정리들

- 이벤트 루프는 작업 스택을 가지고 있지 않다.
- 이벤트 루프가 별도의 스레드에서 실행되고 자바스크립트 실행은 어떤 큐에서 하나씩 꺼내와서 다른 곳에서 하는 것이 아니라 자바스크립트의 실행 자체가 이벤트 루프 안에서 수행되는 것이다.
  setImmediate는 콜백을 작업 큐의 앞 쪽에 밀어넣는 것이 아니라 setImmediate 만을 처리하기 위한 전용 페이즈와 큐가 존재한다.
- setImmediate은 실질적으로 다음 페이즈 혹은 다음 이벤트 루프의 순회에서 실행되고, nextTick이 오히려 실질적으로 더 빠르게 실행된다.
- nextTickQueue에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다. 주의하도록 하자.

## 이벤트 루프의 전체 알고리즘

1. 매크로태스크 대기열에서 가장 오래된 작업을 꺼내어 실행합니다. (예: 스크립트 실행)
2. 모든 마이크로태스크를 실행합니다. (마이크로태스크 대기열이 비어있지 않다면 가장 오래된 마이크로태스크를 대기열에서 꺼내어 실행합니다.)
3. DOM 변경사항이 있는 경우 렌더링합니다.
4. 매크로태스크 대기열이 비었다면, 다른 매크로태스크가 생길 때까지 기다립니다.
5. 처리할 매크로태스크가 생기면 1번으로 돌아갑니다.

### 매크로태스크의 특징

- 딜레이가 0인 setTimeout(func) 을 사용합니다.
- setTimeout은 큰 계산이 요구되는 무거운 작업을 작게 쪼개어 주고 브라우저가 사용자 이벤트에 반응하고 나눠진 작업들 사이에서 진행 상태를 표시할 수 있게 해줍니다.
- 또한, 이벤트가 완전히 처리된 후에 특정 액션에서 이벤트 핸들러가 실행되도록 예약하는 데도 사용될 수 있습니다.

### 마이크로태스크의 특징

- promise 객체의 핸들러들이 마이크로 태스크에 들어갑니다.
- 마이크로태스크 사이에서는 어떠한 UI 혹은 네트워크 변화가 없습니다. 마이크로태스크는 즉시 다음 마이크로 태스크를 실행하기 때문입니다.
- 따라서 사용자는 함수를 비동기식으로 실행하기 위해 queueMicrotask() 를 사용할 수 있지만, 올바른 환경에서 사용해야합니다.

---

## 참조

- [로우 레벨로 살펴보는 Node.js 이벤트 루프](https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/?fbclid=IwAR1QP82JVrNfICEK1UNYGIDnrIlmzzD70AYYcEPiAnW9QzMH26GDker1-B8)
- [자바스크립트 이벤트 루프: 마이크로태스크(Microtasks)와 매크로태스크(Macrotasks)](https://medium.com/official-podo/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%83%9C%EC%8A%A4%ED%81%AC-microtasks-%EC%99%80-%EB%A7%A4%ED%81%AC%EB%A1%9C%ED%83%9C%EC%8A%A4%ED%81%AC-macrotasks-4563cdc324b0)
