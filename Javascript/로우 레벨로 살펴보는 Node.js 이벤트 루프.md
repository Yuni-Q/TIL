# 로우 레벨로 살펴보는 Node.js 이벤트 루프

## 대표적인 잘못된 개념들

# 이벤트 루프는 자바스크립트 엔진 내부에 있다

- 대표적인 잘못된 개념들 중 하나는 바로 이벤트 루프가 자바스크립트 엔진(V8, Spider Monkey 등)의 일부라는 것이다. 하지만 이벤트 루프는 단지 자바스크립트 코드를 실행하기위해 자바스크립트 엔진을 이용하기만 할 뿐이다.(역주: 실제로 V8 엔진에는 이벤트 루프를 관리하는 코드가 없다. Node.js나 브라우저가 이벤트 루프를 담당하는 것)

## 이벤트 루프는 하나의 스택 또는 하나의 큐로만 작동한다

- 먼저, 이벤트 루프에 작업을 담아놓는 스택 같은 것은 존재하지 않는다. 그리고 이벤트 루프가 작동하는 과정은 여러 개의 큐(자료구조에서의 그 큐 맞다.)를 사용하는 복잡한 과정이다. 그러나 대부분의 개발자들은 자바스크립트의 모든 콜백이 단 하나의 큐만 사용하여 수행된다고 알고 있는데, 이것은 완전히 잘못된 생각이다.

## 이벤트 루프는 여러 개의 스레드에서 실행된다

- Node.js 이벤트 루프의 잘못된 다이어그램들 때문에 우리는 한 개의 스레드가 자바스크립트의 실행을 담당하고 다른 한 개는 이벤트 루프를 담당하는, 총 두 개의 스레드가 있다고 생각하게 되었다.(필자도 자바스크립트 뉴비 시절에 그렇게 생각했다.)
- 그러나 실제로는 단일 스레드로 이 모든 것을 처리한다.

## setTimeout은 일부 비동기 OS API와 관련있다.

- 또 다른 큰 오해는 setTimeout의 딜레이가 끝났을 때 콜백이 외부의 요인으로 인해(OS나 커널 같은) 의해 어떤 작업 큐에 들어가게 된다고 생각하는 것이다. 하지만 이벤트 루프에 이런 외부의 요인 같은 건 없다. 우리는 밑에서 이 메커니즘에 대해서 좀 더 자세히 알아볼 것이다.

## setImmediate의 콜백은 작업 큐의 가장 첫번째에 위치한다

- 보통 일반적인 이벤트 루프에 대한 설명들은 하나의 큐만 가지고 설명을 진행하기 때문에, 몇몇 개발자들은 setImmediate()가 콜백을 작업 큐의 가장 앞쪽에 배치하는 API라고 생각하게 된다. 하지만 이것은 완전히 틀린 생각이며, 모든 작업 큐들은 FIFO(First In First Out)로만 작동한다.(역주: 큐에 들어있는 작업의 포지션을 절대 변경하지 않는다는 것이다. 무조건 큐에 먼저 들어간 작업이 먼저 실행된다.)

## 이벤트 루프의 구조

- 일단 이벤트 루프의 구조를 이해하기 위해서는 이벤트 루프의 흐름에 대해서 알고 있어야 한다. 이미 한번 언급했듯이, 거시적인 하나의 큐만 보는 것은 이벤트 루프를 이해하는 데 별로 도움이 되지 않는다. 아래 그림이 이벤트 루프를 제대로 설명한 그림이다.

## 짧은 정리들

- 이벤트 루프는 작업 스택을 가지고 있지 않다.
- 이벤트 루프가 별도의 스레드에서 실행되고 자바스크립트 실행은 어떤 큐에서 하나씩 꺼내와서 다른 곳에서 하는 것이 아니라 자바스크립트의 실행 자체가 이벤트 루프 안에서 수행되는 것이다.
  setImmediate는 콜백을 작업 큐의 앞 쪽에 밀어넣는 것이 아니라 setImmediate 만을 처리하기 위한 전용 페이즈와 큐가 존재한다.
- setImmediate은 실질적으로 다음 페이즈 혹은 다음 이벤트 루프의 순회에서 실행되고, nextTick이 오히려 실질적으로 더 빠르게 실행된다.
- nextTickQueue에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다. 주의하도록 하자.

---

참조 : [로우 레벨로 살펴보는 Node.js 이벤트 루프
](https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/?fbclid=IwAR1QP82JVrNfICEK1UNYGIDnrIlmzzD70AYYcEPiAnW9QzMH26GDker1-B8)
