# V8

- V8은 독일 구글 개발 센터에서 만들어진 JavaScript 엔진입니다.
- 오픈 소스이고 C++로 작성되었다. 클라이언트쪽(Google Chrome)과 서버쪽(node.js) JavaScript 어플리케이션 모두에 쓰입니다.
- 속도를 높이기 위해서 V8은 인터프리터를 이용하는 대신 JavaScript 코드를 좀더 효율적인 기계어 코드로 번역합니다.
- SpiderMonkey나 Rhino(Mozilla)같은 많은 요즘의 JavaScript 엔진처럼 JIT(Just-In-Time) 컴파일러를 적용하여 JavaScript 코드를 실행할 때 컴파일하여 기계어 코드로 만듭니다.
- V8의 가장 큰 차이는 바이트코드 또는 다른 중간 코드를 생성하지 않는 다는 것이다.

## 자바스크립트 엔진 파이프라인

- 먼저, 자신이 작성한 자바스크립트 소스 코드에서부터 시작합니다.
- 자바스크립트 엔진은 소스 코드를 파싱해서 Abstract Syntax Tree(AST) 로 만듭니다. 그리고 AST를 바탕으로, 인터프리터는 바이트 코드를 생성합니다. 여기까지가 자바스크립트로 작성된 코드를 실제로 엔진이 실행하는 부분입니다.
- 코드를 더 빠르게 실행하기 위해, 바이트코드는 프로파일링 된 데이터와 함께 최적화 컴파일러(optimizing compiler)로 보내집니다. 이곳에서는 프로파일링 데이터를 기반으로 매우 최적화 된 기계어를 생성합니다. 만약 정확하지 않은 결과가 나왔다면 다시 deoptimizes하여 바이트 코드로 되돌립니다.

- 인터프리터(interpreter) : 최적화되지 않은 바이트코드(bytecode)를 빠르게 생성합니다.
- 최적화 컴파일러(optimizing compiler) : 매우 최적화된 기계어 코드(macine code)를 약간 시간을 들여서 생성합니다. 이 과정에서 바이트코드는 중간 언어(IR, intermediate representation)입니다. 만약 interpreter 모드라면 바이트코드를 하나씩 읽어서 실행하고, JIT 모드라면 바이트 코드를 기반으로 컴파일하여 수행합니다.
  - 바이트코드(Bytecode, portable code, p-code)는 특정 하드웨어가 아닌 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다. 하드웨어가 아닌 소프트웨어에 의해 처리되기 때문에, 보통 기계어보다 더 추상적이다.
  - JIT 컴파일(just-in-time compilation) 또는 동적 번역(dynamic translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. 이 기법은 프로그램의 실행 속도를 빠르게 하기 위해 사용된다.

## 쓰레드를 사용

- 메인 쓰레드 : 코드를 가져와서 컴파일하고 실행하는 곳
- 컴파일을 위한 별도의 쓰레드 : 별도의 쓰레드가 코드를 최적화하는 동안 메인 쓰레드는 쉬지 않고 코드를 수행할 수 있음
- 프로파일러 쓰레드 : 어떤 메소드에서 사용자가 많은 시간을 보내는지 런타임에게 알려주어 크랭크샤프트(최적화 컴파일러로서 고도로 최적화된 코드를 생산함)가 이들을 최적화할 수 있게 해줌
- 그 외 가비지컬렉터 스윕을 처리하기 위한 몇 개의 쓰레드가 있음

## Hidden class

- JavaScript는 프로토타입 기반 언어이다. 클래스가 없고 오브젝트는 복제하는(cloning) 프로세스를 이용해서 만들어진다.
- JavaScript는 동적으로 타입된다. 타입과 타입 정보는 명시적이지 않고 실행 중에 오브젝트의 프로퍼티가 덧붙여지고 삭제될 수 있다. 타입과 프로퍼티에 효율적으로 접근하는 것이 V8의 어려운 첫번째 도전과제였다.
- 오브젝트의 프로퍼티를 저장하고 프로퍼티가 저장된 곳을 알기 위한 동적인 탐색(lookup)을 하기 위해 dictionary-like 자료 구조를 사용하는 대신에(대부분의 JavaScript 엔진들이 하고 있다) V8은 타입 시스템을 내부적으로 표현하고 프로퍼티 접근 시간을 줄이기 위한 히든 클래스를 실행시간에 생성한다.
- V8은 생성자 함수가 프로퍼티를 정의할 때마다 새로운 히든 클래스를 생성하고 히든 클래스의 변화를 추적한다.
- 새 히든 클래스가 생성될 때마다 이전의 것은 대신 사용될 히든 클래스로 업데이트 된다.
- 다른 JavaScript Engine이 프로퍼티를 저장하기 위해서 사전식 데이터 구조를 이용하지만, V8은 hidden class를 이용한다. 이 둘의 차이는 단순하게 이야기해서 Hashing과 Pointer의 차이라고 할 수 있다.
- 기존에는 자바스크립트의 속성을 가져올 때 메모리상에서 객체 속성 위치를 찾아내는 비효율적인 방식을 사용
- V8은 객체에 새로운 프로퍼티를 추가할 때 hidden class를 생성하고, hidden class에 프로퍼티의 정적인 위치(offset)를 저장함으로써 실제 데이터가 저장되어 이는 위치에 대한 Pointer를 제공한다. 이로 인해 런타임에 데이터접근이 필요 없어지고, 고전적인 클래스 기반의 최적화를 할 수 있다. (위치 정보 해석할 필요가 없어져서 빨라진다)

## 코드 최적화

- V8이 각 프로퍼티에 대해 새로운 히든 클래스를 생성하기 때문에 히든 클래스는 최소한으로 생성되어야 한다. 그러기 위해선 오브젝트가 생성된 후에 프로퍼티를 더하는 것을 피하고 항상 오브젝트 멤버를 같은 순서로 선언해라(히든 클래스 여러 개 생성을 피하기 위해서).
- [업데이트] 다른 요령: 단형적(monomorphic) 연산은 같은 히든 클래스인 오브젝트들에만 적용되는 연산이다. V8은 함수를 호출할 때 히든 클래스를 생성하는데, 만약 다른 parameter 타입들로 다시 호출했다면 V8은 또다른 히든 클래스를 만들어야 한다: 다형적(polymorphic) 코드보다 단형적 코드를 선호해라.

## 어떻게 V8이 JavaScript 코드를 최적화 하는지 추가 예제들

- JavaScript 오브젝트로 만드는 비싼 boxing 연산을 피하기 위해 가능하면 31 bit signed number 를 사용해라.
- V8이 array를 다루기 위해 “Fast elements”를 사용하고 있는 지 확인해라. 그러니까, 키들이 듬성듬성있는 sparse array를 피해라. 또한, 미리 큰 array를 할당하는 것을 피해라. 자연스럽게 커지는 것이 낫다. 마지막으로 array 안의 엘리먼트들을 삭제하지 마라: 키 집합을 듬성듬성하게 만든다.

## V8 엔진은 왜 만들게 되었나?

- V8은 웹 브라우저 안에서 실행되는 JavaScript의 성능을 높이기 위해 처음 고안되었다.
- 구글 크롬에서 사용 중입니다.
- 노드js의 런타임으로도 사용됩니다.

- V8은 웹 브라우저 내부에서 자바스크립트 수행 속도의 개선을 목표로 처음 고안되었습니다. 속도 향상을 위해 V8은 인터프리터를 사용하는 대신 자바스크립트 코드를 더 효율적인 머신 코드로 번역합니다. 저스트인타임 컴파일러를 구현함으로써 코드를 실행 시에 자바스크립트 코드를 머신 코드로 컴파일하는데, 이는 스파이더몽키나 리노와 같은 현대적인 다른 자바스크립트 엔진에서도 마찬가지입니다. 주된 차이는 V8은 바이트코드와 같은 중간 코드를 생산하지 않는다는 점입니다.

- V8에는 원래 두개의 컴파일러가 있었다

  - 풀코드젠: 간단하고 매우 빠른 컴파일러로서 단순하고 상대적으로 느린 머신 코드를 생산합니다
  - 크랭크샤프트: 좀 더 복잡한 (저스트인타임) 최적화 컴파일러로서 고도로 최적화된 코드를 생산합니다

- V8 엔진은 또한 내부적으로 여러 개의 쓰레드를 사용합니다
- 메인 쓰레드는 독자들의 예상대로 코드를 가져와서 컴파일하고 실행하는 곳입니다
- 또한 컴파일을 위한 별도의 쓰레드가 있어서 이 쓰레드가 코드를 최적화하는 동안 메인 쓰레드는 쉬지 않고 코드를 수행할 수 있습니다
- 프로파일러 쓰레드는 어떤 메소드에서 사용자가 많은 시간을 보내는지 런타임에게 알려주어 크랭크샤프트가 이들을 최적화할 수 있게 해줍니다
- 그 외 가비지컬렉터 스윕을 처리하기 위한 몇 개의 쓰레드가 있습니다

- 자바스크립트 코드를 처음으로 수행할 때 V8은 풀코드젠을 이용해서 파싱된 자바스크립트 코드를 변형 없이 직접 머신 코드로 번역합니다. 이를 통해 머신 코드의 실행을 매우 빠르게 시작할 수 있습니다. V8은 이와 같이 중간 바이트코드를 이용하지 않기 때문에 인터프리터가 필요 없게 됩니다.
- 코드가 얼마간 수행된 다음 프로파일러 쓰레드는 충분한 데이터를 얻게 되고 어떤 메소드를 최적화할 지 알 수 있게 됩니다.
- 그러면 크랭크샤프트가 다른 쓰레드에서 최적화를 시작합니다. 크랭크샤프트는 자바스크립트의 추상구문트리를 고수준 정적단일할당(static single-assignment, SSA)으로 번역하는데 이를 하이드로젠(Hydrogen)이라고 부릅니다. 크랭크샤프트는 또한 하이드로젠 그래프를 최적화하고자 노력하기도 합니다. 대부분의 최적화가 이 수준에서 이루어집니다.

### 인라이닝

- 첫 번째 최적화는 미리 가능한 많은 코드를 인라이닝(inlining)하는 것입니다. 인라이닝이란 호출 지점(함수가 호출된 곳의 코드 위치)을 호출된 함수의 내용으로 바꾸는 과정입니다. 이러한 단순한 과정으로 이후의 최적화가 더욱 큰 의미를 가지게 됩니다.

### 히든클래스

- 자바스크립트는 프로토타입 기반의 언어입니다. 클래스라는 것은 없으며 객체는 복제 과정을 통해 생성됩니다. 자바스크립트는 또한 동적언어(dynamic programming language)이기 때문에 객체가 생성된 이후에도 속성을 쉽게 추가하거나 삭제할 수 있습니다.
- 같은 히든클래스를 재사용할 수 있도록 동적 속성을 같은 순서로 초기화하는 것이 훨씬 좋습니다.

### 인라인 캐싱

- V8가 최적화에 사용하는 또 다른 동적 타입 언어에서 사용할 수 있는 기술은 인라인 캐싱입니다. 인라인 캐싱은 같은 메소드에 대한 반복되는 호출은 같은 타입의 객체에 이루어진다는 관찰 결과에 의존합니다.
- V8은 최근 메소드 호출에 파라메터로 전달된 객체 타입의 캐시를 유지하고 이 정보를 이용해 앞으로 파라메터로 넘어올 객체의 타입에 대한 가정을 합니다. 만약 V8이 메소드에 전달될 객체 타입에 대한 가정을 잘 할 수 있으면 객체의 속성에 접근할 방법을 알아내는 과정을 수행하지 않아도 되며 그 대신 객체의 히든 클래스에 대해 이전에 찾아서 저장했던 정보를 사용할 수 있습니다. -히든클래스 와 인라인 캐싱의 개념은 서로 어떻게 관련 있을까? 특정 객체에 메소드가 호출될 때마다 V8엔진은 특정 속성에 접근하기 위한 오프셋을 계산하기 위해 해당 객체의 히든클래스를 뒤져봐야 합니다. 동일한 히든 클래스의 동일한 메소드에 대해 두 번의 성공적인 호출을 마치고나면 V8은 히든클래스를 찾는 것을 생략하고 단순하게 스스로 해당 객체 포인터에 속성 오프셋을 더해 놓습니다. 이후 해당 메소드에 대한 모든 호출에 대해 V8은 히든클래스는 변하지 않았다고 가정하고 이전에 찾아 두었던 오프셋을 이용해 직접 메모리 주소로 점프합니다. 이를 통해 실행 속도는 크게 증가합니다.
- 인라인캐싱은 같은 타입의 객체가 히든클래스를 공유하는 게 중요한 이유이기도 합니다. 만약 타입은 같고 히든 클래스는 다른 두 객체를 만들면 (앞서의 예제처럼) V8은

- 인라인캐싱을 사용할 수 없을 것입니다. 왜냐하면 두 객체가 같은 타입이기는 해도 각각에 대응하는 히든클래스가 그들의 속성에 서로 다른 오프셋을 할당하기 때문입니다.
  같은 메소드에 대한 반복되는 호출은 같은 타입의 객체에 이루어진다는 결과로 진행
- 객체 필드에 접근을 할 때 hidden class를 사용한다면 결국 우리가 얻고 싶은 것은 접근하려는 필드의 오프셋 값입니다. 간단히 말하면 인라인 캐싱은 이 오프셋 값을 캐싱하겠다는 이야기
- V8이 메소드에 전달될 객체 타입에 대한 가정을 잘 할 수 있으면 객체의 속성에 접근할 방법을 알아내는 과정을 수행하지 않아도 되며 그 대신 객체의 히든 클래스에 대해 이전에 찾아서 저장했던 정보를 사용할 수 있음

### 머신코드로의 컴파일

- 하이드로젠 그래프가 최적화되면 크랭크샤프트는 이를 리튬이라고 부르는 더 하위레벨로 낮춥니다. 리튬의 대부분의 구현은 아키텍쳐에 따라 다릅니다. 레지스터 할당이 이 수준에서 이루어집니다.
- 마침내 리튬은 머신 코드로 컴파일됩니다. 그런 다음 OSR(on-stack replacement, 온스택교환)이라는 것이 일어납니다. 분명하게 수행시간이 긴 메소드를 컴파일하고 최적화하기 전에 그것을 실행할 가능성이 높습니다. V8은 더 최적화된 버전으로 다시 시작하기 위해 방금 어떤 코드가 느리게 수행됐는지 잊지 않을 것입니다. 대신 우리가 가진 모든 맥락(스택, 레지스터 등)을 전환하여 코드의 수행 중간에 최적화된 버전으로 옮겨탈 수 있도록 해줍니다. 이를 V8이 시작부터 코드를 인라인하고 기타 최적화를 수행한 것을 생각하면 매우 복잡한 작업입니다. V8이 이러한 작업을 수행하는 유일한 엔진은 아닙니다.
- V8엔진이 내린 가정이 더 이상 유효하지 않는 경우에 대비해 반최적화(deoptimization)라는 보호장치가 존재합니다. 이는 반대로의 변형을 수행하여 최적화되지 않은 코드를 되돌려 놓습니다.

### 가비지 컬렉션

- 가비지컬렉션을 대해 V8은 전통적인 마킹하고 쓸어버리기(mark-and-sweep)의 세대적 접근방법을 이용해 예전 세대를 제거합니다. 마킹 단계에서는 자바스크립트의 수행을 중단하게 되어있습니다. 가비지컬렉션 비용을 통제하고 그 수행을 좀 더 안정적으로 하기위해 V8은 점진적 마킹을 이용합니다. 힙 전체를 훑어서 가능한 모든 객체를 마킹하는 대신 힙의 일부만을 확인한 다음 정상적인 자바스크립트 실행을 계속합니다. 그 다음의 GC 수행은 바로 이전에 멈춘곳에서부터 계속됩니다. 이를 통해 일상적인 실행에는 매우 짧은 코드 중단만 일어납니다. 위에 언급한대로 쓸어버리기는 별도의 쓰레드에서 수행됩니다.

### 이그니션과 터보팬

- 2017년 초 V8 5.9의 배포와 더불어 새로운 실행 파이프라인이 소개되었습니다. 이 새로운 파이프라인은 더 큰 성능 향상을 가져오며 실제 자바스크립트 응용프로그램에서 현저하게 메모리를 절약할 수도 있습니다.
- 새로운 실행 파이프라인은 V8의 인터프리터인 이그니션과 새로운 최적화 컴파일러인 터보팬 위에 만들어졌습니다.
- V8의 5.9 버전이 출시된 이후, 풀코드젠과 크랭크샤프트(2010년부터 V8에서 사용되고 있던 기술들)는 V8에서 자바스크립트 실행에 사용되지 않고 있습니다. 왜냐하면 V8팀이 새로운 자바스크립트 언어 기능과 이러한 기능에 필요한 최적화 필요에 대응하는데 애를 먹고 있기 때문입니다.
- 이는 V8의 구조가 앞으로는 훨씬 단순하고 유지보수가 용이하게 되었다는 것을 의미합니다.

### 어떻게 최적화된 자바스크립트 코드를 작성할 것인가

- 객체 속성의 순서: 객체 속성을 항상 같은 순서로 초기화해서 히든클래스 및 이후에 생성되는 최적화 코드가 공유될 수 있도록 합니다
- 동적 속성: 객체 생성 이후에 속성을 추가하는 것은 히든 클래스가 변하도록 강제하고 이전의 히든클래스를 대상으로 최적화되었던 모든 메소드를 느리게 만듭니다. 대신에 모든 객체의 속성을 생성자에서 할당합니다
- 메소드: 동일한 메소드를 반복적으로 수행하는 코드가 서로 다른 메소드를 한 번씩만 수행하는 코드 보다 더 빠르게 동작합니다(인라인 캐싱 때문)
- 배열: 값이 띄엄띄엄 있어서 키가 계속해서 증가하는 숫자가 되지 않는 배열은 피하는게 좋습니다. 모든 요소를 가지지는 않는 배열은 해시테이블입니다. 이와 같은 배열의 요소들은 접근하기에 많은 비용이 듭니다. 또한 커다란 배열을 미리 할당하지 않도록 하십시오. 사용하면서 크기가 커지도록 하는 게 낫습니다. 마지막으로 배열의 요소를 삭제하지 마십시오. 그 배열의 키가 띄엄띄엄 배치됩니다.
- 태깅된 값: V8은 객체와 숫자를 32비트로 표현합니다. 어떤 값이 오브젝트(flag = 1)인지 혹은 정수(flag = 0)인지는 SMI(Small Integer)라는 하나의 비트에 저장하고 이 때문에 31비트가 남습니다. 따라서 어떤 숫자가 31비트 보다 크면 V8은 이 숫자를 분리해서 더블 타입으로 전환한 다음 이 숫자를 넣을 새로운 객체를 생성합니다. 이러한 동작은 비용이 높으므로 가능한한 31비트의 숫자를 사용하도록 하십시오.

## V8이 어떻게 JavaScript 코드를 컴파일할까?

- V8은 두 개의 컴파일러를 가진다!
- “전체(Full)” 컴파일러는 어떤 JavaScript 코드도 좋은 코드로 만들 수 있다. 하지만 훌륭한 JIT 코드는 아니다. 이 컴파일러의 목표는 코드를 빨리 생성하는 것이기 때문에 어떤 타입 분석도 하지 않고 타입에 대해서 무지하다. 대신에 프로그램이 돌아가는 도중에 타입에 대한 지식을 정교하게 하는 Inline Caches 또는 “IC” 전략을 사용한다. IC는 매우 효율적이고 20배 빠른 속도 향상을 가져왔다.
- 최적화 컴파일러는 대부분의 JavaScript 언어에 대해 훌륭한 코드를 생성한다. 나중에 실행되고 hot 함수들을 재컴파일한다. 최적화 컴파일러는 Inline Cache에서 타입들을 얻고 코드를 어떻게 하면 더 최적화할 수 있을지 결정한다. 그런데 몇 언어 특징들, 예를 들어 try/catch 블록같은 것들은 아직 지원하지 않는다. (try/catch 블록에 대한 최적화 작업은 “불안정한” 코드를 함수로 작성하고 try 블록에서 그 함수를 호출하려는 것으로 시도하고 있다)
- 코드 최적화: V8은 또한 역최적화를 지원한.: 최적화 컴파일러는 다른 타입들에 관한 Inline Cache로부터 최적의 가정을 하는데 역최적화는 이 가정들이 유효하지 않을 때 실행된다. 예를 들면 생성된 히든 클래스가 예상한 것과 다를 때 V8은 최적화된 코드를 버리고 Inline Cache로부터 다시 타입들을 얻는 전체 컴파일러로 돌아온다. 이 과정은 느리며 최적화 이후 함수들을 변경하지 않음으로써 피해야한다.

---

참조

[자바스크립트는 어떻게 작동하는가: V8 엔진의 내부 + 최적화된 코드를 작성을 위한 다섯 가지 팁](https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-v8-엔진의-내부-최적화된-코드를-작성을-위한-다섯-가지-팁-6c6f9832c1d9)  
[[번역] How the V8 engine works?](https://medium.com/@mjkim111/%EB%B2%88%EC%97%AD-how-the-v8-engine-works-6ca056d249aa)  
[JavaScript 엔진 톺아보기 (1)](https://velog.io/@godori/JavaScript-engine-1)  
출처: https://javannspring.tistory.com/230 [JiGyeong's study room]
