# TypeScript 3.0~3.6(최신)의 변경점

## 3.0

- 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript가 빌드 순서 및 출력 구조를 이해할 수 있는 방법을 제공하므로 코드를 더 작은 프로젝트로 쉽게 분할 할 수 있습니다.
- --build 프로젝트 참조와 함께 작동하여 더 빠른 TypeScript 빌드를 가능하게 하는 플래그인 tsc에 대한 새로운 모드가 도입되었습니다.
- 여러 새로운 기능에 대한 지원을 추가하여 튜플 유형으로 함수 매개 변수 목록과 상호 작용합니다.
  - 튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장합니다.
  - 튜플 형식의 스프레드 식을 이산 형 인수로 확장
  - 일반 휴식 매개 변수 및 해당 튜플 유형의 추론.
  - 튜플 유형의 선택적 요소
  - 튜플 유형의 나머지 요소.
- unknown이라는 새로운 최상위 유형이 도입되었습니다. unknown의 형식 안전 대응입니다(any). 뭐든에 할당 할 것입니다. 하지만 unknown 그 자체 입니다. 아무것도에 할당 할 수 없는 any 종류의 주장 또는 제어 흐름을 기반으로 축소하지 않습니다. 마찬가지로, unknown은 더 구체적인 유형을 주장하거나 좁히지 않고서는 어떠한 작업도 허용되지 않습니다.
- JSX 네임스페이스에 새로운 유형 별칭을 지원합니다. LibraryManagedAttributes. 이 헬퍼 유형은 컴포넌트를 Props 대상으로하는 JSX 표현식을 확인하기 위해 사용하기 전에 컴포넌트 유형의 변환을 정의 합니다. 따라서 제공된 소품과 유추 된 소품 사이의 충돌을 처리하는 방법, 추론을 매핑하는 방법, 선택성을 처리하는 방법 및 다른 장소의 추론을 결합하는 방법과 같은 사용자 정의가 가능합니다.
- TypeScript는 새로운 삼중 슬래시 참조 지시문 ( /// \<reference lib="name" />)을 추가하여 파일에 기존의 내장 lib 파일을 명시 적으로 포함 할 수 있습니다.

## 3.1

- 매핑 개체 유형 튜플과 배열. 이제 특정 형상 부재 신형 만드는 대신, 새로운 튜플, 어레이를 제조 동안 push(), pop() 그리고 length 변환 되어 있습니다.
- const에 동일한 범위에서 이러한 함수의 속성에 간단히 할당하여 함수 선언 및 선언 된 기능에 대한 속성을 정의하는 기능을 제공합니다. 이를 통해 namespace해킹에 의존하지 않고 표준 JavaScript 코드를 작성할 수 있습니다.
- 노드 모듈 확인을 사용할 때 TypeScript가 package.json파일을 열어서 읽어야하는 파일을 알아낼 때 먼저라는 새 필드를 확인합니다.

## 3.2

- --strictBindCallApply를 새로 선 보였습니다. bind, call 및 apply 함수 객체의 메소드가 강력하게 형식화하고 엄격하게 확인됩니다.
- 객체 리터럴은 이제 Object.assign 함수 및 JSX 리터럴과 유사한 교차 유형을 생성하는 일반 스프레드 표현식을 허용 합니다.
- 일반 변수에서 나머지 바인딩을 제거 할 수도 있습니다. 이것은 미리 정의 된 사용하여 달성 Pick과 Exclude에서 도우미 유형 lib.d.ts, 문제의 일반적인 유형뿐만 아니라 destructuring 패턴의 다른 바인딩의 이름을 사용합니다.

- BigInts에 대한 유형 검사를 제공 할뿐만 아니라 타겟팅 할 때 BigInt 리터럴을 방출 할 수 있도록 지원합니다. BigInt 지원은 bigint(모두 소문자) 라는 새로운 기본 유형을 도입합니다 . 함수 bigint를 호출 BigInt()하거나 n정수 숫자 리터럴의 끝에를 추가하여 BigInt 리터럴을 작성 하여를 얻을 수 있습니다.
- 판별 속성으로 간주되는 규칙을 완화하여 좁히기가 더 쉬워집니다. 노동 조합의 일반적인 특성은 이제 그들이 포함으로 판별 식으로 간주됩니다 일부 (예를 들어, 문자열 리터럴, 싱글 타입 null, 또는 undefined), 그들은 어떤 제네릭을 포함하지 않습니다.
- unwrap함수 본문에서 축소가 올바르게 작동합니다 .
- tsconfig.json에서들 node_modules. 에서 "extends"필드 의 기본 경로를 사용하는 tsconfig.json경우 TypeScript는 node_modules패키지를 제공합니다.
- tscTypeScript 컴파일러 인이라고하는 새로운 플래그를 지원합니다 --showConfig. 를 실행 tsc --showConfig하면 TypeScript는 필드 tsconfig.json에서 상속 된 옵션을 계산 한 후 유효를 계산하여 extends 인쇄합니다. 일반적으로 구성 문제를 진단하는 데 유용 할 수 있습니다.
- JavaScript 파일을 쓸 때 allowJs 사용할 수 있습니다. Object.defineProperty. 즉, JavaScript 파일에서 유형 검사를 활성화 할 때 ( checkJs옵션을 설정하거나 // @ts-check파일 맨 위에 주석을 추가하여) 더 나은 완성도를 달성하고 유형 검사를 강화할 수 있습니다 .

## 3.3

- 이전 버전의 TypeScript에서는 호출 가능한 형식의 공용체 가 동일한 매개 변수 목록이있는 경우 에만 호출 할 수 있었습니다. TypeScript 3.3에서는 더 이상 오류가 아닙니다.
- --build모드의 --watch플래그 는 증분 파일 감시도 활용합니다. 이는 빠른 빌드를 의미 할 수 있습니다 --build --watch. 테스트에서이 기능은 원래 시간 의 빌드 시간 을 50 %에서 75 %까지 줄였습니다. 특정 풀을 보기 위해 변경에 대한 원래 풀 요청에 대한 자세한 내용을 읽을 수 있지만 대부분의 복합 프로젝트 사용자는 여기에서 상당한 승리를 볼 수 있습니다.

## 3.4

- --incrementalTypeScript가 마지막 컴파일에서 프로젝트 그래프에 대한 정보를 저장하도록 하는 새로운 플래그가 도입되었습니다 . 다음에 TypeScript를 사용하여 호출 --incremental하면 해당 정보를 사용하여 가장 비용이 많이 드는 유형 검사 및 프로젝트 변경 방법을 감지합니다.
- 이제 다른 일반 함수에서 유추하여 자유 형식 변수를 유추 할 때 일반 함수 유형을 생성 할 수 있습니다. 이는 많은 기능 구성 패턴이 3.4에서 더 잘 작동 함을 의미합니다.
- 읽기 전용 배열과 비슷한 유형을 조금 더 쉽게 사용할 수 있습니다. ReadonlyArray 유형은 설명 Array만 읽을 수 있습니다.참조가 있는 변수 ReadonlyArray는 배열의 요소를 추가, 제거 또는 교체 할 수 없습니다.
- 배열 유형에 ReadonlyArray 새로운 readonly 수정자를 사용 하는 새로운 구문이 도입되었습니다 .
- readonly 튜플에 대한 새로운 지원도 도입되었습니다 . 우리는 지금 배열 속기 구문으로 할 수 있듯이 튜플 유형 앞에 readonly키워드를 readonly붙여 튜플 로 만들 수 있습니다. 예상대로 슬롯을 쓸 수 있는 일반 튜플과 달리 튜플 readonly은 해당 위치에서 읽기만 허용합니다.
- readonly에서 매핑 된 형식 의 수정자는 배열과 같은 형식을 해당하는 형식으로 자동 변환 readonly 합니다.
- const 어설션 이라는 리터럴 값에 대한 새로운 구성이 도입되었습니다 . 구문은 const 형식 이름 대신 형식 어설션입니다 ( ex) 123 as const. const 어설션으로 새로운 리터럴 표현을 만들 때 언어에 신호를 보낼 수 있습니다.
- ECMAScript의 새로운 유형 확인 기능인 globalThis전역 변수를 참조하는 전역 변수를 지원합니다. 위의 솔루션과 달리 globalThis 다양한 환경에서 사용할 수 있는 글로벌 범위에 액세스하기위한 표준 방법을 제공합니다.

## 3.5

- 유형 검사 및 증분 빌드에 대한 여러 최적화를 소개합니다.
- 형식 검사를보다 효율적으로 수행하기 위해 TypeScript 3.4에 대한 특정 최적화가 포함되어 있습니다. 이러한 개선 사항은 형식 확인이 코드 완성 목록과 같은 작업을 수행하는 편집기 시나리오에서 훨씬 더 두드러집니다.
- --incremental 컴파일러 상태, 파일을 찾은 이유, 파일이있는 위치 등 세계 상태 계산 방법에 대한 정보를 저장 하여 3.4의 빌드 모드를 개선합니다 . --build모드에서 우리는 TypeScript 3.4에 비해 재 구축 시간을 68 % 나 줄일 수 있음을 발견했습니다.
- 새로운 Omit도우미 유형이 도입 되어 일부 속성이 원본에서 삭제 된 새로운 유형을 만듭니다.
- 형식 검사기는 제공된 모든 속성이 일부 공용체 멤버에 속 하고 적절한 형식인지 확인합니다. 즉, 위의 샘플에서 오류가 올바르게 발생합니다.
- 판별 속성 유형에 할당 할 때 typesceipt 3.5에서 T언어는 실제로 것이다 더 나아가 같은 유형을 분해 S가능한 모든 주민 유형의 조합으로. 이 경우, 사람 boolean의 합집합 true과 false,이 S(A)의 조합으로 간주된다 { done: false, value: number }하고 { done: true, value: number }.
- 생성자 함수에서도 작동하도록이 동작을 일반화합니다.

## 3.6

- 익숙하지 않은 사람들을 위해 TypeScript는 선택적 정적 유형을 추가하여 JavaScript를 기반으로하는 언어입니다. 이러한 유형은 TypeScript 컴파일러에서 검사하여 맞춤법 오류 및 함수 호출과 같은 프로그램의 일반적인 오류를 포착 할 수 있습니다. 그런 다음 TypeScript 컴파일러 및 Babel과 같은 도구를 사용하여 모든 최신 표준 기능을 사용하는 TypeScript 코드를 모든 브라우저 또는 런타임 (ES3 또는 ES5를 지원하는 훨씬 오래된 버전)에서 작동하는 표준 호환 ECMAScript 코드로 변환 할 수 있습니다.
- TypeScript는 유형 검사 및 새로운 ECMAScript 기능을 뛰어 넘습니다. 편집기 툴링은 일류 시민으로 간주되며 TypeScript 프로젝트의 핵심 부분으로, 코드 완성, 리팩토링 및 일련의 다른 편집기에서 빠른 수정과 같은 기능을 제공합니다 . 실제로 Visual Studio 또는 Visual Studio Code에서 JavaScript 파일을 이미 편집 한 경우 실제로 해당 경험은 TypeScript에서 제공되므로 모르는 사이에 이미 TypeScript를 사용했을 수 있습니다!
- 더 엄격한 발전기
- 보다 정확한 어레이 확산
- 약속 된 UX 개선
- 식별자에 대한 더 나은 유니 코드 지원
- import.meta SystemJS 지원
- get접근 set자는 주변 상황에서 허용됩니다
- 주변 클래스 및 함수가 병합 될 수 있음
- API를 지원하는 방법 --build및--incremental
- 새로운 TypeScript 놀이터
- 세미콜론 인식 코드 편집
- 똑똑한 자동 가져 오기
- 클래스 멤버 "constructor"는 이제 생성자입니다
- DOM 업데이트
- 더 이상 병합되지 않는 JSDoc 설명
- 키워드가 이스케이프 시퀀스를 포함 할 수 없음
