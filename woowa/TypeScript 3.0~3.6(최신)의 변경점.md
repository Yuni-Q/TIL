# TypeScript 3.0~3.6(최신)의 변경점

## 3.0

- TypeScript 3.0에는 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 tsconfig.json있습니다. 특히 파일이 다른 tsconfig.json파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript (및 주변 도구)가 빌드 순서 및 출력 구조를 이해할 수있는 방법을 제공하므로 코드를 더 작은 프로젝트로 쉽게 분할 할 수 있습니다.
- TypeScript 3.0에는 또한 --build프로젝트 참조와 함께 작동하여 더 빠른 TypeScript 빌드를 가능하게 하는 플래그 인 tsc에 대한 새로운 모드가 도입되었습니다.
- TypeScript 3.0은 여러 새로운 기능에 대한 지원을 추가하여 튜플 유형으로 함수 매개 변수 목록과 상호 작용합니다. TypeScript 3.0은 다음에 대한 지원을 추가합니다.
  - 튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장합니다.
  - 튜플 형식의 스프레드 식을 이산 형 인수로 확장
  - 일반 휴식 매개 변수 및 해당 튜플 유형의 추론.
  - 튜플 유형의 선택적 요소
  - 튜플 유형의 나머지 요소.
- TypeScript 3.0에는 새로운 최상위 유형이 도입되었습니다 unknown. unknown의 형식 안전 대응입니다 any. 뭐든에 할당 할 것입니다 unknown,하지만 unknown그 자체하지만 아무것도에 할당 할 수없는 any종류의 주장 또는 제어 흐름을 기반으로 축소하지 않고. 마찬가지로, unknown더 구체적인 유형을 주장하거나 좁히지 않고서 는 어떠한 작업도 허용되지 않습니다.
- TypeScript 3.0은이라는 JSX네임 스페이스 에 새로운 유형 별칭을 지원합니다 LibraryManagedAttributes. 이 헬퍼 유형은 컴포넌트를 Props대상으로하는 JSX 표현식을 확인하기 위해 사용하기 전에 컴포넌트 유형 의 변환을 정의 합니다. 따라서 제공된 소품과 유추 된 소품 사이의 충돌을 처리하는 방법, 추론을 매핑하는 방법, 선택성을 처리하는 방법 및 다른 장소의 추론을 결합하는 방법과 같은 사용자 정의가 가능합니다.
- TypeScript는 새로운 삼중 슬래시 참조 지시문 ( /// <reference lib="name" />)을 추가하여 파일에 기존의 내장 lib 파일 을 명시 적으로 포함 할 수 있습니다.

## 3.1

- TypeScript 3.1 매핑 개체 유형 튜플과 배열 이제 특정 형상 부재 신형 만드는 대신, 새로운 튜플 / 어레이를 제조 동안 push(), pop()그리고이 length 변환 되어 있습니다.
- TypeScript 3.1은 const 동일한 범위에서 이러한 함수의 속성에 간단히 할당하여 함수 선언 및 선언 된 기능에 대한 속성을 정의하는 기능을 제공합니다 . 이를 통해 namespace해킹에 의존하지 않고 표준 JavaScript 코드를 작성할 수 있습니다.
- TypeScript 3.1에서 노드 모듈 확인을 사용할 때 TypeScript가 package.json파일을 열어서 읽어야하는 파일을 알아낼 때 먼저라는 새 필드를 확인합니다

## 3.2

- --strictBindCallApply를 새로 선 보였습니다. bind, call 및 apply 함수 객체의 메소드가 강력하게 형식화하고 엄격하게 확인됩니다.
- TypeScript 3.2에서 객체 리터럴은 이제 Object.assign함수 및 JSX 리터럴과 유사한 교차 유형을 생성하는 일반 스프레드 표현식을 허용 합니다.
- TypeScript 3.2를 사용하면 일반 변수에서 나머지 바인딩을 제거 할 수도 있습니다. 이것은 미리 정의 된 사용하여 달성 Pick과 Exclude에서 도우미 유형 lib.d.ts, 문제의 일반적인 유형뿐만 아니라 destructuring 패턴의 다른 바인딩의 이름을 사용합니다.
- TypeScript 3.2는 BigInts에 대한 유형 검사를 제공 할뿐만 아니라 타겟팅 할 때 BigInt 리터럴을 방출 할 수 있도록 지원합니다.
- TypeScript에서 BigInt 지원은 bigint(모두 소문자) 라는 새로운 기본 유형을 도입합니다 . 함수 bigint를 호출 BigInt()하거나 n정수 숫자 리터럴의 끝에를 추가하여 BigInt 리터럴을 작성 하여를 얻을 수 있습니다.
- TypeScript 3.2는 판별 속성으로 간주되는 규칙을 완화하여 좁히기가 더 쉬워집니다. 노동 조합의 일반적인 특성은 이제 그들이 포함으로 판별 식으로 간주됩니다 일부 (예를 들어, 문자열 리터럴, 싱글 타입 null, 또는 undefined), 그들은 어떤 제네릭을 포함하지 않습니다.
- 결과적으로 TypeScript 3.2 error는 다음 예제 의 속성을 판별 자로 간주 하지만 그 이전 Error에는 싱글 톤 유형이 아닙니다. 이로 인해 unwrap함수 본문에서 축소가 올바르게 작동합니다 .
- TypeScript 3.2 지금 해결 tsconfig.json에서들 node_modules. 에서 "extends"필드 의 기본 경로를 사용하는 tsconfig.json경우 TypeScript는 node_modules패키지를 제공합니다.
- tscTypeScript 컴파일러 인이라고하는 새로운 플래그를 지원합니다 --showConfig. 를 실행 tsc --showConfig하면 TypeScript는 필드 tsconfig.json에서 상속 된 옵션을 계산 한 후 유효를 계산하여 extends인쇄합니다. 일반적으로 구성 문제를 진단하는 데 유용 할 수 있습니다.
- JavaScript 파일을 쓸 때 (를 사용하여 allowJs) TypeScript는 이제를 사용하는 선언을 인식합니다 Object.defineProperty. 즉, JavaScript 파일에서 유형 검사를 활성화 할 때 ( checkJs옵션을 설정하거나 // @ts-check파일 맨 위에 주석을 추가하여) 더 나은 완성도를 달성하고 유형 검사를 강화할 수 있습니다 .

## 3.3

- 이전 버전의 TypeScript에서는 호출 가능한 형식의 공용체 가 동일한 매개 변수 목록이있는 경우 에만 호출 할 수있었습니다. TypeScript 3.3에서는 더 이상 오류가 아닙니다.
- TypeScript 3.3에서 --build모드의 --watch플래그 는 증분 파일 감시도 활용합니다. 이는에서보다 빠른 빌드를 의미 할 수 있습니다 --build --watch. 테스트에서이 기능은 원래 시간 의 빌드 시간 을 50 %에서 75 %까지 줄였습니다--build --watch . 특정 풀을보기 위해 변경에 대한 원래 풀 요청에 대한 자세한 내용을 읽을 수 있지만 대부분의 복합 프로젝트 사용자는 여기에서 상당한 승리를 볼 수 있습니다.

## 3.4

- TypeScript 3.4에는 --incrementalTypeScript가 마지막 컴파일에서 프로젝트 그래프에 대한 정보를 저장하도록 하는 새로운 플래그가 도입되었습니다 . 다음에 TypeScript를 사용하여 호출 --incremental하면 해당 정보를 사용하여 가장 비용이 많이 드는 유형 검사 및 프로젝트 변경 방법을 감지합니다.
- TypeScript 3.4는 이제 다른 일반 함수에서 유추하여 자유 형식 변수를 유추 할 때 일반 함수 유형을 생성 할 수 있습니다. 이는 많은 기능 구성 패턴이 3.4에서 더 잘 작동 함을 의미합니다.
- TypeScript 3.4를 사용하면 읽기 전용 배열과 비슷한 유형을 조금 더 쉽게 사용할 수 있습니다. ReadonlyArray유형은 설명 Array만 읽을 수 있습니다들. 에 대한 참조가있는 변수 ReadonlyArray는 배열의 요소를 추가, 제거 또는 교체 할 수 없습니다.
- TypeScript 3.4에서는 배열 유형에 ReadonlyArray새로운 readonly수정자를 사용 하는 새로운 구문이 도입되었습니다 .
- TypeScript 3.4에는 readonly튜플에 대한 새로운 지원도 도입되었습니다 . 우리는 지금 배열 속기 구문으로 할 수 있듯이 튜플 유형 앞에 readonly키워드를 readonly붙여 튜플 로 만들 수 있습니다. 예상대로 슬롯을 쓸 수있는 일반 튜플과 달리 튜플 readonly은 해당 위치에서 읽기만 허용합니다.
- TypeScript 3.4 readonly에서 매핑 된 형식 의 수정자는 배열과 같은 형식을 해당하는 형식으로 자동 변환 readonly합니다.
- TypeScript 3.4에는 const어설 션 이라는 리터럴 값에 대한 새로운 구성이 도입되었습니다 . 구문은 const형식 이름 대신 형식 어설 션입니다 (예 :) 123 as const. const어설 션으로 새로운 리터럴 표현을 만들 때 언어에 신호를 보낼 수 있습니다.
- TypeScript 3.4는 ECMAScript의 새로운 유형 확인 기능인 globalThis전역 변수를 참조하는 전역 변수를 지원합니다. 위의 솔루션과 달리 globalThis다양한 환경에서 사용할 수있는 글로벌 범위에 액세스하기위한 표준 방법을 제공합니다.

## 3.5

- TypeScript 3.5는 유형 검사 및 증분 빌드에 대한 여러 최적화를 소개합니다.
- TypeScript 3.5에는 형식 검사를보다 효율적으로 수행하기 위해 TypeScript 3.4에 대한 특정 최적화가 포함되어 있습니다. 이러한 개선 사항은 형식 확인이 코드 완성 목록과 같은 작업을 수행하는 편집기 시나리오에서 훨씬 더 두드러집니다.
- TypeScript 3.5는 --incremental컴파일러 상태, 파일을 찾은 이유, 파일이있는 위치 등 세계 상태 계산 방법에 대한 정보를 저장 하여 3.4의 빌드 모드를 개선합니다 . --build모드에서 우리는 TypeScript 3.4에 비해 재 구축 시간을 68 % 나 줄일 수 있음을 발견했습니다 !
- TypeScript 3.5에는 새로운 Omit도우미 유형이 도입 되어 일부 속성이 원본에서 삭제 된 새로운 유형을 만듭니다.
- TypeScript 3.5에서 형식 검사기는 제공된 모든 속성이 일부 공용체 멤버에 속 하고 적절한 형식인지 확인합니다. 즉, 위의 샘플에서 오류가 올바르게 발생합니다.
- 처럼 판별 속성 유형에 할당 할 때 타이프 라이터 3.5에서 T언어는 실제로 것이다 더 나아가 같은 유형을 분해 S가능한 모든 주민 유형의 조합으로. 이 경우, 사람 boolean의 합집합 true과 false,이 S(A)의 조합으로 간주된다 { done: false, value: number }하고 { done: true, value: number }.
- TypeScript 3.5는 생성자 함수에서도 작동하도록이 동작을 일반화합니다.
