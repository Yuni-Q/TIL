# prototype based OOP

참조 : [Prototype-based programming](https://en.wikipedia.org/wiki/Prototype-based_programming)

- 프로토 타입 기반 프로그래밍은 프로토 타입 역할을 하는 위임을 통해 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속)을 수행 하는 객체 지향 프로그래밍 스타일입니다.
- 이 모델은 프로토 타입, 프로토 타입 지향, 클래스리스 또는 인스턴스 기반 프로그래밍 이라고도 합니다 . 위임은 프로토 타입 기반 프로그래밍을 지원하는 언어 기능입니다.
- 프로토 타입 기반 프로그래밍은 일반화 된 객체를 사용하여 복제 및 확장 할 수 있습니다.
- 프로토 타입 객체를 만든 다음 새로운 인스턴스를 만듭니다. 객체는 JavaScript로 변경할 수 있으므로 새로운 인스턴스를 확장하여 새로운 필드와 메소드를 제공 할 수 있습니다. 그러면 더 새로운 객체의 프로토 타입 역할을 할 수 있습니다. 비슷한 객체를 많이 만들기 위해 클래스가 필요하지 않습니다.
- 많은 프로토 타입 기반 시스템은 런타임 동안 프로토 타입 변경을 장려하는 반면, 클래스 기반 객체 지향 시스템을 사용하면 프로그램 실행 중에 클래스를 변경할 수 있습니다.
- 거의 모든 프로토 타입 기반 시스템은 해석되고 동적으로 유형이 지정된 언어를 기반 으로 합니다. 그러나 정적으로 형식화 된 언어를 기반 으로하는 시스템 은 기술적으로 가능합니다.

## 객체 구성

- 프로토 타입 기반 언어에는 명시 적 클래스가 없습니다. 객체는 프로토 타입 속성을 통해 다른 객체로부터 직접 상속됩니다.
- 새로운 객체를 구성하는 두 가지 방법이 있습니다. 객체 생성 또는 기존 객체 복제를 통한 방법.
  - 전자는 어떤 형태의 객체 리터럴을 통해 지원 되는데, 선언은 {...} 와 같은 특수 구문을 통해 객체를 런타임에 정의 하고 변수에 직접 전달할 수 있습니다. 대부분의 시스템은 다양한 복제를 지원하지만 객체 생성은 눈에 띄지 않습니다.
- 클래스 기반 언어에서 새 인스턴스는 클래스의 생성자 함수를 통해 구성됩니다 .이 함수는 객체의 멤버 (속성 및 메서드)에 대한 메모리 블록을 예약하고 해당 블록에 대한 참조를 반환하는 특수 함수입니다. 선택적 생성자 인수 세트 는 함수에 전달 될 수 있으며 일반적으로 특성에 보유됩니다. 결과 인스턴스는 클래스에 정의 된 모든 메서드와 속성을 상속하며, 비슷한 형식의 개체를 구성 할 수있는 일종의 템플릿 역할을합니다.
- 객체 생성은 새로운 객체는 기존의 프로토 타입에서 복제하지 않고 처음부터 생성 할 수 있습니다. 이러한 시스템은 기존 객체를 참조하지 않고 새 객체의 속성과 동작을 지정하기위한 특수 구문을 제공합니다. 많은 프로토 타입 언어에는 종종 Object 라고하는 루트 객체가 있습니다. 루트 객체는 런타임에 생성 된 다른 모든 객체의 기본 프로토 타입으로 설정되며 객체에 대한 설명을 반환하는 toString() 함수 와 같이 일반적으로 필요한 메소드를 전달 합니다. 객체 생성의 유용한 측면 중 하나 는 새 객체의 슬롯 (속성 및 메서드) 이름에 네임 스페이스가 없는 것입니다. 최상위 Object 객체와 충돌 합니다.
- 복제 는 기존 객체 (시제품)의 동작을 복사하여 새 객체를 구성하는 프로세스를 말합니다. 그런 다음 새 객체는 원본의 모든 자질을 전달합니다. 이제부터 새 개체를 수정할 수 있습니다. 일부 시스템에서 결과로 생성 된 자식 개체 는 프로토 타입에 대한 명시 적 링크 ( 위임 또는 유사성을 통해 )를 유지하며 프로토 타입의 변경으로 인해 해당 변경 사항이 복제본에 나타납니다.

## Delegation

- 위임을 사용하는 프로토 타입 기반 언어 에서 언어 런타임은 디스패치 할 수 있습니다.일치하는 것을 찾을 때까지 일련의 위임 포인터 (개체에서 프로토 타입까지)를 따라 올바른 방법을 찾거나 올바른 데이터를 찾는 것입니다. 개체간에이 동작 공유를 설정하는 데 필요한 것은 위임 포인터입니다. 클래스 기반 객체 지향 언어의 클래스와 인스턴스 간의 관계와 달리 프로토 타입과 파생물 간의 관계는 하위 링크가이 링크를 넘어 프로토 타입과 메모리 또는 구조적 유사성을 가질 필요는 없습니다. 따라서 클래스 기반 시스템에서와 같이 관련 프로토 타입의 구조를 재정렬하지 않고도 시간이 지남에 따라 하위 오브젝트를 계속 수정하고 수정할 수 있습니다. 데이터뿐만 아니라 메소드도 추가하거나 변경할 수 있습니다.

## Concatenation

- Kevo 프로그래밍 언어로 구현 된 접근 방식 인 연결 프로토 타입 에서는 개체가 복제 된 원본 프로토 타입에 대한 포인터 나 링크가 보이지 않습니다. 프로토 타입 (부모) 개체는 연결되지 않고 복사되며 위임이 없습니다. 결과적으로 프로토 타입의 변경 사항은 복제 된 객체에 반영되지 않습니다.
- 이 배열의 주요 개념 차이는 프로토 타입 객체의 변경 사항이 복제본에 자동으로 전파되지 않는다는 것입니다. 이것은 장단점으로 볼 수 있습니다. 그러나 Kevo는 유사성 (소위 패밀리 셈 블랑 또는 복제 패밀리 메커니즘 )을 기반으로 객체 세트간에 변경 사항을 게시하기위한 추가 기본 요소를 제공합니다. 위임 모델에서 일반적인 것처럼 분류 학적 기원을 통하지 않고.) 또한 위임 기반 프로토 타이핑은 하위 개체의 변경이 나중에 부모의 작업에 영향을 줄 수 있다는 추가적인 단점이 있다고 주장합니다. 그러나이 문제는 위임 기반 모델에 내재 된 것이 아니며 JavaScript와 같은 위임 기반 언어에는 존재하지 않으므로 자식 개체에 대한 변경 내용이 항상 자식 개체 자체에 기록되고 부모 개체에는 절대로 기록되지 않습니다. 값은 부모 값을 변경하지 않고 부모 값을 어둡게합니다).
- 간단한 구현에서 연결 프로토 타입은 위임 기반 프로토 타입보다 빠른 멤버 조회를 갖지만 (부모 오브젝트 체인을 따를 필요가 없기 때문에) 더 많은 메모리를 사용합니다 (단일 슬롯이 아닌 모든 슬롯이 복사되기 때문에) 부모 객체를 가리키는 슬롯). 그러나 속도와 메모리 간의 절충이 필요하지만보다 복잡한 구현은 이러한 문제를 피할 수 있습니다. 예를 들어, 연결 프로토 타이핑이있는 시스템은 COW ( Copy-On-Write) 구현을 사용하여 무대 뒤에서 데이터를 공유 할 수 있습니다. 이러한 접근 방식에는 Kevo가 뒤 따릅니다. 반대로, 위임 기반 프로토 타이핑 시스템은 사용 캐싱 된 데이터를 검색 속도.

## 비판

- 프로토 타입 기반 시스템을 비판하는 클래스 기반 객체 모델의 옹호자들은 종종 프로그래밍 언어를위한 정적 타입 시스템의 지지자들이 다이나믹 타입 시스템을 가지고 있다는 우려와 유사한 우려를 가지고 있습니다. 일반적으로 이러한 우려에는 정확성, 안전성, 예측 가능성, 효율성 및 프로그래머의 친숙 함이 포함됩니다.
- 처음 세 가지 점에서 클래스는 종종 유형과 유사한 것으로 보이며 (대부분 정적으로 유형이 지정된 객체 지향 언어에서 해당 역할을 수행함) 인스턴스 및 인스턴스 사용자에게 계약 보증을 제공하도록 제안됩니다.
- 효율성과 관련하여 클래스를 선언 하면 효율적인 메서드 및 인스턴스 변수 조회를 개발할 수있는 많은 컴파일러 최적화가 간소화 됩니다. 예를 들어 자기의 언어, 많은 개발 시간 개발, 컴파일 및 클래스 기반 시스템에 비해 프로토 타입 기반 시스템의 성능을 향상시키는 기술을 해석에 소요되었다.
- 프로토 타입 기반 언어에 대한 일반적인 비판 은 JavaScript의 인기와 시장 침투에도 불구하고 소프트웨어 개발자 커뮤니티가 익숙하지 않다는 것 입니다. 이 프로토 타입 기반 시스템의 지식 수준은 JavaScript 프레임 워크 의 확산 과 웹 이 성숙함에 따라 JavaScript의 복잡한 사용 으로 인해 증가하고있는 것으로 보입니다 . ECMAScript를 6 개 소개 클래스 문법 설탕 개체를 만들고 상속을 처리하는 다른 방법을 제공하는 자바 스크립트의 기존 프로토 타입 기반 상속 이상을.

---

참조 : [프로토타입 기반 프로그래밍](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EA%B8%B0%EB%B0%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

- 프로토타입 기반 프로그래밍은 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있다. 프로토타입기반 프로그래밍은 클래스리스(class-less), 프로토타입 지향(prototype-oriented) 혹은 인스턴스 기반(instance-based) 프로그래밍이라고도 한다.
- 프로토타입 기반 언어의 가장 원조격인 프로그래밍 언어인 셀프는 데이비드 엉거와 랜덜 스미스가 개발했다. 클래스리스 프로그래밍은 최근에 와서 많이 유명해졌는데, 자바스크립트와 모픽 프레임워크를 사용하는 스퀵에 적용되었고, 그 외에 세실, 뉴튼스크립트, 아이오, 무, 리볼, 케보 등에 적용되었다.(#프로토타입 기반 언어 목록 참고.)

## 클래스 기반과의 비교

- 클래스기반 언어에서 객체는 일반적으로 두 가지 형태가 있다. '클래스'는 객체의 기본적인 만듦새와 기능을 정의하고, '인스턴스'는 "사용할 수 있는" 객체로 특정 클래스의 양식을 기반으로 한다. 클래스기반 언어에서 '클래스'는 동작 방식인 메소드의 모임으로 동작하고, 모든 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있다. 한쪽에는 구조와 동작 방식, 다른 한쪽에는 상태로 구분된다.
- 프로토타입 기반 프로그래밍을 지지하는 사람들은 클래스기반 언어에서는 개발자가 클래스들 사이의 분류와 관계에 먼저 초점을 맞추기 쉽다고 한다. 이와는 달리, 프로토타입기반 프로그래밍은 프로그래머가 여러 가지 표본의 동작 방식에 초점을 맞추고, 이 객체들을 나중에 클래스와 비슷한 방식의 "객체의 원형"으로 분류하는 것은 나중에 걱정해도 된다. 많은 프로토타입기반 체계가 실행시간에 프로토타입을 대체하기 쉬우나, 클래스기반 객체지향 체계에서는 최초의 동적 객체지향 체계인 스몰토크와 같이 프로그램의 실행 중에 클래스를 바꿀 수 있는 것은 몇 가지 되지 않는다.
- 프로토타입 기반 프로그래밍은, 학습의 과정의 주요한 특징으로 프로토타입이나 이그젬플러를 강조하는, 인지 심리학과 같은 특정 학문과 관련되어 있는 경우가 많다.
- 프로토타입 기반 체계의 대부분은 인터프리터이고 동적 타입 프로그래밍 언어이다. 하지만 프로토타입기반의 정적 타입의 체계가 기술적으로 가능하다. 오메가는 그런 체계의 한 예이다.

## 객체 생성

- 클래스기반 언어에서, 클래스의 생성자를 통하거나 필요하다면 생성자와 생성자의 매개변수를 통하여 인스턴스를 새로 만든다. 결과로 만들어진 인스턴스는 선택된 클래스의 설계와 행동을 따르게 된다.
- 프로토타입기반 체계에서, 새 객체를 만드는 두 가지 방법이 있다. 하나는 원래 있던 객체를 '복제(cloning)'하는 방법이고, 다른 하나는 '무(無)에서(ex nihilo)' 객체를 생성하는 방법이다. 대부분 다양한 복제 방식을 제공하기 때문에, 무에서 객체를 생성하는 것은 흔하지 않다.
- 무에서 객체를 생성할 수 있는 체계는 이미 있던 프로토타입을 복제하지 않고 아무것도 없는 상태에서 새로운 객체를 생성할 수 있게 해 준다. 이런 체계는 새 객체의 특성과 행동을 이미 있던 객체를 참조하지 않고도 지정할 수 있다. 많은 프로토타입기반 언어에서 기본 객체 프로토타입인 Object 프로토타입이 있는데, 여기에 공통적으로 필요한 메서드가 들어있고, 모든 객체의 마스터 프로토타입으로 사용된다. 무에서 객체를 창조하는 방식의 유용한 한 가지는 새 객체의 슬롯 이름이 최상위의 Object 객체와 네임스페이스 충돌이 일어나지 않는다는 것이다. 모질라 자바스크립트는 객체의 \_\_proto\_\_ 프로퍼티를 null로 지정하면 이것이 가능하도록 구현되어 있다.
- '복제'는 원래 있던 객체의 프로토타입의 행동을 복제하여 새 객체를 생성하는 과정을 거친다. 새 객체는 원본의 모든 특성을 가진다. 이 상태에서 새 객체를 수정할 수 있다. 어떤 체계에서 복제된 자식 객체는 명시적으로 프로토타입과 '위임'(delegation)이나 '닮음'(resemblance)으로 연관되어 있다. 그래서 프로토타입을 변경하면 복제품에 영향을 끼친다. 포스와 케보 같은 다른 체계에서는 프로토타입을 번식시키는 이런 방식을 따르지 않고, 대신에 프로토타입을 수정하더라도 복제품에는 영향을 끼치지 않는 연쇄된 형태를 사용하여 원본 객체를 수정하더라도 그 자손으로 자동 번식되지 않는다.

## 위임

- 실행시간에 '위임'하는 프로토타입기반의 언어들은 올바른 메서드로 동적 디스패치를 할 수 있거나, 맞는 자료 조각에 이를 때까지 객체에서 프로토타입으로 간단히 위임 포인터를 연속적으로 따라가서 찾을 수 있다. 객체들 사이에서 동작을 공유하는 것을 확립하기 위해 필요한 것들은 위임 포인터뿐이다. 클래스기반 객체지향 언어에서 클래스와 인스턴스의 관계와 달리 프로토타입과 파생된 객체는 이 연결을 통하여 프로토타입과 자식 객체가 메모리나 구조적인 유사성을 가질 필요가 없다. 마찬가지로, 자식 객체는 클래스 기반의 연관된 클래스의 구조를 재배치하지 않고 계속해서 수정할 수 있다. 또 중요한 점은, 자료뿐만 아니라 메서드도 추가되거나 변경될 수 있다는 것이다. 이런 이유로 대부분의 프로토타입기반 언어들은 자료와 메서드 두가지 모두 슬롯으로 관리한다.

## 연쇄

- 순수 프로토타입은 '연쇄적' 프로토타입이라고도 하는데 케보가 그 예이다. 원본 프로토타입에서 복제된 객체로 포인터는 보이지 않는다. 프로토타입 객체는 정확히 복사되지만, 다른 이름이나 참조값을 갖는다. 이 과정은 생물학적인 미토시스와 비교할 수 있다. 메서드와 속성은 대응되는 것으로 중복된다.
- 이렇게 접근하면 객체 작성자가 한 부모 객체의 자식 객체들간에 부수효과를 신경쓰지 않고 복제할 수 있다는 이점이 있다. 또 다른 이점은, 디스패치 중 메서드 미리보기의 계산 비용이 위임에 비해서 급격히 줄어든다는 것이다. 위임을 하면 적합한 메서드나 슬롯을 찾는 것을 실패한다면 전체 위임 사슬에서 찾아봐야 하기 때문이다.
- 연쇄 접근 방식의 단점은 시스템을 통해 바뀌는 것을 번식시키는 데에 조직적으로 어렵다는 것이다. 프로토타입에 변화가 생기면 이것은 복제품에 즉시 혹은 자동적으로 적용되지 않는다. 그러나 케보는 위임 방식에서 주로 쓰는 분류상의 원형을 사용하지 않고, 추가적인 기본형을 제공하여 '가족 닮음'(family reseemblances)라고 하는 유사한 객체들을 모아서 변화를 적용한다.
- 다른 단점은 이 형태를 세련되게 구현하지 못하면 원형과 복제품이 같은 부분에서 복제품들이 위임 형태에 비해서 메모리가 더 많이 낭비된다는 것이다. 그러나 케보에서 실제로 하고 있는 접근 방식처럼 공유하도록 구현하고 자료는 배후에 두는 방식으로 프로그래밍에 대한 연쇄적 행동이 가능하다.

## 비평

- 프로토타입기반 시스템을 비판하고 클래스기반 객체 모델을 지지하는 사람들은 프로그래밍 언어의 정적 타입 시스템을 지지하는 사람들이 동적 타입 시스템에 대하여 우려하는 것과 비슷한 점을 우려하고 있다(자료형 참조). 특히, 프로그램의 정확성, 안전성, 예측성, 효율을 떨어뜨린다고 우려한다.
- 정확성, 안전성, 예측성의 관점에서 보면, 클래스는 타입과 비슷하며, 실제로 대부분의 정적 타입 객체지향 언어에서 클래스는 타입의 역할을 한다. 그리고 클래스의 인스턴스는 주어진 방식대로 동작하리라는 확실한 보장이 된다.
- 효율성의 관점에서 보면, 클래스를 선언하면 대부분의 컴파일러는 더 효율적인 메서드와 인스턴스 변수 미리보기가 가능하여 최적화하기 쉽게 된다. 셀프 (프로그래밍 언어)에서 보면, 클래스기반에 비해서 프로토타입 기반 체계는 수행 속도를 빠르게 하는 컴파일과 인터프리트 기술을 개발하는 데 많은 시간이 걸린다. 예를 들어 리삭 컴파일러는 C만큼이나 빨리 코드를 만든다. 테스트는 C 버전에서 복사한 리삭으로 작성된 MPEG-2 코덱으로 하였다. 이 테스트 결과로 리삭 버전이 C 버전보다 1.9% 속도가 느리지만 37%만큼 줄 수가 적었다.
- 마지막으로, 비록 자바스크립트와 같은 언어들이 유명세를 떨치고, 시장에 침투하고 있지만 프로토타입기반 언어가 소프트웨어 개발자들 사이에서 익숙하지 않아서 때문에 많은 비판을 받는다. 그래서 ECMA스크립트 표준의 4번째판이 자바스크립트를 클래스기반 언어로 만들려고 하고 있다. 게다가 프로토타입기반 체계가 상대적으로 기발하고 별로 사용되지 않고 있으며, 소프트웨어를 개발할 때 널리 퍼지지 못하여 최고관행과 멀기 때문이다.

---

참조 : [객체 지향 언어의 두 가지 줄기](http://mohwa.github.io/blog/javascript/2015/10/16/prototype/)

## 정의

- 객체 지향 언어는 크게 두 가지 줄기로 나눌수 있다.
  - 클래스 기반 언어(C++, Java, C#, Ruby, Python 등)
  - 프로토타입 기반 언어
  - 클래스 기반 & 프로토타입 기반 객체 지향 언어
- 클래스 기반 언어와 프로토타입 기반언어의 차이
  - 클래스 기반 언어
    - 클래스 기반 언어에서는, 객체의 형식이 정의된 클래스라는 개념을 가진다.
    - 클래스 기반 언어만의 상속 개념을 가진다.
  - 프로토타입 기반 언어
    - 프로토타입 기반 언어에서는 클래스라는 개념이 존재하지 않으며, 여러 종류의 Built-in 객체들이 시스템상에 존재하게된다. 또한 클래스 기반언어의 상속 개념과 달리, 객체 원형의 위임 과정을 통해 상속 과정이 구현된다.
      - 프로토타입 기반 언어는 클래스가 존재하지 않는다.
    - JS Built-in 객체 중 하나인 Array 객체
- 클래스 기반 언어는 보통 정적 언어를 말하며, JS 와 같은 동적 언어는 컴파일 시점이 아닌 런타임 시점에서 정적 언어가 다루는 특정 일(자료형 검사, 함수 오버로드, 동적 디스패치 등)들을 수행하게된다.
  - 정적/동적 언어란?
    - 정적언어
      - 컴파일 시점에서 자료형 검사가 이루어진다.
      - 컴파일 시점의 자료형 검사로 인해 런타임 시점에서는 자료형에 대한 많은 오류를 줄일 수 있다.(단 컴파일 시점에서 결정될 수 있는 자료형 정보만이 평가(검사)된다)
      - 컴파일 시점에서의 자료형 검사를 반복할 필요가 없기때문에, 전체 프로그램 실행 시간이 줄어든다.
    - 동적언어
      - 런타임 시점에서 자료형 검사가 이루어진다.
      - 런타임 시점의 자료형 검사로 인해 자료형에 대한 런타임 오류가 발생할 수 있다.(빈도수가 생각보다 많을수있다)
      - 모든 런타임 객체가 자료형에 대한 정보를 가지고 있으며, 이를 통해 함수 오버로드, 동적 디스패치 등을 수행할 수 있다.(동적 언어가 가지는 유연성)
      - 변수는 모든 자료형을 가질 수 있다.
        - 자바스크립트는 느슨한 타입 (loosely typed) 언어, 혹은 동적 (dynamic) 언어이다. 그 말은, 변수의 타입을 미리 선언할 필요가 없다는 뜻이다. 타입은 프로그램이 처리되는 과정에서 자동으로 파악될 것이다. 또한 그 말은 같은 변수에 여러 타입의 값을 넣을 수 있다는 뜻이다.
      - 런타임 시점에서 자료형 검사가 이루어진다.
      - 런타임 시점의 자료형 검사로 인해 자료형에 대한 런타임 오류가 발생할 수 있다.
      - 모든 런타임 객체가 자료형에 대한 정보를 가지고 있으며, 이를 통해 함수 오버로드, 동적 디스패치 등을 수행할 수 있다.
        - JS 는 기본적으로 함수 오버로드를 지원하지 않습니다.

```javascript
// 원형 객체가 없는 상태에서 객체를 생성하는 방법(일부 브라우저를 통해 아래와 같은 무형 객체를 구현할 수 있다)
var instance = {};
instance.__proto__ = null;

console.dir(instance); // Object
console.log(typeof instance); // object
```

- 보통 프로토타입 기반 언어에는 Object 객체(Master Object)가 존재하며, 이 객체의 원형에는 모든 객체가 공통적으로 필요한 특징(속성, 메서드)들이 정의되어있다.

## 위임 과정에 대해

- JS는 프로토타입 기반 언어의 특징인 위임 과정을 따른다.
- 모든 위임 과정은 런타임 시점에서 이루어진다.
- 위임이란 객체들간의 원형 복제 과정을 말한다.
- 위임된 객체 원형은 값(value)이 아닌 참조 값(reference of value)을 갖는다.
- 위임된 객체 원형은 해당 객체의 특징(속성, 메서드)들을 공유하기위해 사용된다.
- 위임받은 자식 객체는 부모 객체의 원형을 참조하고 있기 때문에, 자식 객체로 부터 부모 객체의 원형이 변조될 수 있다.(이로인해 아주 위험한 상황이 연출될 수 있다)
  - 위임 받은 자식 객체는 원하는 특징(속성, 메서드)에 도달하기위해, 각 객체들이 가진 원형을 연속적으로 따라가 찾아내게된다.
  - 또한, 프로토타입 검색 범위는 동적으로 변경될 수 있다.

## 연쇄 과정에 대해

- 순수 프로토타입은 연쇄적 프로토타입이라고도 한다.
- 연쇄란 객체들간의 원형 복제 과정을 말한다.
- 연쇄된 객체 원형은 참조 값(reference of value)이 아닌 원본으로부터 복제된 객체 값(value)을 갖는다.
- 연쇄된 자식 객체는 원본 객체로부터 복제된 원형을 참조하기 때문에, 자식 객체를 통해 원본 객체의 특징들이 변조될 수 없다.
- 연쇄된 자식 객체는 원하는 특징(속성, 메서드)에 도달하기위해, 각 객체들이 가진 원형을 연속적으로 따라가 찾아내게된다.
- 연쇄 방식의 프로토타입 검색 범위는 정적(연쇄 시점에 의해)으로 고정된다.
