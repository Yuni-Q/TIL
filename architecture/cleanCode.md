
# Clean Code

## 2장. 의미 있는 이름
프로그래머는 코드를 최대한 이해하기 쉽게 짜야 합니다.  
집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표 입니다.  

- 의도를 분명히 밝혀라
- 그릇된 정보를 피하라
- 의미 있게 구분하라
- 발음하기 쉬운 이름을 사용하라
- 검색하기 쉬운 이름을 사용하라
- 인코딩을 피하라
- 자신의 기억력을 자랑하지 마라
- 클래스나 객체 이름은 명사나 명사구가 적합하다
- 메서드 이름은 동사나 동사구가 적합하다
- 기발한 이름은 피하라
- 한 개념에 한 단어를 사용하라
- 말장난을 하지 마라
- 해법 영역에서 가져온 이름을 사용하라
- 문제 영역에서 가져온 이름을 사용하라
- 의미 있는 맥락을 추가하라
- 불필요한 맥락을 없애라

## 3장. 함수
우리가 함수를 만드는 이유는 큰 개념을 (다시 말해, 함수 이름을) 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서 입니다.  

### 작게 만들어라!(함수를 만드는 첫째 규칙은 ‘작게!’입니다. 함수를 만드는 둘째 규칙은 ‘더 작게’입니다.)  

### 한 가지만 해라!(“함수는 한 가지를 해야 합니다. 그 한 가지를 잘 해야 합니다. 그 한 가지만을 해야 합니다.”)  
> 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 합니다. 따라서, 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈 입니다.  

### 함수당 추상화 수준은 하나로!

### 서술적인 이름을 사용하라!

### 함수 인수
함수에서 이상적인 인수 개수는 0개(무항) 입니다.  
다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)은 가능한 피하는 편이 좋습니다.  
4개 이상(다항)은 특별한 이유가 필요 합니다. 특별한 이유가 있어도 사용하면 안 됩니다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우입니다.  

### 부수 효과를 일으키지 마라!
함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 합니다.  
객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나 입니다.  

### 오류 코드보다 예외를 사용하라!
try/catch 블록은 원래 추합니다.  
코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞습니다.  
그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋습니다.  

## 4장. 주석

### 주석은 나쁜 코드를 보완하지 못한다

### 코드로 의도를 표현하라!

#### 좋은 주석
- 법적인 주석
- 정보를 제공하는 주석
- 의도를 설명하는 주석
- 의미를 명료하게 밝힌 주석: 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용합니다.
- 결과를 경고하는 주석
- TODO 주석
- 중요성을 강조하는 주석
- 공개 API에서 Javadocs

#### 나쁜 주석
> 대다수 주석이 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못합니다.  

- 주절거리는 주석: 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 노력해야 합니다. 이해가 안되어 다른 모듈까지 뒤져야 하는 주석은 독자와 제대로 소통하지 못하는 주석 입니다. 그런 주석은 바이트만 낭비할 뿐입니다.  
- 같은 이야기를 중복하는 주석
- 오해할 여지가 있는 주석
- 의무적으로 다는 주석
- 이력을 기록하는 주석
- 있으나 마나 한 주석
- 함수나 변수로 표현할 수 있다면 주석을 달지 마라
- 위치를 표시하는 주석
- 닫는 괄호에 다는 주석: 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 함수를 줄이려 시도하자.
- 공로를 돌리거나 저자를 표시하는 주석
- 주석으로 처리한 코드
- HTML 주석
- 전역 정보
- 너무 많은 정보: 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라.
- 모호한 관계: 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
- 함수 헤더: 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.
- 비공개 코드에서 Javadocs

## 5장. 형식 맞추기
오랜 시간이 지나 원래 코드의 흔적을 더 이상 찾아보기 어려울 정도로 코드가 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속 영향을 미칩니다.  

### 적절한 행 길이를 유지하라

### 개념은 빈 행으로 분리하라

### 수직 거리
- 변수 선언  
변수는 사용하는 위치에 최대한 가까이 선언 합니다.  

- 인스턴스 변수  
인스턴스 변수는 클래스 맨 처음에 선언 합니다.  

- 종속 함수  
한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치 합니다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치 합니다.    

- 개념적 유사성
어떤 코드는 서로 끌어당깁니다. 개념적인 친화도가 높기 때문입니다. 친화도가 높을수록 코드를 가까이 배치 합니다.  
친화도가 높은 요인은 여러 가지입니다. 앞서 보았듯이, 한 함수가 다른 함수를 호출해 생기는 직접적인 종속성이 한 예 입니다. 변수와 그 변수를 사용하는 함수도 한 예 입니다. 하지만 그 외에도 친화도를 높이는 요인이 있습니다. 비슷한 동작을 수행하는 일군의 함수가 좋은 예 입니다. 명명법이 똑같고 기본 기능이 유사하고 간단 합니다.  

### 가로 공백과 밀집도
가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현합니다.  

## 6장. 객체와 자료 구조

### 자료 추상화
추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스 입니다.  

### 자료/객체 비대칭
복잡한 시스템을 짜다 보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생깁니다.  
이때는 클래스와 객체 지향 기법이 가장 적합합니다.  
반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 생깁니다.  
이 때는 절차적인 코드와 자료 구조가 좀 더 적합합니다.  

### 디미터 법칙
디미터 법칙은 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙 입니다.  
즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미 입니다.  

### 자료 전달 객체
자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스 입니다.  
이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라 합니다.  

### 결론
객체는 동작을 공개하고 자료를 숨깁니다.  
그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵습니다.  
자료 구조는 별다른 동작 없이 자료를 노출 합니다.  
그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵습니다.  
> (어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합 합니다.   
> 다른 경우도 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합 합니다.  

## 7장. 오류 처리
깨끗한 코드와 오류 처리는 확실히 연관성이 있습니다.  
상당수 코드 기반은 전적으로 오류 처리 코드에 좌우 됩니다.   

### 오류 코드보다 예외를 사용하라

### Try-Catch-Finally 문부터 작성하라
예외에서 프로그램 안에다 범위를 정의한다 는 사실은 매우 흥미롭습니다.  
어떤 면에서 try 블록은 트랜잭션과 비슷 합니다.  
try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지 합니다.  
그러므로 예외가 발생할 코드를 짤 때는 Try-Catch-Finally 문으로 시작하는 편이 좋습니다.  

### 예외에 의미를 제공하라
전후 상황을 충분히 덧붙여 오류 메시지에 정보를 담아 예외와 함께 던집니다.  

### 호출자를 고려해 예외 클래스를 정의하라
애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 합니다.  
흔히 예외 클래스가 하나만 있어도 충분한 코드가 많습니다.  
예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇습니다.  
한 예외는 잡아내고 다른 예외는 무시해도 괜찮은 경우라면 여러 예외 클래스를 사용 합니다.  

### 결론
깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 합니다.  
이 둘은 상충하는 목표가 아닙니다.  
오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있습니다.  
오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아집니다.  

## 8장. 경계

### 경계 살피고 익히기
간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨가? 짐 뉴커크(Jim Newkirk)는 이를 학습 테스트 라 부릅니다.  
학습 테스트는 프로그램에서 사용하려면 방식대로 외부 API를 호출 합니다.  
통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈입니다.  

### 깨끗한 경계
외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 합니다.  
Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환 합니다.  

## 9장. 단위 테스트
TDD 법칙 세 가지  
- 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 둘째 법칙: 컴파일은 실패하지 않으면서 실행히 실패하는 정도로만 단위 테스트를 작성한다.
- 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

### 깨끗한 테스트 코드 유지하기
> 테스트 코드는 실제 코드 못지 않게 중요합니다.  
> 테스트는 유연성, 유지보수성, 재사용성을 제공합니다.  








