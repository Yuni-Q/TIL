# object 부록 C 동적인 협력, 정적인 코드

- 협력을 구성하기 위해서는 살아 움직이는 객체가 필요합니다. 객체는 태어나고 협력하고, 책임을 다하고 나면 소멸합니다. 객체의 상태는 지속적으로 변하고, 외부의 자극에 따라 다양한 방식으로 행동합니다. 간단히 말해 객체는 동적입니다. 살아 움직이는 존재인 것입니다.
- 객체의 움직임과 변화를 표현하기 위해 우리는 객체지향 프로그래밍 언어를 사용합니다. 문제는 프로그래밍을 위해 사용하는 텍스트라는 표현 도구가 정적이라는 것입니다. 프로그램은 일단 작성되고 나면 프로그램은 고정된 텍스트라는 형식 안에 갇혀 있으면서도 객체의 모든 변화 간으성을 담아야 합니다.
- 이것은 프로그래머가 객체지향 프로그램을 작성하기 위해서는 두 가지 모델을 동시에 마음속에 그려야 한다는 것을 의미합니다. 하나는 프로그램 실행 구조를 표현하는 움직이는 모델이고 또 다른 하나는 코드의 구조를 담는 고정된 모델입니다. 전자를 `동적 모델(dynamic model)`이라고 부르고 후자를 `정적 모델(static model)`이라고 부릅니다.
- 훌륭한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요합니다. 객체지향의 세계에서 동적 모델은 `객체`와 `협력`으로 구성됩니다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행합니다. 객체지향의 세계에서 정적 모델은 `타입`과
- 훌륭한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요합니다. 객체지향의 세계에서 동적 모델은 `객체`와 `협력`으로 구성됩니다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행합니다. 객체지향의 세계에서 정적 모델은 `타입`과
- 훌륭한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요합니다. 객체지향의 세계에서 동적 모델은 `객체`와 `협력`으로 구성됩니다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행합니다. 객체지향의 세계에서 정적 모델은 `타입`과
- 훌륭한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요합니다. 객체지향의 세계에서 동적 모델은 `객체`와 `협력`으로 구성됩니다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행합니다. 객체지향의 세계에서 정적 모델은 `타입`과
- 훌륭한 객체지향 프로그램을 작성하기 위해서는 동적 모델과 정적 모델을 조화롭게 버무릴 수 있는 능력이 필요합니다. 객체지향의 세계에서 동적 모델은 `객체`와 `협력`으로 구성됩니다. 객체는 다른 객체와 협력하면서 애플리케이션의 기능을 수행합니다. 객체지향의 세계에서 정적 모델은 `타입`과 `관계`로 구성됩니다. 타입은 객체를 분류하기 위한 틀로서 동일한 타입에 속하는 객체들이 수행할 수 있는 모든 행동들을 압축해서 표현한 것입니다. 클래스 기반의 객체지향 언어에서 타입을 구현하는 가장 대표적인 방법은 클래스를 사용하는 것이므로 일반적으로 정적 모델이라고 하면 클래스로 구성된 모델을 의미합니다.
- 정적 모델은 동적 모델에 의해 주도돼야 하고 동적 모델이라는 토대 위에 세워져야 합니다. 프로그램 코드 안에 담아지는 정적 모델은 객체 사이의 협력에 기반해야 합니다.
- 동적 모델을 기반으로 정적 모델을 구상할 때 고려해야 하는 중요한 요소는 변경입니다. 설계가 필요한 이유는 변경을 수용할 수 있는 코드를 만들기 위해서입니다. 여기서 변경을 수용할 수 있는 코드란 단순하고, 결합도가 낮으며, 중복 코드가 없는 코드를 의미합니다.
- 수정이 용이한 코드란 응집도가 높고, 결합도가 낮으며, 단순해서 쉽게 이해할 수 있는 코드입니다.
- 유연한 코드란 동일한 코드를 이용해 다양한 컨텍스트에서 동작 가능한 협력을 만들 수 있는 코드입니다. 유연성의 관점에서 작성된 코드는 객체 사이의 다양한 조합을 지원해야 합니다.
- 수정이 용이한 코드와 유연한 코드에 대한 욕구는 중복 코드를 제거하게 만든느 가장 큰 압력입니다. 중복 코드가 많을수록 하나의 개념을 변경하기 위해 여러 곳의 코드를 한꺼번에 수정해야 합니다. 코드를 수정하는 작업 자체의 괴로움은 둘째치고라도 버그가 바생할 수 있는 확률이 높아지기 때문에 중복 코드는 언제 터질지 모르는 시한폭탄과도 같습니다. 유연한 코드를 향해 나아가다 보면 서로 다른 컨텍스트 사이의 공통점을 하나의 코드로 모아야 하는 상황에 직면합니다. 그리고 이런 필요성이 중복 코드를 제거하고 새로운 추상화를 도입하게 만듭니다.
- 좋은 설계는 객체 사이의 협력과 행동을 표현하는 동적 모델을 기반으로 해야 합니다. 정적 모델은 동적 모델이 그려놓은 윤곽을 따라야 하는 것입니다.

## 01. 동적 모델과 정적 모델

### 행동이 코드를 결정한다

- 협력에 참여하는 객체의 행동이 객체의 정적 모델을 결정해야 합니다. 행동이 코드의 구조에 영향을 미치는 대표적인 예가 바로 상속 계층을 구성하는 방식입니다.
- 객체의 정적 모델은 동적 모델이라는 토대 없이는 완전해질 수 없습니다. 가장 중요한 것은 객체가 외부에 제공하는 행동입니다. 정적 모델을 설계하는 이유는 단지 행동과 변경을 적절하게 수용할 수 있는 코드 구조를 찾는 것이어야 합니다.
- 정적 모델을 미리 결정하고 객체의 행동을 정적 모델에 맞춰서는 안 됩니다. 동적 모델이 정적 모델을 결정해야 합니다. 만약 정적 모델이 협력에 적합하지 않다면 정적 모델을 지속적으로 개선합니다.

### 변경을 고려하라

- 객체가 제공하는 행동의 측면에서 적절하게 정적 모델을 고려하더라도 변경을 고려하지 않는다면 유지보수하기 어려운 코드가 만들어집니다.

## 02. 도메인 모델과 구현

### 도메인 모델에 관하여

- `도메인(domain)`이란 사용자가 프로그램을 사용하는 대상 영역을 가리킵니다. `모델(model)`이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태입니다. `도메인 모델(domain model)`이란 사용자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태입니다.
- 객체지향 분석 설계에서 지침 중 하나는 소프트웨어의 도메인에 대해 고민하고 도메인 모델을 기반으로 소프트웨어를 구축하라는 것입니다. 이 지침을 따르면 개념과 소프트웨어 사이의 표현적 차이를 줄일 수 있기 때문에 이해하고 수정하기 쉬운 소프트웨어를 만들 수 있습니다.
- 중요한 것은 도메인 모델을 작성하는 것이 목표가 아니라 출발점이라는 것입니다. 우리가 소프트웨어를 만들기 위해 수행하는 모든 활동의 궁극적인 목적은 동작하는 소프트웨어를 만드는 것입니다. 도메인 모델은 소프트웨어를 만드는 데 필요한 개념의 이름과 의미, 그리고 관계에 대한 힌트를 제공하는 역할로 끝나야 합니다.
- 불행은 도메인 안의 개념이 제공하는 틀에 맞춰서 소프트웨어를 구축해야 한다고 생각할 때부터 시작됩니다. 그리고 도메인 모델이 클래스 다이어그램과 같은 정적 모델에 깁나해야 한다는 오해 역시 잘못된 구조를 낳는 원인이 됩니다. 도메인 모델이 클래스 다이어그램과 같은 정적인 형태로 표현돼야 한다는 것 역시 오해입니다. 도메인 모델은 여러분의 도메인에 대한 지식을 표현하고 코드의 구조에 대한 힌트를 제공할 수 있다면 어떤 형태로 표현하더라도 상관이 없습니다. 사실 객체 사이의 협력을 도드라지게 보여주는 개념적인 표현 역시 도메인 모델이 될 수 있습니다
- 우리에게 중요한 것은 소프트웨어의 기능과 객체의 책임입니다. 코드의 구조를 이끄는 것은 도메인 안에 정립된 개념의 분류 체계가 아니라 객체들의 협력입니다. 도메인 안의 개념들을 기반으로 출발하되 객체들의 협력이 도메인 모델에 맞지 않다면 필요한 몇 가지 개념만 남기고 모데인 모델을 과감히 수정합니다.
- 중요한 것은 객체들의 협력을 지원하는 코드 구조를 만드는 것입니다. 도메인의 개념을 충실히 따르는 코드가 목적이 아닙니다. 코드의 구조를 주도하는 것은 구조가 아니라 행동이라는 사실을 기억해야 합니다.
- 도메인 모델에 지나치게 집착하거나 도메인 모델의 초기 구조를 맹목적으로 따르는 코드를 작성하고 있다면 변경하기 어려운 소프트웨어가 만들어질 확률이 높습니다.
- 의사소통 패턴은 객체들이 다른 객체와 상호작용하는 방법을 관장하는 각종 규칙으로 구성돼 있습니다. 우리가 생각하기에 도메인 모델은 이러한 의사소통 패턴에 속합니다. 의사소통 패턴은 객체 간에 있을 법한 관계에 의미를 부여하기 때문입니다. 시스템은 그것이 지닌 역학 측면에서 생각해보면, 의사소통 구조는 객체라는 것을 처음 접할 때 배우는 정적인 분류에서 개념적으로 굉장히 발전한 단계에 해당합니다. 도메인 모델은 명확하게 드러나지 않는데, 이는 의사소통 패턴이 우리가 사용하는 프로그래밍 언어로 명확하게 표현되지 않기 때문입니다. 정적인 분류와 동적인 의사소통 간의 불일치 탓에 객체에 대한 깔금한 클래스 계층 구조를 생각해 내기란 어려울 것입니다. 기껏해야 클래스 계층 구조는 1차원적인 애플리케이션을 나타내면서 객체 간의 구현 세부 사항을 공유하는 메커니즘만을 제공합니다.

### 몬스터 설계하기

- 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법을 `TYPE OBEJECT 패턴`이라고 부릅니다.

### 행동가 변경을 고려한 도메인 모델

- 우리는 도메인 모델을 먼저 만들고 만들어진 도메인 모델에 표현된 개념과 관계를 기반으로 협력에 필요한 객체의 후보를 도출하고 구현 클래스의 이름과 관계를 설계합니다. 하지만 도메인 모델을 그대로 카피해서는 안 됩니다. 초기의 도메인 모델은 그저 작업을 시작하기 위해 거친 아이디어 덩어리일 뿐입니다. 더 많은 지식이 쌓이고 요구사항이 분명해지면 초기의 아이디어에 대한 미련을 버리고 현명한 판단을 내려야 합니다.
- 초기에 고안한 도메인 모델은 좋은 출발점이 될 수는 있지만 객체의 행동과 변경이라는 요소를 고려하면 빠르게 그 가치가 떨어집니다. 구현하거나 변경하기 더 쉬운 모델이 떠올랐다면 과감하게 초기 아이디어를 버립니다. 객체지향의 핵심은 객체 사이의 렵력이며 설계는 변경을 위한 것입니다. 따라서 행동과 변경을 고려하지 않은 채 도메인 모델을 그대로 따르는 설계는 코드의 유지보수를 방해할 뿐입니다.
- 도메인 모델은 단순히 클래스 다이어그램이 아닙니다. 도메인의 핵심을 간략하게 단순화해서 표현할 수 있는 모든 것이 도메인 모델입니다. 그리고 그렇게 작성된 개념이 여러분의 코드에 대한 구조와 행동을 드러낸다면 그것은 더없이 룰륭한 도메인 모델입니다. 형식은 중요하지 않습니다. 중요한 것은 전달하려는 의미입니다.
- 도메인 모델이 단순히 정적 모델의 형태를 띨 필요가 없으면 도메인 모델의 구조가 코드와 다를 필요가 없다는 것입니다. 도메인 모델은 코드를 위한 것입니다. 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야 하지만 최종 모습은 객체의 행동과 변경에 기반해야 하며 코드의 구조를 반영해야 합니다. 중요한 것은 도메인 모델을 봤을 때 도메인의 개념뿐만 아니라 코드도 함께 이해될 수 있는 구조를 찾는 것입니다.

### 분석 모델, 설계 모델, 그리고 구현 모델

- 이론적으로 분석 모델은 해결 방법에 대한 언급 없이 문제 도메인을 설명하는 모델입니다. 분석 모델은 순수하게 문제 도메인에 초점을 맞춰야 하며 기술적인 해결 방법을 언급해서는 안 됩니다. 분석 모델이 완성되면 이를 바탕으로 기술적인 관점에서 솔루션을 서술하는 설계 모델이 만들어집니다. 프로그래머는 이렇게 만들어진 청사진을 기반으로 구현 모델을 만들고 프로그래밍 언어를 사용해 컴퓨터가 이해할 수 있는 명령어로 변환합니다. 그러나 분석 모델, 설계 모델, 구현 모델을 명확하게 구분하는 것은 가능하지도 않을뿐더러 오히려 소프트웨어의 품질에 악영향을 미칩니다. 우리가 원하는 것은 분석과 설계와 구현 동안 동일한 모델을 유지하는 것입니다.
- 도메인 모델이 코드와 동일한 형태를 가진다는 것은 분석, 설계, 구현에 걸쳐 동일한 모델을 사용한다는 것을 의미합니다. 사실 객체지향 패러다임이 과거의 다른 패러다임과 구별되는 가장 큰 차이점은 소프트웨어를 개발하기 위한 전체 주기 동안 동일한 설계 기법과 모델링 방법을 사용할 수 있다는 것입니다. 그리고 이것이 우리가 객체지향 패러다임을 사랑하는 가장 큰 이유입니다.
- 분석 모델과 설계 모델의 하이브리드한 특징이 가장 좋은 모델을 낳는 토양이라면 프로그래밍 언어를 사용해서 구현한 코드가 이 모델을 최대한 반영하는 것이 가장 이상적일 것입니다. 만약 설계의 일부가 적용 기술 내에서 구현 불가능하다면 설계 모델을 변경해야 합니다. 프로그래밍 작업 동안 설계의 실현 가능성과 정확성이 검증되고 테스트되고, 그 결과로 잘못된 설계가 수정되거나 새로운 설계로 대체됩니다. 따라서 프로그래밍은 설계의 한 과정이며 설계는 프로그래밍을 통해 개선됩니다.
- 분석과 설계와 구현 간의 구분이 방법론과 프로젝트 관리를 위해 필요한 중요 요소라고 하더라도 모델과 코드 간의 관계에 이를 강요해서는 안 됩니다. 모델링 툴에 저장된 다이어그램이 코드와 상관이 없다면 당장 다이어그램을 파기하고 모델링 툴을 쓰레기통에 집어 던진 후 프로젝트 관리자에게 라이선스 비용이 더 이상 필요하지 않다는 희소식을 전합니다. 프로젝트 내에서 분석 모델을 설계 모델로 변환하는 작업에 많은 시간을 소비하고 있다면 설계 모델을 도메인을 반영하도록 수정하고 분석 모델을 폐기처분합니다. 이런 프로젝트는 소프트웨어 자체가 아니라 프로세스를 위한 맹목적인 작섭에 개발자들의 소중한 시간과 체력을 낭비하고 있을 뿐입니다.
- 코드와 모델의 차이를 줄이기 위해서는 도메인과 코드 간의 차이가 적어야 합니다. 현재 프로그래밍 패러다임을 주도하고 있는 객체지향의 가장 큰 힘은 도메인을 표현하는 방법과 프로그램 코드를 표현하는 방법이 동일하다는 것입니다. 만약 객체지향 언어를 사용하고 있다면 프로그램 코드를 설계 문서로 간주할 수 있는 기반은 갖춰진 셈입니다.
- 분석 모델과 설계 모델과 구현 모델이 다르다는 생각을 버립니다. 그리고 분석과 설계와 구현이 별개의 활동이라는 생각 역시 버립니다. 여러분의 손에 쥐어진 객체지향 프로그래밍 언어는 도메인을 바라보는 관점을 소프트웨어에 투영할 수 있는 다양한 기법들을 제공합니다. 도메인 개념과 객체 사이의 협력을 잘 버무려 코드에 반영하기 위해 고민하고 프로그래밍하는 동안 분석과 설계와 구현에 대해 동시에 고민하고 있는 것입니다.
- 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확성도 이심스러워집니다. 동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해집니다. 분석과 설계가 치명적으로 동떨어지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않습니다. 모델이 구현에 대해 비현실적으로 보인다면 새로운 모델을 찾아내야만 합니다. 모델이 도메인의 핵심 개념을 충실하게 표현하지 않을 때도 새로운 모델을 찾아내야만 합니다. 그래야만 모델링과 설계 프로세스가 단 하나의 반복 고리를 형성할 수 있습니다.
- 여러분의 코드는 도메인의 개념적인 분류 체계가 아니라 객체의 행동과 변경에 영향을 받습니다. 그리고 객체지향 패러다임에 대한 흔한 오해와 다르게 분석 모델과 설계 모델, 구현 모델 사이의 어떤 차이점도 존재하지 않습니다. 이것들은 모두 행동과 변경이라는 요소에 영향을 받으며 전체 개발 주기 동안 동잉한 모양을 지녀야 합니다.
- 객체지향 패러다임이 강력한 이유는 전체 개발 주기에 걸쳐 동일한 기법과 포현력을 유지할 수 있다는 점입니다. 분석, 설계, 구현 단계 사이에 세부적인 내용을 다를 수 있겠지만 설계의 초점은 동일합니다. 결론은 모든 단계에 걸쳐 행동과 변경에 초점을 맞추라는 것입니다.
