# object 부록 A 계약에 의한 설계

- 의도를 드러내도록 인터페이스를 다듬고 명령과 쿼리를 분리했다고 하더라도 명령으로 인해 발생하는 부수효과를 명확하게 표현하는 데는 한계가 있습니다. 주석으로 부수효과를 서술하는 것도 가능하겠지만 파급효과를 명확하게 전달하기가 쉽지 않을뿐더러 시간이 흐를수록 구현을 정확하게 반영하지 못할 가능성도 높습니다.
- 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵습니다.
- `계약에 의한 설계(Design By Contract, DBC)`를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있습니다. 클라이언트 개발자는 오퍼레이션의 구현을 살펴보지 않더라도 객체의 사용법을 쉽게 이해할 수 있습니다. 계약은 실행 가능하기 때문에 구현에 동기화돼 있는지 여부를 런타임에 검증할 수 있습니다. 따라서 주석과 다르게 시간의 흐름에 뒤처질 걱정을 할 필요가 없습니다. 계약에 의한 설계는 클래스의 부수효과를 명시적으로 문서화하고 명확하게 커뮤니케이션할 수 있을뿐만 아니라 실행 가능한 검증 도구로써 사용할 수 있습니다.

## 01. 협력과 계약

### 부수효과를 명시적으로

- 객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동입니다. 안타깝게도 프로그래밍 언어로 작성된 인터페이스는 객체가 수산할 수 있는 메시지는 정의할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없습니다. 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달할 수 있지만 협력을 위해 필요한 약속과 제약은 인터페이스를 통해 전달할 수 없기 때문에 협력과 관련된 상당한 내용이 암시적인 상태로 남게 됩니다.
- 계약에 의한 설계를 사용하면 제약 조건을 명시적으로 표현하고 자동으로 문서화할 수 있을뿐만 아니라 실행을 통해 검증할 수 있습니다.

### 계약

- 계약의 세부적인 내용은 상황에 따라 다르겠지만 일반적으로 다음과 같은 특성을 가집니다.
  - 각 계약 당사자는 계약으로부터 `이익(benefit)`을 기대하고 이익을 얻기 위해 `의무(obligation)`를 이행합니다.
  - 각 계약 당사자의 이익과 의무는 계약서에 `문서화`됩니다.
- 한쪽의 의무가 반대쪽의 권리가 됩니다. 두 계약 당사자 중 어느 한쪽이라도 계약서에 명시된 내용을 위반한다면 계약은 정상적으로 완료되지 않을 것입니다.
- 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어 입니다.

## 02. 계약에 의한 설계

- 계약은 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화한 것입니다.
  - 협력에 참여하는 각 객체는 계약으로부터 `이익(benefit)`을 기대하고 이익을 얻기 위해 `의무(obligation)`를 이행합니다.
  - 협력에 참여하는 각 객체의 이익과 의무는 계약서에 `문서화`됩니다.
- 계약에 의한 설계 개념은 '인터페이스에 대해 프로그래밍하라'는 원칙을 확장한 것입니다. 계약에 의한 설계를 이용하면 오퍼레이션의 시그니처를 구성하는 다양한 요소들을 이용해 협력에 참여하는 객체들이 지켜야 하는 제약 조건을 명시할 수 있습니다. 이 제약 조건을 인터페이스의 일부로 만듦으로써 코드를 분석하지 않고도 인터페이스의 사용벙을 이해할 수 있습니다.
- 협력하는 클라이언트는 정상적인 상태를 가진 객체와 협력해야 합니다.
- 서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대합니다. 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 예상합니다. 클라이언트는 메시지 전송 전과 후의 서버의 상태가 정상일 것이라고 기대합니다. 이 세 가지 기대가 바로 계약에 의한 설계를 구성하는 세 가지 요소에 대응됩니다. 이 요소들을 순서대로 사전조건, 사후조건, 불변식이라고 부릅니다.
  - 사전조건(precondition) : 메서드가 호출되기 전에 만족돼야 하는 조건. 이것은 메서드의 요구사항을 명시합니다. 사전조건이 만족되지 않을 경우 메서드가 실행돼서는 안 됩니다. 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무입니다.
  - 사후조건(postcondition) : 메서드가 실행된 후에 클라이언트에게 보장하는 조건. 클라이언트가 사전조건을 만족시켰다면 메서드는 사후조건에 명시된 조건을 만족시켜야 합니다. 만약 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우에 클라이언트에게 예외를 던져야 합니다. 사후조건을 만족시키는 것은 서버의 의무입니다.
  - 불변식(invariant) : 항상 참이라고 보장되는 서버의 조건. 메서드가 실행되는 도중에는 불변식을 만족시키지 못한 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이어야 합니다.
- 사전조건, 사후조건, 불변식을 기술할 때는 실행 절차를 기술할 필요 없이 상태 변경만을 명시하기 때문에 코드를 이해하고 분석하기 쉬워집니다. 클라잉너트 개발자는 사전조건에 명시된 조건을 만족시키지 않으면 메서드가 실행되지 않을 것이라는 사실을 잘 알고 있습니다. 불변식을 사용하면 클래스의 의미를 쉽게 설명할 수 있고 클라이언트 개발자가 객체를 더욱 쉽게 예측할 수 있습니다. 사후조건을 믿는다면 객체가 내부적으로 어떤 방식으로 동작하는지 걱정할 필요가 없습니다. 사전조건, 사후조건, 불변식에는 클라이언트 개발자가 알아야 하는 모든 것이 포함돼 있을 것입니다.

### 사전조건

- 사전조건이란 메서드가 정상적으로 실행되기 위해 만족해야 하는 조건입니다. 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무입니다. 따라서 사전조건을 만족시키지 못해서 메서드가 실행되지 않을 경우 클라이언트에 버그가 있다는 것을 의미합니다. 사전조건이 만족되지 않을 경우 서버는 메서드를 실행할 의무가 없습니다.
- 일반적으로 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용됩니다.
- 계약에 의한 설계를 사용하면 계약만을 위해 준비된 전용 표기법을 사용해 계약을 명확하게 표현할 수 있습니다. 또한 계약을 일반 로직과 분리해서 서술함으로써 계약을 좀 더 두드러지게 강조할 수 있습니다. 또한 계약이 메서드의 일부로 실행되도록함으로써 계약을 강제할 수 있습니다.

### 사후조건

- 사후조건은 메서드에 실행 결과가 올바른지 검사하고 실행 후에 객체가 유효한 상태로 남아 있는지를 검증합니다. 간단히 말해서 사후조건을 통해 메서드를 호출한 후에 어떤 일이 일어났는지를 설명할 수 있는 것입니다. 클라이언트가 사전조건을 만족시켰는데도 서버가 사후조건을 만족시키지 못한다면 서버에 버그가 있음을 의미합니다.
- 일반적으로 사후조건은 다음과 같은 세 가지 용도로 사용됩니다.
  - 인스턴스 변수의 상태가 올바른지를 서술하기 위해
  - 메서드에 전달된 파라미터 값이 올바르게 변경됐는지를 서술하기 위해
  - 반환값이 올바른지 서술하기 위해
- 사전조건보다 사후조건을 정희하기 어려운 이유
  - 한 메서드 안에서 return 문이 여러 번 나올 경우 : 모드 return 문마다 결괏값이 올바른지 검증하는 코드를 추가해야 합니다. 다행히도 계약에 의한 설계를 지원하는 대부분의 라이브러리는 결괏값에 대한 사후조건을 한 번만 기술할 수 있게 해줍니다.
  - 실행 전과 실행 후의 값을 비교해야 하는 경우 : 실행 전의 값이 실행으로 인해 다른 갑승로 변경됐을 수도 있기 때문에 두 값을 비교하기 어려울 수 있습니다. 다행히 계약에 의한 설계를 지원하는 대부분의 라이브러리는 실행 전의 ㄱ밧에 접근할 수 있는 간편한 방법을 제공합니다.

### 불변식

- 사전조건과 사후조건은 각 메서드마다 달라지는 데 반해 불변식은 인스턴스 생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세합니다. 일반저긍로 불변식은 객체의 내부 상태와 관련이 있습니다.
- 불변식은 다음과 같은 두 가지 특성을 가집니다.
  - 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 합니다. 이것은 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미합니다.
  - 불변식은 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 합니다. 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메서드 실행 전과 메서드 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 합니다.
- 불변식은 클래스의 모든 메서드의 사전조건과 사후조건에 추가되는 공통의 조건으로 생각할 수 있습니다. 불변식은 메서드가 실행되기 전에 사전조건과 함께 실행되며, 메서드가 실행된 후에 사후조건과 함께 실행됩니다. 만약 불변식을 수작업으로 작성한다면 모든 메서드에 동일한 불변식을 추가해야 할 것입니다. 물론 대부분의 라이브러리들은 불변식을 한 번만 작성하면 모든 사전조건과 사후조건에 자동으로 합쳐주는 기능을 제공합니다.

## 03. 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계의 핵심은 클라이언트와 서버 사이의 견고한 협력을 위해 준수해야 하는 규약을 정의하는 것입니다. 계약에 의한 설계는 클라이언트가 만족시켜야 하는 사전조건과 클라이언트의 관점에서 서버가 만족시캬야 하는 사후조건을 기술합니다. 계약에 의한 설계와 리스코프 치환 원척이 만나는 지점이 바로 이곳입니다. 리스코프 치환 원칙은 슈퍼타입의 인스턴스와 협력하는 클라이언트의 관점에서 서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미합니다.
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 합니다.
- 리스코프 치환 원칙의 규칙을 두 가지 종류로 세분화할 수 있습니다.
  - 첫 번째 규칙은 협력에 참여하는 객체에 대한 기대를 표현하는 `계약 규칙`입니다.
  - 두 번째 규칙은 교체 가능한 타입과 관련된 `가변성 규칙`입니다.
- `계약 규칙(contract rules`은 슈퍼타입과 서브타입 사이의 사전조건, 사후조건, 불변식에 대해 서술할 수 있는 제약에 관한 규칙입니다.
  - 서브타입에 더 강력한 사후조건을 정의할 수 없습니다.
  - 서브타입에 더 완화된 사후조건을 정의할 수 없습니다.
  - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 합니다.
- `가변성 규칙(variance rules)`은 파라미터와 리턴 타입의 변형과 관련된 규칙입니다.
  - 서브타입의 메서드 파라미터는 반공변성을 가져야 합니다.
  - 서브타입의 리턴 타입은 공변성을 가져야 합니다.
  - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 됩니다.
- 대부분의 객체지향 언어에서 공변성과 반공변성이 중요해지는 곳은 상속이 제네릭 프로그래밍과 만나는 지점입니다. 여기서의 초점은 일반적인 클래스의 상속에 맞춰져 있으므로 제네릭 프로그래밍과 관련된 가변성 규칙은 다루지 않습니다.
- 계약에 의한 설계는 협력을 올바르게 설계하기 위해 고려해야 하는 설계 원칙과 설계 방법이지 특정한 구현 메커니즘이 아닙니다. 비록 계약에 의한 설계를 위한 적절한 라이브러리가 존재하지 않거나 언어 차원에서 지원하지 않는다고 하더라도 계약에 의한 설계를 적용하는 것은 가능합니다.

### 계약 규칙

#### 서브타입에 더 강력한 서전조건을 정의할 수 없습니다.

- 서브타입이 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 됩니다. 계약서에 명시된 의무보다 더 많은 의무를 짊어져야 한다는 사실을 순순히 납득하는 클라이언트는 없을 것입니다. 결국 사전조건을 강화한 서브타입은 클라이언트의 입장에서 수용이 불가능하기 때문에 슈퍼타입을 대체할 수 없게 됩니다. 따라서 사전조건 강화는 리스코프 치환 원칙 위반입니다.

#### 서브타입에 더 완화된 사후조건을 정의할 수 없습니다.

- 계약서에 명시된 이익보다 더 적은 이익을 받게 된다는 사실을 납득할 수 있는 클라이언트는 없습니다. 결국 사후조건을 완화시키는 서버는 클라이언트의 관점에서 수용할 수 없기 때문에 슈퍼타입을 대체할 수 없습니다. 사후조건 완화는 리스코프 치환 원칙 위반입니다.

#### 일찍 실패하기(Fail Fast)

- 문제가 발생한 그 위치에서 프로그램이 실패하도록 만듭니다. 문제의 원인을 파악할 수 있는 가장 빠른 방법은 문제가 발생하자마자 프로그램이 일찍 실패하게 만든느 것입니다.
- 가능한 한 빨리 문제를 발견하게 되면 좀 더 일찍 시스템을 멈출 수 있다는 이득이 있습니다. 게다가 프로그램을 멈추는 것이 할 수 있는 최선일 때가 많습니다. 방금 불가능한 뭔가가 발생했다는 것을 코드가 발견한다면 프로그램은 더 이상 유효하지 않다고 할 수 있습니다. 이 시점 이후로 하는 일은 모두 수상쩍게 됩니다. 되도록 빨리 종료해야 합니다. 일반적으로, 죽은 프로그램이 입히는 피해는 절름발이 프로그램이 끼치는 것보다 훨씬 덜한 법입니다.

#### 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 합니다.

- 불변식은 메서드가 실행되기 전과 후에 반드시 만족시켜야 하는 조건입니다. 모든 객체는 객체가 생성된 직후부터 소멸될 때까지 불변식을 만족시켜야 합니다. 하지만 메서드를 실행하는 도중에는 만족시키지 않아도 무방합니다. 생성자의 경우 시작 시점에는 불변식을 만족시키지 않겠지만 생성자가 종료되는 시점에는 불변식을 만족시켜야 합니다.
- 자식 클래스가 계약을 위반할 수 있는 코드를 작성하는 것을 막을 수 있는 유일한 방법은 인스턴스 변수의 가시성을 protected가 아니라 private으로 만드는 것뿐입니다. protected 인스천스 변수를 가진 부모 클래스의 불변성은 자식 클래스에 의해 언제라도 쉽게 무너질 수 있습니다. 모든 인스턴스 변수의 가시성은 private으로 제한돼야 합니다.
- 자식 클래스에서 이스턴스 변수의 상태를 변경하고 싶다면 부모 클래스에 protected 메서드를 제공하고 이 메서드를 통해 불변식을 체크하게 해야 합니다.

### 가변성 규칙

#### 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 됩니다

- 일반적으로 부모 클래스가 던지는 예외가 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우 자식 클래스는 부모 클래스를 대체할 수 없습니다. 따라서 서브타입이 아닙니다.
- 클라이언트의 관점에서 부모 클래스에 대해 기대했던 것보다 더 적은 일을 수행하는 자식 클래스는 부모 클래스와 동일하지 않습니다. 부모 클래스보다 못한 자식 클래스는 서브타입이 아닙니다.

#### 서브타입이 리턴 타입은 공변성을 가져야 합니다

- 공변성(covariance) : S와 T 사이의 서브타입 관계가 그대로 유지됩니다. 이 경우 해당 위치에서 서브타입인 S가 슈퍼타입인 T 대신 사용될 수 있습니다. 우리가 흔히 이야기하는 리스코프 치환 원칙은 공변성과 관련된 원칙이라고 생각하면 됩니다.
- 반공변성(contravariance) : S와 T 사이의 서브타입 관계가 역전됩니다. 이 경우 해당 위치에서 슈퍼타입인 T가 서브타입인 S 대신 사용될 수 있습니다.
- 무공변성(invariance): S와 T 사이에는 아무런 관계도 존재하지 않습니다. 따라서 S 대신 T를 사용하거나 T 대신 S를 사용할 수 없습니다.
- 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩 할 때 부모 클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성을 `리턴 타입 공변성(return type covariance)`이라고 부릅니다. 간단하게 말해서 리턴 타입 공변성이란 메서드를 구현한 클래스의 타입 계틍 방향과 리턴 타입의 계층 방향이 동일한 경우를 가리킵니다.
- 슈퍼타입 대신 서브타입을 반롼하는 것은 더 강력한 사후조건을 정의하는 것과 같습니다. 따라서 리턴 타입 공변성은 계약에 의한 설계 관점에서 계약을 위반하지 않습니다.

### 서브타입의 메서드 파라미터는 반공변성을 가져야 합니다

- 부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 특성을 `파라미터 타입 반공변성(parameter type contravariance)`이라고 부릅니다. 간단하게 말해서 파라미터 타입 반공변성이란 메서드를 정의한 클래스의 타입 계층과 파라미터의 타입 계층의 방향이 반대인 경우 서브타입 관계를 만족한다는 것을 의미합니다.
- 서브타입 대신 슈퍼타입을 파라미터로 받는 것은 더 약한 사후저건을 정의하는 것과 같습니다. 따라서 파라미터 타입 반공변성은 걔약에 의한 설계 관점에서 계약을 윕반하지 않습니다.
- 리턴 타입 공변성과 파라미터 타입 반공변성을 사전조건과 사후조건의 관점에서 설명할 수도 있습니다. 서브타입은 슈퍼탄입에서 정의한 것보다 더 강력한 사전조건을 정의할 수는 없지만 사전조건을 완화할 수는 있습니다.
- 사전조건은 파라미터에 대한 제약조건이므로 이것은 슈퍼타입에서 정의한 파라미터 타입에 대한 제약을 좀 더 완화할 수 있다는 것을 의미합니다. 따라서 좀 더 완화된 슈퍼타입을 파라미터로 받을 수 있는 것입니다.
- 리턴 타입은 사후조건과 관련이 있으며 서브타입은 슈퍼타입에서 정의된 사후조건을 완화시킬 수는 없지만 강화할 수는 있다는 사실을 기억해야 합니다. 따라서 슈퍼타입에서 정의한 리턴 타입보다 더 강화된 서브 타입 인스턴스를 반환하는 것이 가능한 것입니다.
- 사실 객체지향 언어 중에서 파라미터 반공변성을 지원하는 언어는 거의 없다고 봐도 무방합니다. 여기서 파라미터 반공변성에 대해 언급하는 이유는 제네릭 프롤그래밍에서는 파라미터 반공변성이 중요한 의미를 가지기 때문입니다. 이번 장에서 설명한 기본적인 내용을 알아두는 것은 제네릭 프로그래밍을 공부하는 데 도움이 될 것이기 때문입니다.

### 함수 타입과 서브타이핑

- 최근의 객체지향 언어들은 이름 없는 메서드를 정의할 수 있게 허용합니다. 이들은 다양한 언어에서 `익명 함수(anonymous function)`, `함수 리터럴(function literal)`, `람다 표현식(lambda expression)` 등의 다양한 이름으로 불립니다.
- 이름 없는 메서드를 정의하는 것을 허용하는 언어들은 객체의 타입뿐만 아니라 메서드의 타입을 정의 할 수 있게 허용합니다. 그리고 타입에서 정의한 시그니처를 준수하는 메서드들을 이 타입의 인스턴스로 간주합니다.
- 서브타입이 슈퍼타입을 치환할 수 있다는 것은 계약에 의한 설계에서 정의한 계약 규칙과 가변성 규칙을 준수한다는 것을 의미합니다.
- 진정한 서브타이핑 관계를 만들고 싶다면 서브타입에 더 강력한 사전조건이나 더 완화된 사후조건을 정의해서는 안 되며 슈퍼타입의 불변식을 유지하기 위해 항상 노력해야 합니다. 또한 서브타입에서 슈퍼 타입에서 정의하지 않은 예외를 던져서는 안 됩니다.
