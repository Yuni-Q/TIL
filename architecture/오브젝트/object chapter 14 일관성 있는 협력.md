# object chapter 14 일관성 있는 협력

- 객체는 협력을 위해 존재합니다. 협력은 객체가 존재하는 이유와 문맥을 제공합니다. 잘 설계된 애플리케이션은 이해하기 쉽고, 수정하기 용이하며, 재사용 가능한 협력의 모임입니다.
- 객체지향 설계의 목표는 적절한 책임을 수행하는 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것입니다.
- 객체들의 협력 구조가 서로 다른 경우에는 코드를 이해하기도 어렵고 코드 수정으로 인해 버그가 발생한 위험성도 높아집니다. 유사한 요구사항을 계속 추가해야 하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우에는 전체적인 설계의 일관성이 서서히 무너지게 됩니다.
- 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것입니다. 하지만 재사용은 공짜로 얻어지지 않습니다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 합니다. 일관성은 설계에 드는 비용을 감소시킵니다. 과거의 해결 방법을 반복적으로 사용해서 유사한 기능을 구현하는 데 드는 시간과 노력을 대폭 줄일 수 있기 때문입니다. 일관성 있는 설계가 주는 더 큰 이익은 코드가 이해하기 쉬워진다는 것입니다. 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알면 문제를 이해느 것만으로도 코드의 구조를 예상할 수 있게 됩니다.
- 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용합니다. 객체들의 협력이 전체적으로 일관성 있는 유사한 패턴을 따른다면 시스템을 이해하고 확장하기 위해 요구되는 정신적인 부담을 크게 줄일 수 있습니다. 지금 보고 있는 코드가 얼마 전에 봤던 코드와 유사하다는 사실을 아는 순간 새로운 코드가 직관적인 모습으로 다가오는 것을 느끼게 될 것입니다. 유사한 기능을 구현하기 위해 유사한 협력 방식을 따를 경우 코드를 이해힉 위해 필요한 것은 약간의 기억력과 적응력뿐입니다.
- 일관성 있는 협력 패턴을 적용하면 여러분의 코드가 이해하기 쉽고 직관적이며 유연해집니다.

## 01. 핸드폰 과금 시스템 변경하기

### 기본 정책 확장

### 고정요금 방식 구현하기

### 시간대별 방식 구현하기

### 요일별 방식 구현하기

### 구간별 방식 구현하기

- 비일관성은 두 가지 상황에서 발목을 잡습니다.
  - 하나는 새로운 구현을 추가해야 하는 상황입니다.
  - 또 다른 하나는 기존의 구현을 이해해야 하는 상황입니다.
  - 그 장애물이 문제인 이유는 개발자로서 우리가 수행하는 대부분의 활동이 코드를 추가하고 이해하는 일과 깊숙히 연관돼 있기 때문입니다.
- 유사한 기능은 유사한 방식으로 구현해야 합니다. 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것입니다.

#### 코드 재사용을 위한 상속은 해롭다

## 02. 설계에 일관성 부여하기

- 일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것입니다.
- 일관성 있는 설계를 위한 두 번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라는 것입니다. 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿입니다. 디자인 패턴을 학습하면 빠른 시간 안에 전문가의 경험을 흡수할 수 있습니다.
- 디자인 패턴이 반복적으로 적용할 수 있는 설계 구조를 제공한다고 하더라도 모든 경우에 적합한 패턴을 찾을 수 있는 것은 아닙니다. 따라서 협력을 일관성 있게 만들기 위해 다음과 같은 기본 지침을 따르는 것이 도움이 될 것입니다.
  - 변하는 개념을 변하지 않는 개념으로부터 분리합니다.
  - 변하는 개념을 캡슐화합니다.
  - 사실 이 두 가지 지침은 훌륭한 구조를 설계하기 위해 따라야 하는 기본적인 원칙이기도 합니다. 대부분의 원칙과 개념들은 변경의 캡슐화라는 목표를 향합니다.

### 조건 로직 대 객체 탐색

- 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것입니다. 다형성은 바로 이런 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법입니다.
- 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스로 분리해야 합니다. 클래스를 분리하기 위해 가장 중요한 기준은 변경의 이유와 주기입니다. 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야합니다. 간단하게 말해서 단일 책임 원칙을 따르도록 클래스를 분리해야 한다는 것입니다.
- 큰 메서드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 인스턴스들 사이의 협력 패턴에 일관성을 부여하기가 더 쉬워집니다. 유사한 행동을 수행하는 작은 클래스들이 자연스럽게 역할이라는 추상화로 묶이게 되고 역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문입니다.
- 훌륭한 추상화를 찾아 추상화에 의존하도록 만들어야 합니다. 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해줍니다. 따라서 선택하는 추상화의 품질이 캡슐화의 품질을 결정합니다.
- 타입을 캡슐화하고 낮은 의존성을 유지하기 위해서는 다양한 기법들이 필요합니다.
  - 인터페이스 설계 원칙들을 적용하면 구현을 효과적으로 캡슐화하는 코드를 구현하 수 있습니다.
  - 의존성 돤리 기법은 타입을 캡슐화하기 위해 낮은 결합도를 유지할 수 있는 방법을 잘 보여줍니다.
  - 타입을 캡슐화 하기 위해서가 아니라 코드 재사용을 위해 상속을 사용하고 있다면 주의사항을 살펴 보아야합니다.
  - 상속 대신 합성을 사용하는 것도 캡슐화를 보장할 수 있는 훌륭한 방법입니다.
  - 설계 원칙을 따르면 리스코프 치환 원칙을 준수하는 타입 계층을 구현하는 데 상속을 이용할 수 있습니다.
- 변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있습니다.
- 구성 요소를 캡슐화 하는 실행 지침은 객체지향의 핵심 덕목 중 하나입니다. 시스템을 책임을 캡슐화한 섬들로 분리하고 그 섬들 간의 결합도를 제한합니다.
  - 이 실행 지침이 드러나는 또 다른 주제가 패턴입니다. GOF에 의하면 인터페이스에 대해 설계해야 한다고 조언하는데, 이것은 결합도가 느슨해질 수 있도록 엔티티 사이의 관계가 추상적인 수준에서 정해져야 한다는 사실을 다르게 표현한 것입니다. 이 특성이 패턴들의 공통적인 경향이라는 것을 알게 될 것입니다. 패턴은 매우 빈버하게 요소들이 관계를 맺을 수 있는 대상을 추상적 기반 타입으로 제한합니다.

#### 일관성 있는 협력을 위한 지침 1

- 변하는 개념을 변하지 않는 개념으로부터 분리합니다.

#### 일관성 있는 협력을 위한 지침 2

- 변하는 개념을 캡슐화합니다.

### 캡슐화 다시 살펴보기

- 많은 사람들은 객체의 캡슐화에 관한 이야기를 들으면 반사적으로 `데이터 은닉(data hiding)`을 떠올립니다. 데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체의 내부의 구현을 숨기는 기법을 가리킵니다. 간단하게 말해서 클래스의 모든 인스턴스 변수는 private으로 선언해야 하고 오직 해당 클래스의 메서드만이 인스턴스 변수에 접근할 수 있어야 한다는 것입니다.
- 캡슐화는 데이터 은닉 이상입니다.
  - 설계에서 무엇이 변화될 수 있는지 고려합니다. 이 접근법은 재설계의 원인에 초점을 맞추는 것과 반대되는 것입니다. 설계에 변경을 강요하는 것이 무엇인지에 대해 고민하기보다는 재설계 없이 변경할 수 있는 것이 무엇인지 고려합니다. 여기서의 초점은 많은 디자인 패턴의 주제인 변화하는 개념을 캡슐화하는 것입니다.
- GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아닙니다. 소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것입니다.
- 캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것입니다. 객체를 구현한 개발자는 필요할 때 객체의 내부 구현을 수정하기를 원합니다. 객체와 협력하는 클라이언트 개발자는 객체의 인터페이스가 변하지 않기를 원합니다. 따라서 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 합니다.
- 다양한 종류의 캡슐화가 공존합니다.
  - 데이터 캡슐화 : 클래스는 내부에 관리하는 데이터를 캡슐화 합니다.
  - 매세드 캡슐화 : 클래스 내부 행동을 캡슐화 합니다.
  - 객체 캡슐화 : 객체와 객체 사이의 관계를 캡슐화합니다. 객체 캡슐화는 항상을 의미합니다.
  - 서브타입 캡슐화 : 서브타입의 종류를 캡슐화 합니다. 서브타입 캡슐화가 다형성의 기반 됩니다.
- 캡슐화란 단지 데이터 은닉을 의미하는 것이 아닙니다. 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종입니다. 일반적으로 데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용하고 객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용합니다.
- 변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것입니다. 서브타입 캡슐화는 인터페이스 상속을 사용하고, 객체 캡슐화는 합성을 사용합니다.

#### 변하는 부분을 분리해서 타입 계층을 만든다