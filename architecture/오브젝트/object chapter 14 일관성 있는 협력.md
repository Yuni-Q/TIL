# object chapter 14 일관성 있는 협력

- 객체는 협력을 위해 존재합니다. 협력은 객체가 존재하는 이유와 문맥을 제공합니다. 잘 설계된 애플리케이션은 이해하기 쉽고, 수정하기 용이하며, 재사용 가능한 협력의 모임입니다.
- 객체지향 설계의 목표는 적절한 책임을 수행하는 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것입니다.
- 객체들의 협력 구조가 서로 다른 경우에는 코드를 이해하기도 어렵고 코드 수정으로 인해 버그가 발생한 위험성도 높아집니다. 유사한 요구사항을 계속 추가해야 하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우에는 전체적인 설계의 일관성이 서서히 무너지게 됩니다.
- 객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것입니다. 하지만 재사용은 공짜로 얻어지지 않습니다. 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 합니다. 일관성은 설계에 드는 비용을 감소시킵니다. 과거의 해결 방법을 반복적으로 사용해서 유사한 기능을 구현하는 데 드는 시간과 노력을 대폭 줄일 수 있기 때문입니다. 일관성 있는 설계가 주는 더 큰 이익은 코드가 이해하기 쉬워진다는 것입니다. 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알면 문제를 이해느 것만으로도 코드의 구조를 예상할 수 있게 됩니다.
- 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용합니다. 객체들의 협력이 전체적으로 일관성 있는 유사한 패턴을 따른다면 시스템을 이해하고 확장하기 위해 요구되는 정신적인 부담을 크게 줄일 수 있습니다. 지금 보고 있는 코드가 얼마 전에 봤던 코드와 유사하다는 사실을 아는 순간 새로운 코드가 직관적인 모습으로 다가오는 것을 느끼게 될 것입니다. 유사한 기능을 구현하기 위해 유사한 협력 방식을 따를 경우 코드를 이해힉 위해 필요한 것은 약간의 기억력과 적응력뿐입니다.
- 일관성 있는 협력 패턴을 적용하면 여러분의 코드가 이해하기 쉽고 직관적이며 유연해집니다.

## 01. 핸드폰 과금 시스템 변경하기

### 기본 정책 확장

### 고정요금 방식 구현하기

### 시간대별 방식 구현하기

### 요일별 방식 구현하기

### 구간별 방식 구현하기

- 비일관성은 두 가지 상황에서 발목을 잡습니다.
  - 하나는 새로운 구현을 추가해야 하는 상황입니다.
  - 또 다른 하나는 기존의 구현을 이해해야 하는 상황입니다.
  - 그 장애물이 문제인 이유는 개발자로서 우리가 수행하는 대부분의 활동이 코드를 추가하고 이해하는 일과 깊숙히 연관돼 있기 때문입니다.
- 유사한 기능은 유사한 방식으로 구현해야 합니다. 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것입니다.

#### 코드 재사용을 위한 상속은 해롭다

## 02. 설계에 일관성 부여하기

- 일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것입니다.
- 일관성 있는 설계를 위한 두 번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라는 것입니다. 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿입니다. 디자인 패턴을 학습하면 빠른 시간 안에 전문가의 경험을 흡수할 수 있습니다.
- 디자인 패턴이 반복적으로 적용할 수 있는 설계 구조를 제공한다고 하더라도 모든 경우에 적합한 패턴을 찾을 수 있는 것은 아닙니다. 따라서 협력을 일관성 있게 만들기 위해 다음과 같은 기본 지침을 따르는 것이 도움이 될 것입니다.
  - 변하는 개념을 변하지 않는 개념으로부터 분리합니다.
  - 변하는 개념을 캡슐화합니다.
  - 사실 이 두 가지 지침은 훌륭한 구조를 설계하기 위해 따라야 하는 기본적인 원칙이기도 합니다. 대부분의 원칙과 개념들은 변경의 캡슐화라는 목표를 향합니다.

### 조건 로직 대 객체 탐색

- 객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것입니다. 다형성은 바로 이런 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법입니다.
- 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스로 분리해야 합니다. 클래스를 분리하기 위해 가장 중요한 기준은 변경의 이유와 주기입니다. 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야합니다. 간단하게 말해서 단일 책임 원칙을 따르도록 클래스를 분리해야 한다는 것입니다.
- 큰 메서드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 인스턴스들 사이의 협력 패턴에 일관성을 부여하기가 더 쉬워집니다. 유사한 행동을 수행하는 작은 클래스들이 자연스럽게 역할이라는 추상화로 묶이게 되고 역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문입니다.
- 훌륭한 추상화를 찾아 추상화에 의존하도록 만들어야 합니다. 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해줍니다. 따라서 선택하는 추상화의 품질이 캡슐화의 품질을 결정합니다.
- 타입을 캡슐화하고 낮은 의존성을 유지하기 위해서는 다양한 기법들이 필요합니다.
  - 인터페이스 설계 원칙들을 적용하면 구현을 효과적으로 캡슐화하는 코드를 구현하 수 있습니다.
  - 의존성 돤리 기법은 타입을 캡슐화하기 위해 낮은 결합도를 유지할 수 있는 방법을 잘 보여줍니다.
  - 타입을 캡슐화 하기 위해서가 아니라 코드 재사용을 위해 상속을 사용하고 있다면 주의사항을 살펴 보아야합니다.
  - 상속 대신 합성을 사용하는 것도 캡슐화를 보장할 수 있는 훌륭한 방법입니다.
  - 설계 원칙을 따르면 리스코프 치환 원칙을 준수하는 타입 계층을 구현하는 데 상속을 이용할 수 있습니다.
- 변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있습니다.
- 구성 요소를 캡슐화 하는 실행 지침은 객체지향의 핵심 덕목 중 하나입니다. 시스템을 책임을 캡슐화한 섬들로 분리하고 그 섬들 간의 결합도를 제한합니다.
  - 이 실행 지침이 드러나는 또 다른 주제가 패턴입니다. GOF에 의하면 인터페이스에 대해 설계해야 한다고 조언하는데, 이것은 결합도가 느슨해질 수 있도록 엔티티 사이의 관계가 추상적인 수준에서 정해져야 한다는 사실을 다르게 표현한 것입니다. 이 특성이 패턴들의 공통적인 경향이라는 것을 알게 될 것입니다. 패턴은 매우 빈버하게 요소들이 관계를 맺을 수 있는 대상을 추상적 기반 타입으로 제한합니다.

#### 일관성 있는 협력을 위한 지침 1

- 변하는 개념을 변하지 않는 개념으로부터 분리합니다.

#### 일관성 있는 협력을 위한 지침 2

- 변하는 개념을 캡슐화합니다.

### 캡슐화 다시 살펴보기

- 많은 사람들은 객체의 캡슐화에 관한 이야기를 들으면 반사적으로 `데이터 은닉(data hiding)`을 떠올립니다. 데이터 은닉이란 오직 외부에 공개된 메서드를 통해서만 객체의 내부에 접근할 수 있게 제한함으로써 객체의 내부의 구현을 숨기는 기법을 가리킵니다. 간단하게 말해서 클래스의 모든 인스턴스 변수는 private으로 선언해야 하고 오직 해당 클래스의 메서드만이 인스턴스 변수에 접근할 수 있어야 한다는 것입니다.
- 캡슐화는 데이터 은닉 이상입니다.
  - 설계에서 무엇이 변화될 수 있는지 고려합니다. 이 접근법은 재설계의 원인에 초점을 맞추는 것과 반대되는 것입니다. 설계에 변경을 강요하는 것이 무엇인지에 대해 고민하기보다는 재설계 없이 변경할 수 있는 것이 무엇인지 고려합니다. 여기서의 초점은 많은 디자인 패턴의 주제인 변화하는 개념을 캡슐화하는 것입니다.
- GOF의 조언에 따르면 캡슐화란 단순히 데이터를 감추는 것이 아닙니다. 소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것입니다.
- 캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것입니다. 객체를 구현한 개발자는 필요할 때 객체의 내부 구현을 수정하기를 원합니다. 객체와 협력하는 클라이언트 개발자는 객체의 인터페이스가 변하지 않기를 원합니다. 따라서 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 합니다.
- 다양한 종류의 캡슐화가 공존합니다.
  - 데이터 캡슐화 : 클래스는 내부에 관리하는 데이터를 캡슐화 합니다.
  - 매세드 캡슐화 : 클래스 내부 행동을 캡슐화 합니다.
  - 객체 캡슐화 : 객체와 객체 사이의 관계를 캡슐화합니다. 객체 캡슐화는 항상을 의미합니다.
  - 서브타입 캡슐화 : 서브타입의 종류를 캡슐화 합니다. 서브타입 캡슐화가 다형성의 기반 됩니다.
- 캡슐화란 단지 데이터 은닉을 의미하는 것이 아닙니다. 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종입니다. 일반적으로 데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용하고 객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용합니다.
- 변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것입니다. 서브타입 캡슐화는 인터페이스 상속을 사용하고, 객체 캡슐화는 합성을 사용합니다.

#### 변하는 부분을 분리해서 타입 계층을 만든다

- 변하지 않는 부분으로부터 변하는 부분을 분리합니다. 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화한 후 변하는 부분들이 이 추상 클래스나 인터페이스를 상속받게 만듭니다. 변하는 부분은 변하지 않는 부분의 서브타입이 됩니다.

#### 변하지 않는 부분의 일부로 타입 계층을 합성한다

- 앞에서 구현한 타입 계층을 변하지 않는 부분에 합성합니다. 변하지 않는 부분에서는 변경되는 구체적인 사항에 결합돼서는 안됩니다. 의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만듭니다. 이제 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서는 알지 못할 것입니다. 변경이 캡슐화된 것입니다.

## 03. 일관성 있는 기본 정책 구현하기

### 변경 분리하기

- 일관성 있는 협력을 만들기 위한 첫 번째 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것입니다.
- 공통점은 변하지 않는 부분입니다. 차이점은 변하는 부분입니다. 우리의 목적은 변하지 않는 것과 변하는 것을 분리하는 것이라는 점을 기억해야 합니다. 따라서 변하지 않는 '규칙'으로부터 변하는 '적용조건'을 분리해야 합니다.

### 변경 캡슐화하기

- 협력을 일관성 있게 만들기 위해서는 변경을 캡슐화해서 파급효과를 줄여야 합니다. 변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것입니다. 물론 변하는 부분의 공통점을 추상화하는 것도 잊어서는 안 됩니다. 이제 변하지 않는 부분이 오직 이 추상화에만 의존하도록 관계를 제한하면 변경을 캡슐화할 수 있게 됩니다.
- 변하지 않는 것은 '규칙'입니다. 변하는 것은 '적용조건'입니다. 따라서 '규칙'으로부터 '적용조건'을 분리해서 추상화한 후 추상화의 서브타입으로 만듭니다. 이것이 서브타입 캡슐화입니다. 그 후에 규칙이 적용조건을 표현하는 추상화를 합성 관계로 연결합니다. 이것이 객체 캡슐화입니다.

### 협력 패턴 설계하기

- 변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있습니다. 추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 됩니다. 다시 말해서 재사용 가능한 협력 패턴이 선명하게 드러나는 것입니다.

### 추상화 수준에서 협력 패턴 구현하기

- 변하는 것과 변하지 않는 것을 분리하고 변하는 것을 캡슐화한 코드는 오로지 변하지 않는 것과 추상화에 대한 의존성만으로도 전체적인 협력을 구현할 수 있습니다. 변하는 것은 추상화 뒤에 캡슐화되어 숨겨져 있기 때문에 전체적인 협력의 구조에 영향을 미치지 않습니다.
- 변경을 캡슐화해서 일관성 잇게 만들면 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에 변하지 않는 부분을 재사용할수 있습니다. 그리고 새로운 기능을 추가힉 위해 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있습니다. 따라서 코드의 재사용성이 향상되고 테스트해야 하는 코드의 양이 감소합니다. 기능을 추가할 때 따라야 하는 구조를 강제할 수 있기 때문에 기능을 추가하거나 변경할 때도 설계의 일관성이 무너지지 않습니다.
- 기본 정책을 추가하기 위해 규칙을 지키는 것보다 어기는 것이 더 어렵다는 점을 주목해야 합니다. 일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 때문에 정해진 구조를 우회하기 어렵게 만듭니다. 개발자는 코드의 형태로 주어진 제약 안에 머물러야 하지만 작은 문제에 집중할 수 있는 자유를 얻습니다. 그리고 이 작은 문제에 대한 해결책을 전체 문맥에 연결함으로써 협력을 확장하고 구체화할 수 있습니다.
- 변경 전에 설계는 전체적으로 일관성이 떨어지기 때문에 코드에 대해 가지고 있던 기존의 지식이 유사한 기능을 이해하는 데 아무런 도움도 되지 않습니다. 오히려 기존 코드에 대한 선입견이 이해에 걸림돌로 작용합니다.
- 협력을 일관성 있게 만들면 변하지 않는 부분은 모든 기본 정책에서 공통적이라는 것을 기억해야 합니다. 이 공통 코드의 구조와 협력 패턴은 모든 기본 정책에 걸쳐 동일하기 때문에 코드를 한 번 이해하면 이 지식을 다른 코드를 이해하는 데 그대로 적용할 수 있습니다.
- 일단 일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있습니다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 `개념적 무결성(Conceptual Integrity)`을 유지할 수 있는 가장 효과적인 방법입니다. 개념적 무결성을 일관성과 동일한 뜻으로 간주해도 무방합니다. 시스템이 일관성 있는 몇 개의 협력 패턴으로 구성된다면 시스템을 이해하고, 수정하고, 확장하는 데 필요한 노력과 시간을 아낄 구 있습니다. 따라서 협력을 설계하고 있으면 항상 기존의 협력 패턴을 따를 수는 없는지 고민합니다. 그것이 시스템의 개념적 무결성을 지키는 최선의 방법일 것입니다.

### 구체적인 협력 구현하기

#### 시간대별 정책

#### 요일별 정책

#### 구간별 정책

### 협력 패턴에 맞추기

- 가급적 기존의 협력 패턴에 맞추는 것이 가장 좋은 방법입니다. 비록 설계를 약간 비트는 것이 조금은 이상한 구조를 낳더라도 전체적으로 일관성을 유지할 수 있는 설계를 선택하는 것이 현명합니다.

#### 지속적으로 개선하라

- 처음에는 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르면서 새로운 요구사항이 추가되는 과정에서 일관성의 벽에 조금씩 금이 가는 경우를 자주 보게 됩니다. 협력을 설계하는 초기 단계에서 모든 요구사항을 미리 예상할 수 없기 때문에 이것은 잘못이 아니면 꽤나 자연스러운 현상입니다. 오히려 새로운 요구사항을 수용할 수 있는 패턴을 향해 설계를 진화시킬 수 있는 좋은 신호로 받아들여야 합니다.
- 협력은 고정된 것이 아닙니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링합니다. 요구사항의 변경에 따라 협력 역시 지속적으로 개선해야 합니다. 중요한 것은 현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지입니다.

### 패턴을 찾아라

- 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것입니다. 변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정하고 이렇게 결정된 협력이 코드의 구조를 결정합니다. 따라서 훌륭한 설계자가 되는 첫걸음은 변경의 방향을 파악할 수 있는 날카로운 감각을 기르는 것입니다. 그리고 이 변경에 탄력적으로 대응할 수 있는 다양한 캡슐화 방법과 설계 방법을 익히는 것 역시 중요합니다.
- 애플리케이션에서 유사한 기능에 대한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화 할 수 있는 적절한 추상화를 찾은 후, 이 추상화에 변하지 않는 공통적인 책임을 할당합니다. 현재의 구조가 변경을 캡슐화하기에 적합하지 않다면 코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩터링합니다. 변경을 수용할 수 있는 적절한 역할과 책임을 찾다 보면 협력의 일관성이 서서히 윤곽을 드러낼 것입니다.
- 협력을 일관성 있게 만드는 과정은 유사한 기능을 구현하기 위해 반복적으로 적용할 수 있는 협력의 구조를 찾아가는 긴 여정입니다. 따라서 협력을 일관성 있게 만드는 것은 유사한 변경을 수용할 수 있는 협력 패턴을 발견하는 것과 동일합니다.
- 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어집니다. 객체, 역할, 책임은 계속 진화해 나가는 것입니다. 협력자들 간에 부하를 좀 더 균형 있게 배분하는 벙법을 새로 만들어내면 나눠줄 책임이 바뀌게 됩니다. 만약 객체들이 서로 통신하는 방법을 개선해냈다면 이들 간의 상호작용은 재정의되야 합니다. 이 같은 과정을 거치면서 객체들이 자주 통신하는 경로는 더욱 효율적이게 되고, 주어진 작업을 수행하는 표준 방안이 정착됩니다. 협력 패턴이 드러나는 것입니다.
- 협력 패턴과 관련해서 업근할 가치가 있는 두 가지 개념이 있습니다.
  - 하나는 패턴 입니다.
  - 다른 하나는 프레임워크 입니다.
