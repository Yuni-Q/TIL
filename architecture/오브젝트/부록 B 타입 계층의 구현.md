# 부록 B 타입 계층의 구현

- 타입은 다양한 방법으로 구현할 수 있습니다. 사실 타입의 개념을 이해하는 데 가장 큰 걸림돌은 타입을 구현하는 방법이 다양하다는 점입니다. 심지어 타입을 구현할 수 있는 독자적인 방법을 제공하는 언어도 있습니다.
- 타입 계층은 타입보다 상황이 더 복잡한데 다양한 방식으로 구현된 타입들을 하나의 타입 계층 안에 조합할 수 있기 때문입니다.
- 타입 게층은 동일한 메시지에 대한 행동 호환성을 전제로 하기 때문에 여기서 언급하는 모든 방법은 타입 계층을 구현하는 방법인 동시에 다형성을 구현하는 방법이기도 합니다. 이번 장에서 설명하는 방법을 자세히 살펴보면 공통적으로 슈퍼타입에 대해 전송한 메시지를 서브타입별로 다르게 처리할 수 있는 방법을 제공한다는 사실을 알 수 있습니다.
- 올바른 타입 계층이 되기 위해서는 서브타입이 슈퍼타입을 대체할 수 있도록 리스코프 치환 원칙을 준수해야 합니다. 리스코프 치환 원칙은 특정한 구현 방법에 의해 보장될 수 있기 때문에 클라이언트 관점에서 타입을 동일하게 다룰 수 있도록 의미적으로 행동 호환성을 보장하는 것은 전적으로 우리의 책임입니다. 뒤에서 다루는 다양한 구현 방법을 이용할 때 타입 사이에 리스코프 치환 원칙을 준수하도록 만드는 책임은 우리 자신에게 있다는 사실을 기억해야 합니다.

### 클래스를 이용한 타입 계층 구현

- 클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 타입이라는 말에서 반사적으로 클래스라는 단어를 떠올립니다. 타입은 객체의 퍼블릭 인터페이스를 가리키기 떄문에 결과적으로 클래스는 객체의 타입과 구현을 동시에 정의하는 것과 같습니다. 이것이 객체지향 언어에서 클래스를 `사용자 정의 타입(user-defined data type)`이라고 부르는 이유입니다.
- 타입을 구현할 수 있는 다양한 방법이 존재하는 순간부터는 클래스와 타입은 갈라지기 시작합니다. 퍼블릭 인터페이스를 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 간단한 방법은 상속을 이용하는 것입니다. 상속을 이용하면 자식 클래스가 부모 클래스의 구현뿐만 아니라 퍼블릭 인터페이스도 물려받을 수 있기 때문에 타입 계층을 쉽게 구현할 수 있습니다. 하지만 상속은 자식 클래스를 부모 클래스의 구현에 강하게 결합시키기 때문에 구체 클래스를 상속받는 것은 피해야 합니다. 가급적 추상 클래스를 상속 받거나 인터페이스를 구현하는 방법을 사용해야 합니다.
- 클래스는 타입을 구현할 수 있는 다양한 방법 중 하나일 뿐입ㄴ디ㅏ. 비교적 최근에 발표된 객체지향 언어들은 클래스를 사용하지 않고도 타입을 구현할 수 있는 방법을 제공합니다. 대표적인 것이 자바와 C#의 인터페이스 입니다.

### 인터페이스를 이용한 타입 계층 구현

- 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법은 클래스가 아닌 인터페이스를 사용하는 것입니다.
- 인터페이스와 클래스를 함께 조합하면 다중 상속의 딜레마에 빠지지 않을 수 있고 단일 상속 계층으로 인한 결합도 문제도 피할 수 있습니다.
- 여러 클래스가 동일한 타입을 구현할 수 있습니다.
- 하나의 클래스가 여러 타입을 구현할 수 있습니다.
- 인터페이스를 이용해 타입을 정의하고 클래스를 이용해 객체를 구현하면 클래스 상속을 사용하지 않고도 타입 계층을 구현할 수 있습니다.
- 클래스와 타입 간의 차이를 이해하는 것은 중요합니다. 객체의 클래스는 객체의 구현을 정의합니다. 클래스는 객체의 내부 오퍼레이션 구현 방법을 정의하는 것이고 객체의 타입은 인터페이스만을 정의하는 것으로 객체가 반응할 수 있는 오퍼레이션의 집합을 정의합니다. 하나의 객체가 여러 타입을 가질 수 있고 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있습니다. 즉, 객체의 구현은 다를지라도 인터페이스는 같을 수 있다는 의미입니다.
- 클래스와 타입 간에는 밀접한 관련이 있습니다. 클래스도 객체가 만족할 수 있는 오퍼레이션을 정의하고 있으므로 타입을 정의하는 것이기도 합니다. 그래서 객체가 클래스의 인터페이스라고 말할 때 객체는 클래스가 정의하고 있는 인터페이스를 지원한다는 뜻을 내포합니다.
- 타입은 동일한 퍼블릭 인터페이스를 가진 객체들의 범주입니다. 클래스는 타입에 속하는 객체들을 구현하기 위한 구현 메커니즘입니다. 객체지향에서 중요한 것은 협력 안에서 객체가 제공하는 행동이라는 사실을 기억해야 합니다. 따라서 중요한 것은 클래스 자체가 아니라 타입입니다. 타입이 식별된 후에 타입에 속하는 객체를 구현하기 위해 클래스를 사용하는 것입니다.
- 중요한 것은 객체가 외부에 제공하는 행동, 즉 타입을 중심으로 객체들의 계층을 설계하는 것입니다. 타입이 아니라 클래스를 강조하면 객체의 퍼블릭 인터페이스가 아닌 세부 구현에 결합된 협력 관계를 낳게 됩니다.

### 추상 클래스를 이용한 타입 계층 구현

- 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법도 있습니다. 바로 `추상 클래스`를 이용하는 방법입니다.
- 구체 클래스로 타입을 정의해서 상속받는 방법과 추상 클래스로 타입을 정의해서 상속받는 방법의 차이점은 추상화 정도와 상속을 사용하는 의도입니다.
  - 첫 번째로 의존하는 대상의 추상화 정도가 다릅니다. 구체적인 메서드가 추상적인 메서드에 의존하기 때문에 의존성 역전 원칙을 따른다고 할 수 있습니다. 결과적으로 이 설계는 유연한 동시에 변화에 안정적입니다. 한 가지 조언은 모든 구체 클래스의 부모 클래스를 항상 추상 클래스로 만들기 위해 노력해야 합니다. 의존하는 대상이 더 추상적일수록 결합도는 낮아지고 결합도가 낮아질수록 변경으로 인한 영향도는 줄어듭니다.
  - 두 번째 차이점은 상속을 사용하는 의도입니다. 상속을 염두하고 설계 되었는지의 차이가 있습니다.

### 추상 클래스와 인터페이스 결합하기

- 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에는 추상 클래스를 이용해 코드 중복을 방지하는 것입니다. 이런 형태로 추상 클래스를 사용하는 방식을 `골격 구현 추상 클래스(skeletal implementation abstract class)`라고 부릅니다.
- 인터페이스가 메서드 구현 부분(메서드 몸체)을 포함하지는 않지만 인터페이스를 사용해 타입을 정의한다고해서 프로그래머가 구현을 하는 데 도움을 못 주는 것은 아닙니다. 외부에 공개한 각각의 중요한 인터페이스와 연관시킨 골격 구현 추상 클래스를 제공함으로써 인터페이스와 추상 클래스의 장점을 결합할 수 있습니다. 그렇게 함으로써 인터페이스는 여전히 타입을 정의하지만 골격 구현 클래스는 그것을 구현하는 모든 일을 맡습니다.
- 인터페이스와 추상 클래스를 함께 사용하는 방법은 추상 클래스만 사용하는 방법에 비해 두 가지 장점이 있습니다.
  - 다양한 구현 방법이 필요한 경우 새로운 추상 클래스를 추가해서 쉽게 해결할 수 있습니다.
  - 이미 부모 클래스가 존재하는 클래스라고 하더라도 인터페이스를 추가함으로써 새로운 타입으로 쉽게 확장할 수 있습니다.
  - 설계가 상속 계층에 얽매이지 않는 타입 계층을 요구한다면 인터페이스로 타입을 정의합니다. 추상 클래스로 기본 구현을 제공해서 중복 코드를 제거합니다. 하지만 이런 복잡성이 필요하지 않다면 타입을 정의하기 위해 인터페이스나 추상 클래스 둘 중 하나만 사용합니다. 타입의 구현 방법이 단 한 가지이거나 단일 상속 계층만으로도 타입 계층을 구현하는 데 무리가 없다면 클래스나 추상 클래스를 이용해 타입을 정의하는 것이 더 좋습니다. 그 외의 상황이라면 인터페이스를 이용하는 것을 고려합니다.

### 덕 타이핑 사용하기

- 덕 타이핑은 주로 동적 타입 언어에서 사용하는 방법으로서 `덕 테스트(duck test)`를 프로그래밍 언어에 적용한 것입니다.
  - 덕 테스트는 어떤 대상의 '행동'이 오리와 같다면 그것을 오리하는 타입으로 취급해도 무방하다는 것입닌다. 다시 말해 객체가 어떤 인터페이스에 정의된 행동을 수행할 수 있다면 그 객체를 해당 타입으로 분류해도 문제가 없습니다.
- 동적 타입 언어에서는 명시적으로 동일한 클래스를 상속받거나 동일한 인터페이스를 구현하지 않더라도 시그니처가 동일한 메서드를 가진 클래스는 같은 타입으로 취급할 수 있습니다.
- 덕 타이핑은 타입이 행동에 대한 것이라는 사실을 강조합니다. 두 객체가 동일하게 행동한다면 내부 구현이 어떤 방식이든 상관없습니다. 타입 관점에서 두 객체는 동일한 타입인 것입니다.
- 인터페이스가 클래스보다 더 유연한 설계를 가능하게 해주는 이유는 클래스가 정의하는 구현이라는 컨텍스트에 독립적인 코드를 적상할 수 있게 해주기 때문입니다. 덕 타이핑은 여기서 한 걸음 더 나아갑니다. 단지 메서드의 시그니처만 동일하면 명시적인 타입 선언이라는 컨텍스트를 제거할 수 있습니다. 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체합니다. 결과적으로 코드는 낮은 결합도를 유지하고 변경에 유연하게 대응할 수 있습니다.
- 덕 타이핑을 사용하면 메시지 수준으로 결합도를 낮출 수 있기 때문에 유연한 설계를 얻을 수 있습니다. 하지만 덕 타이핑을 사용하면 컴파일 시점에 발견할 수 있는 오류를 실행 시점으로 미루게 되기 때문에 설꼐의 유연성을 얻는 대신 코드의 안정성을 약화시킬 수 있다는 점에 주의해야 합니다.

### 믹스인과 타입 계층

- `믹스인(mixin)`은 객체를 생성할 때 코드 일부를 섞어 넣을 수 있도록 만드렁진 일종의 추상 서브 클래스입니다. 언어마다 구현 방법에 차이는 있지만 믹스인을 사용하는 목적은 다양한 객체 구현 안에서 동일한 '행동'을 중복 코드 없이 재사용할 수 있게 만드는 것입니다.
- 믹스인을 통해 코드를 재사용하는 객체들은 동일한 행동을 공유하게 됩니다. 다시 말해 공통의 행동이 믹스인된 객체들은 동일한 메시지를 수신할 수 있는 퍼블릭 인터페이스를 공유하게 됩니다. 타입은 퍼블릭 인터페이스와 관련이 있기 때문에 대부분의 믹스인을 구현하는 기법들은 타입을 정의하는 것으로 볼 수 있습니다.

### 정리

- 타입을 정의하는 기준은 객체가 외부에 제공하는 퍼블릭 인터페이스이기 때문에 실제로 타입의 개념을 코드로 옮길 수 있는 다양한 방법이 존재하며 동시에 타입의 구현 방법만큼이나 다양한 방식으로 타입 계층을 구현할 수 있습니다.
- 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 구현할 때 리스코프 치환 원칙을 준수해야 합니다.
