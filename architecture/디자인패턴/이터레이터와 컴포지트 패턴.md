# 이터레이터 패턴
- 이터레이터 패턴은 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공해 줍니다.

## 단일 역할 원칙
- 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.

#  컴포지트 패턴
- 컴포지트 패턴을 이용하면 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있습니다. 이 패턴을 이용하면 클라이언트에서 개별 객체와 다르 객체들로 구성된 복합 객체(composite)를 똑같은 방법으로 다룰 수 있습니다.
- 단일 역할 원칙을 깨면서 대신에 투명성을 확보하기 위한 패턴이라고 할 수 있습니다.
  - 투명성(transparency)는 Component 인터페이스에 자식들을 관리하기 위한 기능과 잎으로써의 기능을 전부 집어넣음으러써 클라이언트에서 복합 객체와 잎 노드를 똑같은 방식으로 처리할 수 있도록 할 수 있습니다.
- 가장 큰 장점은 클라이언트를 단순화시킬 수 있다는 점입니다. 클라이언트들은 복합 객체를 사용하고 있는지 잎 객체를 사용하고 있는지에 대해서 신경 쓰지 않아도 됩니다. 올바른 객체에 대해서 올바른 메소드를 호출하고 있는지 확인하기 위해 지저분하게 여기저기에 if문을 쓰지 않아도 됩니다. 그리고 메소드 하나만 호출하면 전체 구조에 대해서 반복해서 작업을 처리할 수 있는 경우도 자주 있습니다.

## 디자인 도구 상자 안에 들어가야 할 도구들

### 객체 지향 원칙
- 어떤 클래스가 바뀌게 되는 이유는 한가지 뿐이어야만 한다.

### 객체 지향 패턴
- 이터레이터 패턴 : 컬렉션을 표현하는 방법을 노출시키지 않으면서도 집합체 내의 있느 모든 객체들에 하나씩 접근하는 방법을 제공합니다.
- 컴포지트 패턴 : 객체들을 트리 구조로 구성하여 부분-전체 계층구조를 구현합니다. 컴포지트 패턴을 이용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다루도록 할 수 있습니다.

### 핵심정리
- 반복자를 이용하면 내부 구조를 드러내지 않으면서도 클라이언트로부터 컬렉션 안에 들어있는 모든 원소들에 접근하도록 할 수 있습니다.
- 이터레이터 패턴을 이용하면 집합체에 대한 반복작업을 별도의 객체로 캡슐화할 수 있습니다.
- 이터레이터 패턴을 이용하면 컬렉션에 있는 모든 데이터에 대해서 반복작업을 하는 역할을 컬렉션에서 분리시킬 수 있습니다.
- 이터레이터 패턴을 쓰면 다양한 집합체에 들어있는 객체에 대한 반복작업들에 대해 똑같은 인터페이스를 적용할 수 있기 때문에, 집합체에 있는 객체를 활용하는 코드를 만들 때 다형성을 활용할 수 있습니다.
- 한 클래스에는 될 수 있으면 한 가지 역할만 부여하는 것이 좋습니다.
- 컴포지트 패턴에서는 개별 객체와 복합 객체를 모두 담아둘 수 있는 구조를 제공합니다.
- 컴포지트 패턴을 이용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있습니다.
- 복합 구조에 들어있는 것을 구성요소라고 부릅니다. 구성요소에는 복합 객체와 잎 노드가 있습니다.
- 컴포지트 패턴을 적용할 때는 여러 가지 장단점을 고려해야 합니다. 상황에 따라 투명성과 안정성 사이에서 적절한 평형점을 찾아야 합니다.
