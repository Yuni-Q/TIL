# 데코레이션패턴
- OCP(Open-Closed Principle)는 가장 중요한 디자인 원칙 가운데 하나입니다.
- 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
- 모순된 것 같아 보이지만, 직접 코드를 수정하지 않고도 코드를 확장할 수 있게 해 주는 기법들이 있습니다.
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 합니다. 무조건 OCP를 적용하는 것은 시간 낭비가 될 수도 있고, 괜히 쓸 데 없는 일을 하는 것일 수도 있습니다. 결과적으로 불필요하게 복잡하고 이해하기 힘든 코드만 만들게 되는 부작용이 있을 수도 있으니 주의해야 합니다.
- 데코레이터의 수퍼클래스는 자신이 장식하고 있는 객체의 수퍼클래스와 같습니다.
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있습니다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 수퍼클래스를 가지고 있기 때문에 원래 객체(싸여져 있는 객체)가 들어갈 자리에 데코레이터 객체를 집어넣어도 상관 없습니다.
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 것 외에 원라는 추가적인 작업을 수행할 수 있습니다.
- 객체는 언제든지 감쌀 수 있기 때문에 실행중에 필요한 데코레이터를 마음대로 적용할 수 있습니다.
- 데코레이터 패턴(Decorator Pattern)에서는 개체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

## 단점
- 디자인을 유연하게 만드는 재주가 뛰어나지만 일을 하다 보면 자잘한 클래스들이 엄청나게 추가되는 경우가 종종 있습니다. 그러다보면 남들이 봤을 때 이해하기 힘든 디자인이 만들어지곤 합니다.
- 특정 형식에 의존하는 클라이언트 코드를 가지고 와서는 제대로 생각해보지 않고 데코레이터 패턴을 적용하는 사람이 많다. 하지만 특정 형식에 의존하는 코드에 데코레이터를 그냥 적용하면 모든 게 엉망이 되어 버리죠.
- 데코레이터를 도입하면 구성 요소를 초기화하는 데 필요한 코드가 훨씬 복잡해진다는 단점이 있거든요. 데코레이터를 쓰면 구성 요소 인스턴스만 만든다고 해서 일이 끝나는 게 아니죠. 꽤 많은 데코레이터로 감싸야 하는 경우가 종종 있으니까요.

### 해결책
- 팩토리와 빌더가 도움을 줄 수 있다.


## 장점
- OCP에 충실하면서도 유연한 디자인을 만들어낼 수 있다.

## 디자인 도구상자 안에 들어가야 할 도구들

### 객체지향 원칙
- 클래스는 확장에 대해서는 열려 있지만 변경에 대해서는 닫혀 있어야 한다(OCP)

### 데코레이터 패턴
- 객체에 추가 요소를 동적을 더할 수 있습니다. 데코레이터를 사용하면 서브 클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있습니다.

### 핵심정리
- 상속을 통해 확장을 할 수도 있지만, 디자인의 유연성 면에서 보면 별로 좋지 않습니다.
- 기존 코드를 수정하지 않고도 행동을 확장하는 방법이 필요합니다.
- 구성과 위임을 통해서 실행중에 새로운 행동을 추가할 수 있습니다.
- 상속 대신 데코레이터 패턴을 통해서 행동을 확장할 수 있습니다.
- 데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터들을 사용합니다.
- 데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영합니다(상속 또는 인터페이스 구현을 통해서 자신이 감쌀 클래스와 같은 형식을 가지게 됩니다)
- 데코레이터에서는 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장합니다.
- 구성요소를 감싸는 데코레이터의 개수에는 제한이 없습니다.
- 구성요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없습니다. 클라이언트에서 구성 요소의 구체적인 형식에 의존하게 되는 경우는 예외입니다.
- 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해질 수도 있습니다.
# Link as
```jsx
import Link from 'next/link';

export default props => (
  <Link href={`/post?title=${props.title}`} as={`/post/${props.title}`} >
    <a>{props.title}</a>
  </Link>
);
```

```javascript
server.get("post/:title", (req, res) => {
  const actualPage = "/post"
  const queryParams = { title: req.params.title };
  app.render(req, res, actualPage, queryParams);
});
```