# 기타 패턴

## 브리지(Bridge) 패턴

- 구현 분만 아니라 추상화된 부분까지 변경시켜야 하는 경우에는 브리지 패턴을 쓰면 됩니다.
- 브리지 패턴을 이용하면 추상화된 부분과 추상 클래스 / 인터페이스를 구현한 클래스를 서로 다른 클래스 계층구조에 집어넣음으로써 그 둘을 모두 변경시킬 수 있습니다.

### 브리지의 장점

- 구현을 인터에피스에 완전히 결합시키지 않았기 때문에 구현과 추상화된 부분을 분리시킬 수 있습니다.
- 추상화된 부분과 실제 구현 부분을 독립적으로 확장 할 수 있습니다.
- 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트 쪽에서 영향을 끼치지 않습니다.

## 브리지 활용법 및 단점

- 여러 플랫폼에서 사용해야 할 그래픽스 및 윈도우 처리 시스템에서 유용하게 쓰입니다.
- 인터페이스와 실제 구현부를 서로 다른 방식으로 변경해야 하는 경우에 유용하게 쓰입니다.
- 디자인이 복잡해진다는 단점이 있습니다.

## 빌더(Builder) 패턴

- 제품을 여러 단계로 나눠서 만들 수 있도록 제품 생산 단계들을 캡슐화하고 싶다면 빌더 패턴을 사용하면 됩니다.

### 빌더의 장점

- 복합 객체가 생성되는 과정으 캡슐화 합니다.
- 여러 단계와 다양한 절차를 통해서 객체를 만들 수 있습니다(팩토리 패턴에서는 한 단계에서 모든 걸처리해야 하죠)
- 제품의 내부 구조를 클라이언트로부터 보호할 수 있습니다.
- 클라이언트에서는 추상 인터페이스만 볼 수 있기 때문에 제품을 구현한 코드를 쉽게 바꿀 수 있습니다.

### 빌더 활용법 및 단점

- 복합 객체 구조를 구축하기 위한 용도로 많이 쓰입니다.
- 팩토리를 사용하는 경우에 비해 객체를 만들기 위해서 클라이언트에 대해 더 많이 알아야 합니다.

## 역할 사슬(Chain of Responsibility) 패턴

- 한 요청을 두 개 이상의 객체에서 처리하고 싶다면 역할 사슬 패턴을 사용하면 됩니다.

### 역할 사슬의 장점

- 요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있습니다.
- 객체에서는 사슬의 구조를 몰라도 되고 그 사슬에 들어 있는 객체에 대한 직접적인 레퍼런스를 가질 필요도 없기 때문에 객체를 단순하게 만들 수 있습니다.
- 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 여할을 동적으로 추가/제거할 수 있습니다.

### 역할 사슬 사용법 및 단점

- 윈도우 시스템에서 마우스 클릭이나 키보드 이벤트를 처리 할 때 흔하게 쓰입니다.
- 요청이 반드시 수행된다는 보장이 없다는 단점이 있습니다. 사슬 끝까지 갔는데도 아무 객체에서도 처리 해주이 않을 수 있죠(사실 이런 특성이 잠점이 될 수도 있긴 합니다)
- 실행시에 과정을 살펴보거나 디버깅하기가 힘들 수 있다는 단점이 있습니다.

## 플라이웨이트(Flyweight) 패턴

- 어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 '가상 인스턴스'를 제공하고 싶다면 플라이웨이트 패턴을 사용하면 됩니다.

### 플라이웨이트 패턴의 장점

- 실행시에 객체 인스턴스의 개수를 줄여서 메모리를 절약할 수 있습니다.
- 여러 '가상' 객체의 상태를 한 곳에 집중시켜놓을 수 있습니다.

### 플라이웨이트 패턴 사용법 및 단점

- 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어할 수 있는 경우에 유용하게 쓰입니다.
- 일단 이 패턴을 써서 구현해놓고 나면 특정 인스턴스만 다른 인스턴스와 다른 식으로 행동하도록 하는 것이 불가능하다는 단점이 있습니다.

## 인터프리터(Interpreter) 패턴

- 어떤 언어에 대한 인터프리터를 만들 때는 인터프리터 패턴을 사용하면 됩니다.

### 인터프리터 패턴의 장점

- 각 문법 규칙을 클래스로 표현하기 때문에 언어를 쉽게 구현할 수 있습니다.
- 문법이 클래스에 의해 표현되기 때문에 언어를 쉽게 변경하거나 확장할 수 있습니다.
- 클래스 구조에 메소드만 추가하면 프로그램을 해석하는 기본 기능 외에 예쁘게 출력하는 기능이라든가, 더 나은 프로그램 확인 기능 같은 새로운 기능을 추가할 수 있습니다.

### 인터프리터 활용법 및 단점

- 간단한 언어를 구현할 때 인터프리터 패턴이 유용하게 쓰입니다.
- 문법이 간단하고 효율보다는 단순하게 만드는 것이 더 중요한 경우에 유용합니다.
- 스크립트 언어 및 프로그래밍 언어에서 모두 쓸 수 있습니다.
- 문법 규칙의 개수가 많아지면 아주 복잡해 진다는 단점이 있습니다. 그런 경우에는 파서 / 컴파일러 생성기를 쓰는 것이 낫습니다.

## 미디에이터(Mediator) 패턴

- 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키고자 하는 경우에는 미디에이터 패턴을 쓰면 됩니다.

### 미디에이터 패턴의 장점

- 시스템하고 각 객체를 분리시킴으로써 재사용성을 획기적으로 향상시킬 수 있습니다.
- 제어 로직을 한 군데 모아놨기 때문에 관리하기가 수월합니다.
- 시스템에 들어있는 객체 사이에서 오가는 메시지의 종류를 확 줄이고 단순화시킬 수 있습니다.

### 미디에이터 패턴 활용법 및 단점

- 서로 연관된 GUI 구성요소들을 관리하기 위한 용도로 많이 쓰입니다.
- 디자인을 잘 하지 못하면 미디에이터 객체 자체가 너무 복잡해질 수 있다는 단점이 있습니다.

## 메멘토(Memento) 패턴

- 객체를 이전의 상태로 복구시켜야 하는 경우에는 메멘토 패턴을 쓰면 됩니다. 예를 들어 사용자가 '직업 취소'를 요청하는 경우를 생각하면 됩니다.

### 메멘토 패턴의 장점

- 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관하기 때문에 안전합니다.
- 핵심 객체의 데이터를 계속해서 캡슐화된 상태로 유지할 수 있습니다.
- 복구 기능을 구현하기가 쉽습니다.

### 메멘토 패턴 활용법 및 단점

- 메멘토 객체를 써서 상태를 저장합니다.
- 상태를 저장하고 복구하는 데 시간이 오래 걸릴 수 있다는 단점이 있습니다.
- 자바 시스템에서는 시스템의 상태를 저장할 때 직렬화를 사용하는 것이 좋습니다.

## 프로토 타입(Prototype) 패턴

- 어떤 클래스의 인스턴스 만드는 것이 자원/시간을 많이 잡아먹거나 복잡한 경우에는 프로토타입 패턴을 쓰면 됩니다.

### 프로토 타입 패턴의 장점

- 클라리언트에서는 새로운 인스턴스를 만드는 복잡한 과정을 몰라도 됩니다.
- 클라이언트에서는 구체적인 형식을 모르더라도 객체를 생성할 수 있습니다.
- 상화에 따라서 객체를 새로 생성하는 것보다 객체를 복사하는 것이 더 효율적일 수 있습니다.

### 프로토 타입 패턴 활용법 및 단점

- 시스템에서 복잡한 클래스 계층 구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 새로 만들어야 하는 경우에 유용하게 써먹을 수 있습니다.
- 때때로 객체의 복사본을 만드는 일이 매우 복잡한 경우가 있다는 단점이 있습니다.

## 비지터(Visitor) 패턴

- 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않은 경우에는 비지터 패턴을 쓰면 됩니다.

### 비지터 패턴의 장점

- 구조 자체를 변경시키지 않으면서도 복합 객체 구조에 새로운 기능을 추가할 수 있습니다.
- 비교적 손쉽게 새로운 기능을 추가할 수 있습니다.
- 비지터에서 수행하는 기능과 관련된 코드를 한 곳에 집중시켜 놓을 수 있습니다.

### 비지터 패턴의 단점

- 비지터를 사용하면 복합 클래스의 캡슐화가 깨집니다.
- 컬렉션 내의 모든 항목을 접근하기 위한 트래비서가 있기 때문에 복합 구조를 변경하기가 더 어려워집니다.
