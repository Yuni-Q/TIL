# 옵저버패턴
- 옵저버 객체들은 주제 객체를 구독하고 있으며(주제 객체에 등록되어 있으며) 주제의 데이터가 바뀌면 갱신 내용을 전달 받습니다.
- 옵저버 패턴(Observer Pattern)에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들하네 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다.
- 옵저버 패턴에서는 주제와 옵저버가 느슨하게 결합되어 있는 객체 디자인을 제공합니다.
  - 주제가 옵저버에 대해서 아는 것은 옵저버가 특정 인터페이스(Observer 인터페이스)를 구현한다는 것 뿐입니다.
  - 옵저버는 언제든지 새로 추가할 수 있습니다.
  - 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 전혀 변경할 필요가 없습니다.
  - 주제와 옵저버는 서로 독집적으로 재사용할 수 있습니다.
  - 주제나 옵저버가 바뀌더라도 서로한테 영향을 미치지는 않습니다.
- 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다. 객체 사이의 상호의존성을 최소화할 수 있기 떄문입니다.
- 옵저버한테 연락이 가는 순서에 의존하면 절대 안 됩니다.
- java.util.observable의 단점
  - observable은 클래스 입니다.
    - observable이 클래스기 때문에 서브클래스를 만들어야 한다는 점이 문제가 됩니다. 이미 다른 수퍼클래스를 확장하고 있는 클래스에 obsevable의 기능을 추가할 수 없으니까요. 그래서 재사용성에 제약이 생기게 됩니다.
    - obsevable 인터페이스라느 것이 없기 떄문에 자바에 내장된 Obsevable API하고 잘 맞는 클래스를 직접 구현하는 것은 불가능합니다. java.util 구현을 다른 구현으로 바꾸는 것도불가능하죠.
  - Observable 클래스의 핵심 메소드를 외부에서 호출할 수 없습니다.
  - java.util.Observable을 확장한 클래스를 쓸 수 있는 상황이라면 Observable API를 쓰는 것도 괜찮을 것입니다. 하지만 앞서 했던 것처럼 직접 구현해야 할 수도 있습니다. 둘 중 어떤 방법을 쓰든 옵저버 패턴만 제대로 알고 있다면 그 패턴을 활용하는 API는 어떤 것이든 잘 활용할 수 있을 것입니다.

## 디자인 원칙
- 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.

## 다지안 도구상자 안에 들어가야 할 도구들

### 객체지향 원칙
- 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.

### 객체지향 패턴
- 옵저버 패턴 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의 합니다.

### 핵심정리
- 옵저버 패턴에서는 객체들 사이에 일대다 관계를 정의 합니다.
- 주제 또는 Observable 객체는 동일한 인터페이스를 써서 옵저버에 연락을 합니다.
- Observable에서는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 대해 전혀 모르기 때문에, 이들 사이의 결합은 느슨한 결합입니다.
- 옵저버 패턴을 이용하면 주제 객체에서 데이터를 보내거나(푸시 방식) 옵저버가 데이터를 가져오는(풀 방식)을 쓸 수 있습니다(풀 방식이 더 "옳은" 것으로 간주됩니다)
- 옵저버들한테 연락을 돌리는 순서에 젖ㄹ대로 의존하면 안 됩니다.
- java.util.Observable의 몇가지 문제점에 주의 합시다.
- 필요하면 언제든지 주저하지말고 Observable 클래스에 상응하는 클래스를 직접 구현해 봅시다.
- 스윙 및 여러 GUI 프레임워크에서 옵저버 패턴이 많이 쓰입니다.
- 옵저버 패턴은 JavaBeans나 RMI를 비롯하여, GUI가 아닌 다른 부분에서도 광범위하게 쓰입니다.

## 디자인 원칙 경시대회
- 애플리케이션에 바뀌는 부분을 찾아내서 바뀌지 않는 부분으로부터 분리 시킨다.
  - 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식입니다. 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있습니다. 나중에 바뀔 것에 대비해 두면 이렇게 편하게 작업할 수 있습니다.
- 특정 구현이 아닌, 인터페이스에 맞춰서 프로그래밍한다.
  - Subject와 Observer에서 모두 인터페이스를 사용했습니다.  Subject에서는 Subject 인터페이스를 통해서 Observer 인터페이스를 구현하는 객체들의 등록. 탈퇴를 관리하고, 그런 객체들한테 연락을 돌리지요. 지금까지 우리가 봐 왔던 것차럼, 이렇게 함으로써 결합이 느슨하게 만들수 있습니다.
- 상속보다는 구성을 활용한다.
  - 옵저버 패턴에서는 구성을 활용하여, 옵저버들을 관리합니다. 주제와 옵저버 사이의 관계는 상속이 아니라 구성에 의해서 이루어지니까요. 게다가 실행중에 구성되는 방식을 사용하니까 더할 나위 없이 좋겠죠.