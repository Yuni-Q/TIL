
# MSA

## 모놀리틱 아키텍쳐 란?
보통 작은 서비스 들은 모노리틱으로 구성되어 있습니다.<br>
프로젝트의 모든 구성이 1개의 서버에 구축 되어 있습니다.<br>
이 경우 SPOF 문제가 발생 할 수 있습니다.<br>
이를 해결하기 위해 서버를 여러대 띄운 다음 L4로 요청을 분산 처리 하는 방법이 있다.<br>
하지만 이는 완벽 할 수 없고 배포 시간의 문제나 요청을 처리하는 성능 문제로 MSA가 주목 받고 있습니다.<br>

## 모놀리틱의 단점
애플리케이션 확장성 에로 => 아키텍쳐 유지 진화의 어려움 => 민첩성 저해<br>
장기 개발 사이클 ( 다수개발자 공통 참여 ) => 신규 출시에 몇 달이 걸림 => 혁신 저해<br>
운영이 어려움 ( 특정 모듈 장애시 ) => 신규 기능 추가에 어려움 => 고객 불만족<br>

## 마이크로 서비스의 이점
개발 마이크로 서비스 확장 가능 => 빠른 운영 및 개선 => 높은 민첩성<br>
빠른 빌드/테스트/배포 가능 => 몇 분만에 배포 가능 => 빠른 혁신<br>
명확한 오너쉽 및 자울적 운영 => 신규 기능 빠르게 추가 가능 => 고객 만족<br>

## MSA 란?
하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처 입니다.<br>
'하나의 서버는 하나의 기능만 하자'는 목적을 바탕으로 서비스를 구성합니다.<br>

서비스 복잡도가 증가하면서 모놀리틱 아키텍처가 가지는 문제점들은 배포 시간의 증가, 부분적 스케일 아웃의 어려움, 안정성의 감소 등 여러가지가 문제가 대두 되었습니다.<br>
그 중에서도 굳이 한가지를 꼽자면 애플리케이션을 구성하는 프로그래밍 언어, 또는 프레임워크의 변경이 거의 불가능에 가까울 정도로 어렵다는 점 입니다.<br>
모든 기술의 발전이 다 그렇듯이 마이크로서비스 역시 기존에 없다가 갑자기 등장한 개념은 아닙니다.<br>
많은 기업들에서는 이미 이와 같은 방식으로 서비스를 분리하여 애플리케이션을 만들었으며 그때 그때 다양한 용어로 이름 붙여져 왔습니다.<br>
그러나 최근 들어, REST API의 일반화, 도커(Docker)와 같은 컨테이너 기술, 클라우드 컴퓨팅 환경의 발전 등에 힘입어 마이크로서비스는 좀 더 손쉽게 구현될 수 있게 되었습니다.<br>
마이크로 서비스 아키텍쳐는 대용량 웹서비스가 많아짐에 따라 정의된 아키텍쳐인데, 그 근간은 SOA (Service Oriented Architecture : 서비스 지향 아키텍쳐)에 두고 있습니다.<br>
SOA는 엔터프라이즈 시스템을 중심으로 고안된 아키텍쳐라면, 마이크로 서비스 아키텍쳐는 SOA 사상에 근간을 두고, 대용량 웹서비스 개발에 맞는 구조로 사상이 경량화 되고, 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍쳐입니다.<br>

## SOA 란?
마이크로 서비스를 이야기할 때 가장 많이 받는 질문 중이 바로 10년전 우리가 알고 있는 SOA와 무엇이 다른가 하는 점입니다.<br>
모놀리식 애플리케이션을 서로 연결하는 ESB에 초점을 맞춥니다.<br>
ESB에서 복잡성을 숨기는 서비스 지향 구현 방식을 많은데, 몇 년씩 시간만 낭비하고 수백만 달러가 날아가는데도 별 가치가 없는 중앙 집중식 거버넌스를 가진 경우가 많다고 합니다.<br>
이것이 바로 과거의 문제점입니다. 마이크로서비스에서 커뮤니티에서 사용한 많은 기술들은 큰 조직에서 다양한 서비스를 통합하려는 개발자들의 경험에서 비롯되었습니다.<br>
ESB 라는 bus를 두고 사용하기 때문에 adapter를 따로 개발할 필요가 있습니다.<br>

## MSA 특징
마이크로 서비스 아키텍처에서 서비스는 작고, 독립적이며, 느슨하게 결합되어 있습니다.<br>
각 서비스는 작은 개발 팀이 관리할 수 있는 개별 코드베이스입니다.<br>
서비스를 독립적으로 배포할 수 있습니다. 팀이 전체 응용 프로그램을 다시 빌드한 후 재배치하지 않고도 기존 서비스를 업데이트할 수 있습니다.<br>
서비스가 해당 데이터 또는 외부 상태를 유지해야 합니다. 이는 별도의 데이터 레이어가 데이터 지속성을 처리하는 기존 모델과의 차이점입니다.<br>
서비스가 잘 정의된 API를 사용하여 서로 통신합니다. 각 서비스의 내부 구현 세부 정보는 다른 서비스에서 숨겨집니다.<br>
서비스가 동일한 기술 스택, 라이브러리 또는 프레임워크를 공유할 필요가 없습니다.<br>

### 추천
높은 릴리스 개발속도가 필요한 대규모 응용 프로그램.<br>
고확장성이 필요한 복합 응용 프로그램.<br>
풍부한 도메인이나 많은 하위 도메인이 있는 응용 프로그램.<br>
소규모 개발 팀으로 구성된 조직.<br>

### 장점
독립 배포. 전체 응용 프로그램을 다시 배포하지 않고 서비스를 업데이트할 수 있고, 문제가 발생하면 업데이트를 롤백 또는 롤포워드할 수 있습니다. 버그 수정 및 기능 릴리스 관리가 더 용이해지고 위험이 감소합니다.<br>
독립 개발. 단일 개발 팀이 서비스를 빌드, 테스트 및 배포할 수 있습니다. 그 결과, 연속적인 혁신과 더 빠른 릴리스 주기가 가능합니다.<br>
집중화된 소규모 팀. 팀이 한 서비스에 집중할 수 있습니다. 각 서비스의 범위가 작을수록 코드베이스 이해가 더 용이해지며 새로운 팀 구성원이 더 쉽게 이용할 수 있습니다.<br>
결함 격리. 한 서비스가 다운되더라도 전체 응용 프로그램 작동은 중단되지 않습니다. 그러나 저절로 복원되는 것은 아닙니다. 복원 모범 사례 및 디자인 패턴을 따라야 합니다.<br>
혼합 기술 스택. 팀이 해당 서비스에 가장 적합한 기술을 선택할 수 있습니다.<br>
세분화된 크기 조정. 서비스를 독립적으로 확장할 수 있습니다. 이와 동시에, VM당 서비스 수준이 높을수록 VM 리소스가 완전히 활용됨을 의미합니다. 배치 제약 조건을 사용하여 서비스를 VM 프로필(높은 CPU, 높은 메모리 등)에 맞출 수 있습니다.<br>
애플리케이션을 특화된 기능별로 나누게 되면 자연스럽게 애플리케이션의 추상화(abstraction)가 가능해집니다.
‘인증’을 담당하는 서비스(예, auth.example.com)는 그 구체적인 구현 내용을 모르더라도 다른 서비스에서 약속된 인터페이스를 이용해 인증 과정을 수행할 수 있습니다. 또한, 검색창의 ‘자동완성’을 담당하는 서비스(예, autocomplete.example.com)는 사용자의 입력을 받아서 자동완성 결과만을 응답해주면 되기 때문에 해당 API를 유지한 상태에서 세부적인 구현내용을 언제든지 손쉽게 개선하고 변경할 수 있습니다.<br>
어떤 서비스에서 사용하는 데이터는 변경이 적고 주로 읽기(read) 작업만 수행되는 반면, 또 다른 서비스의 데이터는 읽기 작업보다 빠른 속도로 쓰여지는(write) 작업이 대부분이라면 각각의 서비스 특성에 맞게 데이터베이스의 종류를 결정하고 설계할 수 있습니다.<br>
다른 서비스에 미치는 영향이 적습니다.<br>
여러 번 배포를 하는 것이 가능합니다.<br>
효율적인 자원사용이 가능하게 됩니다.<br>

### 단점
복잡성. 마이크로 서비스 응용 프로그램에는 동등한 모놀리식 응용 프로그램보다 작동 부분이 더 많습니다. 각 서비스는 더 단순하지만 전체 시스템이 더 복잡합니다.<br>
개발 및 테스트. 서비스 종속성에 대한 개발 시 다른 접근 방법이 필요합니다. 기존 도구는 서비스 종속성 작업에 맞게 설계되지 않았을 수 있습니다. 서비스 경계를 벗어난 리팩터링은 어려울 수 있습니다. 특히 응용 프로그램이 빠르게 발전하는 경우 서비스 종속성을 테스트하기도 어렵습니다.<br>
통제 부족. 마이크로 서비스 빌드에 대한 분산 접근 방법에는 장점이 있지만 문제가 발생할 수도 있습니다. 언어와 프레임워크가 너무 많아서 응용 프로그램 유지 관리가 어려워질 수 있습니다. 팀의 유연성을 지나치게 제한하지 않고 몇 가지 프로젝트 전체 표준을 적용하는 것이 유용할 수 있습니다. 특히 로깅과 같은 교차 기능에 해당합니다.
네트워크 정체 및 대기 시간. 다수의 작고 세분화된 서비스를 사용하면 서비스 간 통신이 증가할 수 있습니다. 또한 서비스 종속성 체인이 너무 길어질 경우(서비스 A가 B를 호출하고, B가 C를 호출하고...) 추가 대기 시간이 문제가 될 수 있습니다. API를 신중하게 디자인해야 합니다. 통신량이 과도한 API를 피하고, 직렬화 형식을 고려하고, 비동기 통신 패턴을 사용할 영역을 찾아보세요.<br>
데이터 무결성. 각 마이크로 서비스가 자체 데이터 지속성을 담당합니다. 그 결과, 데이터 일관성이 과제가 될 수 있습니다. 가능한 경우 결과적 일관성을 수용합니다.<br>
관리. 마이크로 서비스에 성공하려면 성숙한 DevOps 문화가 필요합니다. 전체 서비스의 상관관계 로깅이 까다로울 수 있습니다. 일반적으로 로깅은 단일 사용자 작업에 대한 여러 서비스 호출을 상호 연결해야 합니다.<br>
버전 관리. 서비스 업데이트로 인해 종속된 서비스가 손상되지 않아야 합니다. 언제든지 여러 서비스가 업데이트될 수 있으므로 신중하게 디자인하지 않으면 이전 버전 또는 이후 버전과의 호환성 문제가 발생할 수 있습니다.<br>
기능. 마이크로 서비스는 고도로 분산된 시스템입니다. 팀이 성공을 위한 기술과 경험을 가지고 있는지 신중하게 평가합니다.<br>
서비스 간의 통신에 대한 처리가 추가적으로 필요하다는 점입니다. 코드의 양이 늘어난다는 점 뿐만 아니라, 사용자의 요청을 처리하기 위한 응답속도의 증가에도 영향을 미칩니다. 서로다른 데이터베이스, 심지어 종류도 서로 다른 데이터베이스 내의 데이터의 정합성을 유지하기 위한 트랜잭션 처리는 대부분의 데이터베이스가 자체적으로 지원하지 않기 때문에 애플리케이션의 개발과정에서 항상 고려해야 한다는 어려움이 있습니다.<br>
넷플릭스(Netflix)와 같은 대규모 서비스들은 보통 수백개 이상의 마이크로서비스로 이루어지는데 이렇게 많은 서비스들은 각각 서로 분산되어 있기 때문에 관리 포인트가 증가하고 통합해서 모니터링하고 운영하는 것이 모놀리틱 아키텍처에 비해 매우 어려워집니다. 이것은 필연적으로 매우 정교한 배포 자동화를 필요로 하며 많은 PaaS(Platform as a Service) 서비스, 또는 도커(Docker)와 같은 컨테이너 기술을 활용하여 도움을 받을 수 있습니다.<br>

## API Gateway
API Gateway는 그 이름에서도 유추할 수 있듯이 서비스로 전달되는 모든 API 요청의 관문(Gateway) 역할을 하는 서버입니다. 클라이언트는 시스템 내부의 아키텍처가 마이크로서비스 형태로 되어있는지 모놀리틱 아키텍처로 구현되어 있는지를 알 필요가 없으며 서로 약속한 형태의 API 요청만을 서버로 보내면 알맞는 형태의 결과를 받을 수 있습니다.<br>
API Gateway는 이처럼 클라이언트의 요청을 일괄적으로 처리하는 역할 뿐만 아니라, 전체 시스템의 부하를 분산시키는 로드 밸런서의 역할, 동일한 요청에 대한 불필요한 반복작업을 줄일 수 있는 캐싱, 시스템상을 오고가는 요청과 응답에 대한 모니터링 역할도 수행할 수 있습니다.<br>
시스템 내부의 아키텍처를 숨길 수 있는(encapsulate) 특성이 API Gateway가 갖는 가장 큰 장점이라고 할 수 있습니다.<br>

### 단점
구현하고 관리해야하는 요소가 하나 더 증가한다는 점입니다.<br>
성능상의 병목(bottleneck)지점이 될 수 있다는 점입니다.<br>

### 중점 !
비동기(asynchronous)적이고 non-blocking I/O 처리가 가능하도록 구현하는 것이 적은 비용으로 최대의 성능을 발휘할 수 있는 관건이 됩니다.

## API Gateway의 필요성
요청을 보내야하는 서비스의 개수가 증가할 수록 응답속도가 늦어집니다<br>
소스코드가 복잡해지는 결과를 초래합니다<br>
모든 마이크로서비스가 웹 통신에 적합한 프로토콜로 통신하지는 않습니다<br>
클라이언트가 모든 마이크로서비스의 호스트명은 물론 end_point를 알고 있어야 합니다. 요청을 보내야하는 서비스의 개수가 증가할 수록 응답속도가 늦어진다는 점입니다.<br>
여러개의 마이크로서비스에 요청을 보내기 위해서는 모든 마이크로서비스의 주소를 저장해 두어야하며, 요청을 보낼 때마다 해당 요청이 어떤 서비스에 보내는 것인지를 명시해 주어야 하기 때문에 필연적으로 소스코드가 복잡해지는 결과를 초래합니다.<br>
모든 마이크로서비스가 웹 통신에 적합한 프로토콜로 통신하지는 않는다는 점입니다.<br>

다른 서비스 컴포넌트에 대한 의존성이 없이 서비스를 독립적으로 개발 및 배포/운영할 수 있다는 장점을 가지고 있으나, 다른 컴포넌트의 데이타를 API 통신을 통해서만 가지고 와야 하기 때문에 성능상 문제를 야기할 수 있고, 또한 이 기종 데이타 베이스간의 트렌젝션을 묶을 수 없는 문제점을 가지고 있다. (이러한 데이타 분산에 의한 트렌젝션 문제는 SOA 때부터 있어 왔다.) 데이타 분산으로 인한 트렌젝션 문제는 뒤에서 조금 더 자세하게 설명하도록 한다<br>

## API Gateway 구현 시 고려사항
개별 마이크로서비스로 보내는 요청의 선후관계가 존재하게 되는 것입니다.<br>
분산된 서버의 상태와 여러가지 변수들로 인해서 일부 서비스에 장애가 발생하거나 응답속도가 지연될 가능성이 높아지게 됩니다. API Gateway는 특정 요청에 대하여 개별 서비스의 특수한 장애 상황에 대해서 어떻게 대처할지에 대한 고려가 구현시 포함되어야 합니다.<br>
컴포넌트를 서비스화 하는 부분에 까지는 대부분 큰 문제가 없이 적응을 하지만 apigateway의 도입 부분의 경우, 내부적인 많은 잡음이 날 수 있고, 또한 도입을 했더라도 잘못된 설계나 구현으로 인해서 실패 가능성이 비교적 높은 모듈이기 때문이다. 마이크로 서비스 아키텍쳐의 핵심 컴포넌트이기도 하지만, 도입을 위해서는 팀의 상당 수준의 높은 기술적인 이해와 개발 능력을 필요로 한다.<br>
마지막으로 API Gateway는 모든 요청이 몰리는 지점이기 때문에 동일한 요청에 대하여 중복적으로 마이크로서비스에 요청을 보내는 것 보다 기존의 결과를 캐싱하여 재활용할 수 있도록 설계하는 것이 중요합니다. 예를 들어, 검색 포털의 메인화면에서 ‘날씨 서비스’와 같은 경우, 모든 요청에 대하여 반복적으로 현재 날씨를 가져오는 것 보다 주기적인 시간 단위로 갱신을 하며 한번 가져온 결과를 해당 주기 내에서 재활용하는 것이 불필요한 자원사용을 막는 현명한 방법이라고 할 수 있겠습니다.<br>

## 적용 대상
근본적인 원인은 서비스의 구조 자체가 너무 복잡하다는 점입니다. 복잡한 구조는 서비스 초창기 부터 함께 개발을 하여 전체 히스토리를 알고 있는 소수의 개발자를 제외하고는 대부분의 개발자들이 전체적인 시스템의 구조를 알지 못하기 때문에 재활용 가능한 모듈을 무시하고 중복된 코드를 생산하게 되며 사용하지 않는 코드가 기술 부채로 계속 쌓이게 됩니다. 또한, 코드가 서로 다양한 방식으로 연관되어 있기 때문에 간단한 버그 수정이 더 큰 버그를 양산하게 되는 결과를 초래합니다.

## Orchestration
다른 기능으로는 orchestration 이라는 개념이 있다. 기존 open api의 mash up과 같은 개념으로, 여러개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다.<br>
예를 들어, 포인트 적립과, 물품 구매라는 서비스가 있을때, 이 두개의 서비스를 묶어서 “물품 구입시 포인트 적립”이라는 새로운 서비스를 만들어 낼 수 있다. 이러한 orchestration 기능은, api gateway를 통해서 구현될 수 있다.<br>
이는 마이크로 서비스 아키텍쳐가 서비스 자체가 fine grained 형태로 잘게 쪼게졌기 때문에 가능한 일인데, 사실 orchestration을 api gateway 계층에서 하는 것은 gateway 입장에서 부담이 되는 일이다. 실제로 과거의 SOA 시절에 많은 ESB(Enterprise Service Bus) 프로젝트가 실패한 원인 중의 하나가 과도한 orchestration 로직을 넣어서 전체적인 성능 문제를 유발한 경우가 많았다. 그래서 orchestration 서비스의 활용은 마이크로 서비스 아키텍쳐에 대한 높은 이해와 api gateway 자체에 대한 높은 수준의 기술적인 이해를 필요로 한다.<br>
실제로 넷플릭스의 경우 마이크로 서비스 아키텍쳐를 사용하면서, 여러개의 서비스들을 gateway 계층을 통해서 orchestration 하는 모델을 사용하고 있다.<br>

## MSA 구현을 위해 사용하는 기술들

### RPC 프로토콜 ( HTTP 2.0 )
원격 프로시저 호출(영어: remote procedure call, 리모트 프로시저 콜, RPC)은 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술입니다.<br>
다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있다.

### MQ ( 메세지 큐 ) 
카프카<br>
rabbit MQ<br>

#### 메세지 큐를 이용해 작업의 효율성 증가
성공을 보장하기 위해 2개의 큐를 사용하기도 합니다. ( 파이프라인처럼 입력과 출력을 다른 큐에 활용합니다.)
status를 활용해 성공하지 못하면 재요청 합니다.

### 폴리글랏 프로그래밍
MSA를 활용하여 여러개의 언어와 db를 사용하여 개발 할 수 있습니다.

### 로그
ELK를 통해 여러 서버의 로그를 모아 로그 서버로 관리 합니다.
