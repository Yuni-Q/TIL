# 14장 점진적인개선

- 지난 수십여 년 동안 쌓아온 경험에서 얻은 교훈이라면, 프로그래밍은 과학보다 공예(craft)에 가깝다는 사실입니다.
- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 합니다.
- 하지만 대다수 신잠 프로그래머는 무조건 돌아가는 프로그램을 목표로 잡습니다. 일단 프로그램이 '돌아가면' 다음 업무로 넘어갑니다. '돌아가는' 프로그램은 그 상태가 어떻든 그대로 버려둡니다. 경험이 풍부한 전문 프로그래머라면 이런 행동이 전문가로서 자살 행위라는 사실을 잘 압니다.
- 처음부터 지저분한 코드를 짜려는 생각은 없었습니다. 하지만 어느 순간 프로그램은 프로그래머의 손을 벗어 납니다. 코드는 조금씩 엉망이 되어 갑니다.
- 첫 버전은 생각만큼 엉망이지 않았을 것입니다. 하지만 조금만 무엇인가를 더하려고 할 때 코드가 엄청나게 지저분해 집니다. 유지와 보수가 적당히 수월했던 코드가 버그와 결함이 숨어있을 지도 모른다는 상당히 의심스러운 코드로 뒤바뀌어 버립니다. 그렇게 되면 코드는 통제를 벗어나기 시작합니다. 그리고 조금 더 코드를 추가하면 코드는 완전히 엉망이 되어 버립니다.

### 그래서 멈췄다

- 계속 밀어 붙이면 프로그램은 어떻게든 완성하겠지만 그랬다가는 너무 커서 손대기 어려운 골칫거리가 생겨날 것입니다. 코드 구조를 유지보수하기 좋은 상태로 만들려면 문제를 인식한 바로 그 순간 기능을 더이상 추가하지 않고 리팩토링을 해야 합니다.

### 점진적으로 개선하다

- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위 입니다. 어떤 프로그램은 그저 그런 '개선'에서 결코 회복하지 못합니다. '개선' 전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문입니다.
- 그래서 테스트 주도 개발(Test-Driven Development, TDD)이라는 기법을 사용합니다. TDD는 '언제 어느 때라도 시스템이 돌아가야 한다'는 원칙을 따릅니다. 다시 말해, TDD는 시스템을 망가뜨리는 변경을 허용하지 않습니다. 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 합니다.
- 변경 전후에 시스템이 똑같이 돌아간다는 사실을 확인하려면 언제든 실행이 가능한 자동화된 테스트 슈트가 필요합니다.
- 코드를 최소로 건드리는 가장 단순한 변경을 가합니다. 그러면 코드 일부가 깨지게 되고 이를 재빨리 고칠 수 있습니다.
- 한 번에 하나씩 고치면서 테스트를 계속 돌려 테스트 케이스가 하나라도 실패하면 다음 변경으로 넘어가기 전에 오류를 수정합니다. 그러면 프로그램 구조를 조금씩 변경하는 동안에도 시스템의 정상 동작을 유지하기 쉬워지기 때문입니다.
- 리팩터링을 하다 보면 코드를 넣었다 뺐다 하는 사례가 아주 흔합니다. 단계적으로 조금씩 변경하며 매번 테스트를 돌려야 하므로 코드를 여기저기 옮길 일이 많아집니다. 리팩터링은 루미 큐브 맞추기와 비슷합니다. 큰 목표 하나를 이루기 위해 자잘한 단계를 수 없이 거친다. 각 단계를 거쳐야 다음 단계가 가능합니다.
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아집니다. 적절한 장소를 만들어 코드만 분리해도 설계가 좋아집니다. 관심사를 분리하면 코드를 이해하고 보수 하기 훨씬 더 쉬워집니다.

### 최종 코드

- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아집니다.
- 적절한 장소를 만들어 코드만 분리해도 설계가 좋아집니다.
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워집니다.

## 결론

- 그저 돌아가는 코드만으로는 부족합니다. 돌아가는 코드가 심하게 망가지는 사례는 흔합니다. 단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족합니다. 설계와 구조를 개선할 시간이 없다고 변명할지 모르지만 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인입니다. 나쁜 일정은 다시 짜면 됩니다. 나쁜 요구사항은 다시 정의하면 됩니다. 나쁜 팀 역학은 복구하면 됩니다. 하지만 나쁜 코드는 썩어 문드러집니다. 점점 무게가 늘어나 팀의 발목을 잡습니다. 속도가 점점 느려지다 못해 기어가는 팀도 많습니다. 너무 서두르다가 이후로 영원히 자신들의 운명을 지배할 악성 코드라는 굴레를 젊어집니다.
- 물론 나쁜 코드도 깨끗한 코드로 개선할 수 있습니다. 하지만 비용이 엄청나게 많이 듭니다. 코드가 썩어가며 모듈은 서로서로 얽히고 설켜 뒤엉키고 숨겨진 의존성이 수도 없이 생깁니다. 오래된 의존성을 찾아내 깨려면 상당한 시간과 인내심이 필요합니다. 반면 처음부터 코드를깨ㅜ끗하게 유지하기란 상대적으로 쉽습니다. 아침에 엉망으로 만든 코드를 오후에 정리하기는 어렵지 않습니다. 더욱이 5분 전에 엉망으로 만든 코드는 지금 당장 정리하기 아주 쉽습니다.
- 그러므로 코드는 언제나 최대한 깔끔하고 단순하게 정리해야 합니다. 절대로 썩어가게 방치하면 안 됩니다.
