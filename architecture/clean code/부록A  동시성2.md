# 부록A 동시성2

## 클라이언트/서버 예제

- 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 합니다. 가능성은 다음 두 가지 입니다.
  - I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보냅니다.
  - 프로세서 : 수치 계산, 정규표현식 처리, 가비지 컬렉션 등에 시간을 보냅니다.
- 대개 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 대개 하나가 지배적입니다.
- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합합니다. 프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘인다고 빨라지지 않습니다. CPU 사이클은 한계가 있기 때문입니다.
- 반면 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 합니다. 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있습니다.

## 스레드 추가하기

- 서버의 process 함수가 주로 I/O 연산에 시간을 보낸다면, 한 가지 방법으로, 스레드를 추가합니다.(process 함수만 변경합니다.)

## 서버 살펴보기

- 새 서버가 만드는 스레드 수는 코드에서 한계를 명시하지 않으므 로 이론상으로 JVM(Java Virtual Machine)이 허용하는 수까지 가능합니다.
- 대다수 간단한 시스템은 그래도 괜찮습니다. 하지만 공용 네트워크에 연결된 수 많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰려 시스템이 동작을 멈출수도 있습니다.
- 서버 코드가 지는 책임이 소켓 연결 관리, 클라이언트처리, 스레드 정책, 서버 종료정책 이 모든 책임은 process 함수가 집니다. 게다가 코드는 추상화 수준도 다양합니다. process 함수가 작기는 하지만 확실히 분할할 필요가 있습니다.
- 서버 프로그램은 고칠 이유가 여럿입니다. 즉, 단일 책임 원칙SRP(Single Responsibility Primple)을 위반합니다. 다중 스레드 프로그램을 깨끗하게 유지하려면 잘 통제 된 몇 곳으로 스레드 관리를 모아야 합니다.
- 스레드를 관리하는 코드는 스레드만 관리해야 합니다. 비동시성 문제까지 뒤섞지 않더라도 동시성 문제는 그 자체만으로도 추적하기 어렵습니다.
- 앞서 열거한 책임마다 클래스를 만든다면, 즉 스레드 관리 책임을 클래스로 분리한다면, 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않ㅅ브니다. 더구나 스레드를 걱정하지 않고서 다른 책임을 테스트하기가 훨씬 더 쉬워집니다.
- 스레드 관리를 한 곳으로 몰았으니 스레드를 제어하는 동시성 정책을 바꾸기도 쉬워집니다.

### 결론

- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켜야 하빈다. 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요합니다.

## 가능한 실행 경로

- 프레임(frame) : 모든 메서드 호출에는 프레임이 필요합니다. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수를 포함합니다. 프레임은 호출스택을 정의할 때 사용하는 표준기법입니다.현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출을 지원합니다.
- 지역 변수(local vauibtes) : 메서드 범위 내에 정의되는 모든 변수를 가리킵니다. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수를 갖습니다. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킵니다.
- 피연산자 스택(operand stack) : JVM이 지원하는 명령 대다수는 매개변수를 받습니다. 피연산자 스택은 이런 매개변수를 저장하는 장소입니다. 피연산자 스택은 표준 LIFO(last in, first out) 자료 구조입니다.

### 결론

- 스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해 바이트 코드를 속속들이 이해할 필요는 없습니다. 여러 스레드가 서로를 훼방 놓는 시나리오가 어느 정도 머릿속에 그려지는 정도의 지식이면 충분합니다.
- 어떤 연산이 안전하고 안전 하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 합니다.(전처리 연산과 후처리 연산 모두) ++ 연산은 원자적 연산이라 오해하는 사람이 많은데, ++ 연산은 분명히 원자적 연산이 아닙니다. 즉, 다음을 알아야 한다는 말이다.
  - 공유객체/값이 있는곳
  - 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
  - 동시성 문제를 방지하는 방법

## 라이브러리를 이해하라

### Executor 프레임워크

- ExecutorClientScheduler.java에서 봤듯이, 자바 5에서 처음 소개한 Ex­ecutor 프레임워크는 스레드 풀링으로 정교한 실행을 지원합니다. Executor는 java.util.concurrent 패키지에 속하는 클래스입니다.
- 직접 생성한 스레드 풀을 사용한다면 Executor 클래스를 고려하기 바랍니다. 코드가 깔끔해지고, 이해하기 쉬워지고, 크기가 작아집니다.

### 스레드를 차단하지 않는 방법

- 현대 프로세서는 흔히 CAS(Compare and Swap)라 불리는 연산을 지원합니다. CAS는 데이터 베이스 분야에서 낙관적 잠금(optimistic locking)이라는 개념과 유사합니다. 반면 동기화 버전은 비관적 잠금(pessimistic locking)이라는 개념과 유사합니다.
- 스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발합니다. 그래서 그런 상황이 발생했는지 효율적으로 감지해 갱신이 성공할 때까지 재차 시도합니다. 스레드 몇 개가, 아니 많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적입니다.
- 메서드가 공유 변수를 갱신하려 든다면 CAS 연산은 현재 변수 값이 최종으로 알려진 값인지 확인합니다. 그렇다면 변수 값을 갱신합니다. 아니라면 다른 스레드가 끼어들었다는 뜻이므로 변수 값을 갱신하지 않습니다. (CAS 연산으로) 값을 변경 하려던 메서드는 값이 변경되지 않았다는 사실을 확인하고 다시 시도합니다.

### 다중 스레드 환경에서 안전하지 않은 클래스

- SimpleDateFormat
- 데이터베이스연결
- java.util 컨테이너 클래스
- 서블릿
- 몇몇 집합(collection) 클래스는 스레드에 안전한 메서드를 제공합니다.하지만 그런 메서드 여럿을 호출하는 작업은 스레드에 안전하지 않습니다.
  - 스레드에 안전한 집합 클래스를 사용합니다.

## 메서드 사이에 존재하는 의존성을 조심하라

- 해결 방안은 세 가지입니다.
  - 실패를 용인합니다.
  - 클라이언트를 바꿔 문제를 해결합니다. 즉, 클라이언트-기반 잠금 메커니즘을 구현합니다.
  - 서버를 바꿔 문제를 해결합니다. 서버에 맞춰 클라이언트도 바꿉니다. 즉, 서버-기반 잠금 메커니즘을 구현합니다.

### 실패를 용인한다

- 때로는 실패해도 괜찮도록 프로그램을 조정할 수 있습니다.
- 예를 들어, 위에서 클라이언트가 예외를 받아 처리해도 됩니다. 다소 조잡한 방법입니다. 한 밤중에 시스템을 재부팅해 메모리 누수를 해결하는 방법과 비슷합니다.

### 클라이언트-기반 잠금

- 비록 DRY(Dor't Repeat Yourself) 원칙을 위반하지만, 다중 스레드 환경에 안전하지 못한 외부 도구를 사용하는 경우라면 필요할지도 모릅니다.
- 하지민 서버를 사용하는 모든 프로그래머가 락을 기억해 객체에 걸었다 풀어야 하므로 다소 위험한 전략입니다.

### 서버-기반 잠금

- 일반적으로 서버-기반 잠금이 더 바람직합니다.
  - 코드 중복이 줄어듭니다. 클라이언트-기반 잠금 메커니즘은 각 클라이언트가 알아서 서버를 잠궈야 합니다. 잠금 메커니즘을 서버에 구현하면 클라이언트는 자유롭게 객체를 사용할뿐더러 클라이언트에 잠금 코드를 추가할 필요도 없어집니다.
  - 성능이 좋아집니다. 단일스레드 환경으로 시스템을 배치할 경우 (다중 스레드 서버를 단일스레드 서버로) 서버만 교체하면 오버헤드가 줄어듭니다.
  - 오류가 발생할 가능성이 줄어든듭니다. 잠금을 잊어버리는 바람에 오류가 발생할 위험은 프로그래머 한명으로 제한됩니다.
  - 스레드 정책이 하나 입니다. 클라이언트-기반 잠금은 각 클라이언트가 정책을 구현하는 반면, 서버-기반 잠금은 서버 한곳에서 정책을 구현합니다.
  - 공유 변수 범위가 줄어듭니다. 클라이언트가 공유 변수 자체를 모르거나 공유 변수가 잠긴 방식을 모릅니다. 모두가 서버에 숨겨집니다. 문제가 생기면 살펴볼 곳이 적습니다.
- 서버 코드에 손대지 못한다면 ADAPTER 패턴을 사용해 API를 변경한 후 잠금을 추가 합니다.
- 아니면, 더 좋은 방법으로, 스레드에 안전하며 인터페이스가 확장된 집합 클래스를 사용합니다.

## 데드락

- 데드탁을 근본적으로 해결하려면 원인을 이해해야 합니다. 다음 네 가지 조건을 모두 만족하면 데드탁이 발생합니다.
  - 상호 배제(Mutual Exclusion)
  - 잠금 & 대기 (Lock&Wait)
  - 선점 불가(No Preemption)
  - 순환대기(Circular Wait)
- 네 조건 모두를 충족해야 데드락이 발생합니다. 네 조건 중 하나라도 깨버리면 데드락은 발생하지 않습니다.

### 상호 배제

- 여러 스레드가 한 자원을 공유하나 그 자원은 여러 스레드가 동시에 사용하지 못하며, 개수가제한적이라면
  상호 배제 조건을 만족합니다.
- 좋은 예가 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등과 같은 자원입니다.

#### 상호 배제 조건 깨기

- 데드락을 피하는 전략 중 하나가 상호 배제 조건을 비껴가는 방법입니다.
- 동시에 사용해도 괜찮은 자원을 사용합니다.
- 스레드 수 이상으로 자원 수를 늘입니다.
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인합니다.
- 불행하게도 대다수 자원은 그 수가 제한적인 데다 동시에 사용하기도 어렵습니다. 게다가 첫 번째 자원을 사용하고 나서야 두 번째로 필요한 자원이 밝혀지는 경우도 없지 않습니다.

### 잠근 & 대기

- 일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않습니다.

#### 잠금 & 대기 조건 깨기

- 대기하지 않으면 데드락이 발생하지 않습니다.
- 각 자원을 점유하기 전에 확인합니다. 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작합니다.
- 이 방법은 잠재적인 문제가 몇 가지 있습니다.
  - 기아(Starvation) : 한 스레드가 계속해서 필요한 자원을 점유하지 못합니다. 점유 하려는 자원이 한꺼번에 확보하기 어려운 조합일지도 모릅니다.
  - 라이브락(Livelock) : 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 내놨다를 반복합니다. (임베디드 장비나 간단하게 직접 짠 스레드에 작업을 분산하는 알고리즘 둥) 단순한 CPU 스케줄링 알고리즘에서 특히 쉽게 발생합니다.
- 두 경우 모두가 자칫하면 작업 처리량을 크게 떨어뜨립니다.
- 기아는 CPU 효율을 저하시키는 반면 라이브락은 쓸데 없이 CPU만 많이 사용합니다.
- 이런 전략이 비효율적으로 보일지도 모르지만 아무 대책이 없는 경우보다는 좋습니다. 모든 전략이 실패할 때 언제든 꺼내 들 카드라는 장점이 있습니다.

### 선점 불가

- 한 스레드가 다른 스레드로부터 자원을 빼앗지 못합니다. 자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 점유하지 못합니다.

#### 선점 불가 조건 깨기

- 데드락을 피하는 또 다른 전략은 다른 스레드로부터 자원을 뺏어오는 방법입니다. 일반적으로 간단한 요청 메커니즘으로 처리합니다. 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라 요청합니다. 소유 스레드가 다른 자원을 기다리던 중이 었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작합니다.
- 앞서 언급한 전략과 비슷하지만 스레드가 자원을 기다려도 괜찮다는 이점이 있습니다. 그러면 처음부터 다시 시작하는 횟수가 줄어듭니다.
- 하지만 조심하기 바랍니다. 이 모든 요청을 관리하기가 그리 간단하지 않습니다.

### 순환 대기

- 죽음의 포옹(deadly embrace)이라고도 합니다.

#### 순환 대기 조건 깨기

- 데드탁을 방지하는 가장 흔한 전략입니다. 대다수 시스템에서는 모든 스레드가 동의하는 간단한 규약이 면 충분합니다.
- 좀 더 일반적으로 말해, 모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능합니다.
- 그러나 여느 전략과 마찬가지로 이 전략 역시 문제를 일으킬 소지가 있습니다.
  - 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모릅니다. 그래서 맨 처음 할당한 자원을 아주 나중에야 쓸지도 모릅니다. 즉, 자원을 꼭 필요한 이상으로 오랫동안 점유합니다.
  - 때로는 순서에 따라 자원을 할당하기 어렵습니다. 첫 자원을 사용한 후에야 둘째 자원 ID를 얻는다면 순서대로 할당하기란 불가능합니다.
- 이렇게 데드락을 피하는 전략은 많습니다. 어떤 전략은 기아를 일으키고, 어떤 전략은 CPU를 심하게 사용해 응답도를 낮춥니다.
- 프로그램에서 스레드 관련 코드를 분리하면 조율과 실험이 가능하므로 통찰력이 높아져 최적의 전략을 찾기 쉬워집니다.

## 다중 스레드 코드 테스트

- 몬테 카를로 테스트. 조율이 가능하게 유연한 테스트를 만듭니다. 그런 다음, 임의로 값을 조율하면서 (예를 들어, 테스트 서버에서 ) 반복해 돌립니다. 테스트가 실패하면 버그가 있다는 증거입니다. 테스트는 일찌감치 작성하기 시작해 통합 서버에서 계속 돌립니다. 참고로, 테스트가 실패한 조건은 신중하게 기록합니다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌립니다. 반복해서 돌립니다. 계속 해서 돌립니다. 테스트가 실패 없이 오래 돌아갈수록 두 가지 중 하나일 확률이 높아집니다.
  - 실제 코드가 올바르다.
  - 테스트가 부족해 문제를 드러내지 못한다.
- 부하가 변하는 장비에서 테스트를 돌립니다. 실제 환경과 비슷하게 부하를 걸어 줄 수 있다면 그렇게 합니다.
- 하지만 위와 같은 조치를 모두 취하더라도 코드에서 스레드 문제를 찾아낼 가능성은 매우 낮습니다. 십억 번에 한 번씩만 일어나는 희귀한 문제가 가장 골치 아픕니다. 복잡한 시스템에서 이런 문제는 공포 그 자체입니다.

## 스레드 코드 테스트를 도와주는 도구

- IBM은 ConTest라는 도구가 있습니다. 스레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구입니다.

## 결론

- 다중 스레드 시스템을 구현하려 면 알아야 할 내용이 아주 많습니다. 더그 리(Doug Lea)가 쓴 멋진 책 Concurrent Programming in Java: Design Principles and Patterns을 출발점으로 추천합니다.
- 동시 갱신을 방지하는 깨끗한 동기화/잠금 기법을 소개했습니다.
- 스레드가 I/O 위주 시스템의 처리율을 높여주는 이유와 실제로 처리율을 높이는 방법을 살펴봤습니다.
- 데드탁을 논했으며, 깔끔하게 데드탁을 방지하는 기법도 열거했습니다.
- 마지막으로 보조 코드를 추가해 동시성 문제를 사전에 노출하는 전략을 소개했습니다.
