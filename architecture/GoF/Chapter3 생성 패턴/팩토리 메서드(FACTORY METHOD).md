# 팩토리 메서드(FACTORY METHOD)

## 의도

- 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할 지에 대한 결정은 서브클래스가 내리도록 합니다.

## 다른 이름

- 가상 생성자(Virtual Constructor)

## 동기

- 프레임워크는 추상 클래스를 사용하여 객체 간의 관련성을 정의하고 유지할 수 있습니다. 또한 프레임워크는 이들 객체를 생성할 책임을 지니기도 합니다. 프레임워크는 이들 추상 클래스 간의 상호작용을 책임져서 전체 시스템의 기본 동작 방식을 정의합니다. 그리고 이들 추상 클래스를 상속하는 서브클래스에 서 구체적인 행동을 정의함으로써 새로운 응용프로그램을 만듭니다.

## 활용성

- 팩토리 메서드는 다음과 같은 상황에 사용합니다.

- 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브 클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때

## 참여자

- Product : 팩토리 메서드가 생성하는 객체의 인터페이스를 정의합니다.
- ConcreteProduct : Product 클래스에 정의된 인터페이스를 실제로 구현합니다.
- Creator : Product 타입의 객체를 반환하는 팩토리 메서드를 선언 합니다. Creator 클래스는 팩토리 메서드를 기본적으로 구현하는데, 이 구현에서는 ConcreteProduct 객체를 반환합니다. 또한 Product 객체의 생성을 위해 팩토리 메서드를 호출합니다.
- ConcreteCreator : 팩토리 메서드를 재정의하여 ConcreteProduct의 인스턴스를 반환합니다.

## 협력 방법

- Creator는 자신의 서브클래스를 통해 실제 필요한 팩토리 메서드를 정의하여 적절한 ConcreteProduct의 인스턴스를 반환할 수 있게 합니다.

## 결과

- 팩토리 메서드 패턴은 응용프로그램에 국한된 클래스가 여러분의 코드에 종속되지 않도록 해 줍니다. 응용프로그램은 Product 클래스에 정의된 인터페이스와만 동작하도록 코드가 만들어지기 때문에, 사용자가 정의한 어떤 ConcreteProduct 클래스와도 동작할 수 있게 됩니다.
- 팩토리 메서드의 잠재적인 단점은 사용자가 ConcreteProduct 객체 하나만 만들려 할 때에도 Creator 클래스를 서브클래싱해야 할지 모른다는 점입니다. 서브클래싱 기법은 사용자 Creator 클래스를 상속해서 서브클래스를 만들어야 할 때는 그럭저럭 훌륭한 방법이지만, 그렇지 않은 때라면 다른 방식으로 클래스의 진화 과정을 처리 해야 합니다.
- 팩토리 메서드 패턴을 쓰면서 얻는 결과는 다음과 같이 두 가지가 더 있습니다.

1. `서브클래스에 대한 훅(hook) 메서드를 제공합니다.` 팩토리 메서드로 클래스 내부에서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 훨씬 응용성이 높아 집니다. 팩토리 메서드 패턴에서는 객체별로 서로 다른 버전을 제공하는 흑 기능을 서브클래스에 정의합니다.
2. `병렬적인 클래스 계통을 연결하는 역할을 담당합니다.` Creator 클래스만이 팩토리 메서드를 호출하게 되어 있습니다. 하지만 꼭 이때만 그런 것은 아닙니다. 팩토리 메서드는 병렬적인 클래스 계통이 만들어질 때 더욱 쓸모가 있습니다. 병렬적 클래스 계통은 클래스가 자신의 책임을 분리된 다른 클래스에 위임할 때 발생합니다.

## 구현

- 팩토리 메서드 패턴을 구현할 때는 다음 사항을 고려해야 합니다.

1. `구현 방법이 크게 두가지입니다.` 팩토리 패턴을 구현하는 두가지 방식은 (1)Creator 클래스를 추상 클래스로 정의하고, 정의한 팩토리 메서드에 대한 구현은 제공하지 않는 경우와 (2) Creator가 구체 클래스이고, 팩토리 메서드에 대한 기본 구현을 제공하는 경우입니다. 물론 기본 구현을 일부 정의한 추상 클래스로 정의할 수도 있지만, 흔한 일은 아닙니다. 추상 클래스로 정의할 때는 구현을 제공한 서브클래스를 반드시 정의해야 합니다. 이때, 아직 예측할 수 없는 클래스들을 생성해야 하는 문제가 생깁니다. 구체 클래스로 정의할 때는 Creator가 팩토리 메서드를 사용하여 유연성을 보장할 수 있습니다. 이런 규칙이 있지요. '객체의 생성은 별도의 연산으로 분리하여, 이 연산을 서브클래스에서 재정의하게 합니다.' 이 규칙을 따르면, 서브클래스 설계자는 부모 클래스가 인스턴스를 만드는 객체의 클래스를 변경할 수 있습니다.
2. `팩토리 메서드를 매개변수화합니다.` 또 다른 구현 방식으로, 팩토리 메서드를 이용해서 여러 종류의 제품을 생성하는 방법도 있습니다. 팩토리 메서드가 매개변수를 받아서 어떤 종류의 제품을 생성할지 식별하게 만드는 것입니다. 물론, 팩토리 메서드가 생성하는 모든 객체는 Product라는 인터페이스를 만족해야 합니다. 매개변수화된 팩토리 메서드를 오버라이드하면, Creator 클래스가 생성하는 제품을 쉽게 확장하거나 변경할 수 있습니다. 새로운 종류의 제품에 대한 식별자를 추가하거나, 기존의 식별자를 다른 제품과 연결할 수 있습니다.
3. `언어마다 구현 방법이 조금 다를 수 있습니다.` 스몰토크 프로그램은 종종 인스턴스화할 객체의 클래스를 반환하는 메서드를 사용합니다. Creator 팩토리 메서드는 이 클래스를 이용해서 제품을 생성하고, ConcreteCreator 클래스는 이 값을 저장하거나 연산합니다. 결과적으로，인스턴스화될 ConcreteProduct 타입과의 바인딩(binding)이 늦게 이루어지게 됩니다.
4. `템플릿을 사용하여 서브클래싱을 피합니다.` 앞에서 언급했듯이 팩토리 메서드를 쓰면 생길 수 있는 잠재적인 문제점 중 하나는 그냥 Product 클래스 하나를 추가하려 할 때마다 서브클래싱을 해야 한다는 점입니다. 이로써 클래스 계통의 부피가 확장되는 문제가 생길 수 있습니다. C++에서 이런 문제를 해결할 수 있는 방법 중 하나는 Creator 클래스의 서브클래스가 되는 템플릿 클래스를 정의하고 이것이 Product 클래스로 매개변수화되도록 만드는 것입니다. 이 템플릿 클래스를 이용하면, 사용자는 Creator를 상속받는 서브클래스를 정의할 필요 없이, 적절한 Product 클래스만 준비해 놓으면 됩니다.
5. `명명 규칙을 따르는 것도 매우 중요한 일입니다.` 팩토리 메서드를 쓴다는 사실을 명확하게 만들어 주는 명명 규칙을 따르는 좋은 습관을 들이도록 합시다.

## 관련 패턴

- 추상 팩토리 패턴은 이 팩토리 메서드를 이용해서 구현할 때가 많습니다. 추상 팩토리 패턴에서도 팩토리 메서드의 모습을 볼 수 있습니다. 팩토리 메서드는 템플릿 메서드 패턴에서도 사용될 때가 많습니다. 원형 패턴은 Creator 클래스의 상속이 필요하지는 않습니다. 그러나 Product 클래스에 정의된 초기화 연산은 필요합니다. Creator 클래스는 객체의 초기화를 위해 초기 화 연산을 사용하지만, 팩토리 메서드는 이런 연산이 필요하지 않습니다.
