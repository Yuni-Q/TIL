# Chapter 2 사례 연구: 문서 편집기 설계

## 재귀적 합성

- 계층적으로 구조화된 정보를 보여주는 가장 일반적인 방법으로 재귀적 합성(recursive composition) 기법이 있습니다. 이 기법을 이용하면 단순한 것에서 복잡한 것을 점진적으로 만들어 낼수 있습니다. 쉽게 말해, 재귀적 합성은 간단한 그래픽 요소들을 복합하여 문서를 만드는 방법입니다. 첫 단계에서 문서에 있는 한 행(row)의 왼쪽에서 오른쪽으로 글자들과 그래픽들을 채웁니다. 그러면 여러 선들이 하나의 열(column)을 만들게 되고, 다수의 열이 하나의 페이지를 만듭니다.
- 물리적 구조를 표현하는 데 있어서, 각각의 주요 요소를 모두 객체로 만들어 구현할 수 있습니다. 이렇게 하면 글자나 그래픽과 같은 시각적 요소뿐만 아니라 보이지 않는 구조적 요소(선, 열 등)도 포함할 수 있습니다.
- 문서에 정의할 글자와 그래픽 요소를 객체화하면 Lexi 설계의 유연성을 늘릴 수 있게 됩니다. 이제는 문자와 그래픽 모두를 바라보는 방법이 같아집니다. 즉, 화면에 표시하고 서식을 지정할 수 있으며 다른 것들 안에 포함될 수 있는 대상으로 동일시 합니다. 이렇게 함으로써 다른 기능에 영향을 주지 않고 새 글자를 추가할 수도 있습니다. Lexi의 객체 구조는 문서의 물리적 구조를 그대로 따르게 됩니다.
- 이 접근법에는 두 가지 중요한 의미가 내포되어 있습니다. 첫째, 각 객체에 대응하는 클래스가 필요합니다. 둘째, 이 클래스는 객체들을 일관되게 다루기 위해 호환성을 갖는 인터페이스를 정의해야 합니다. 그러나 두 번째 사항은 확정적인 것은 아닙니다. C++와 같은 언어에서 인터페이스를 호환성 있게 만드는 방법은 관련된 클래스들을 상속을 통해 묶는 것인데, 그러면 부모 클래스에 공통의 인터페이스를 정의할 수 있습니다.

## 복합체 패턴

- 재귀적 합성은 단순한 문서 이상의 것을 처리할 때 좋은 방법입니다. 재귀적 합성을 이용해서 복잡한 계층적 구조를 표현할 수 있습니다. 복합체 패턴은 객체지향 관점에서 재귀적 합성을 표현하는 패턴입니다.

## 합성자와 복합

- 서식 설정 알고리즘을 캡슐화할 수 있는 객체를 Compositor 클래스로 정의합니다. Compositor 클래스에 정의한 인터페이스는 서식을 지정할 글리프가 무엇인지 (SetComposition() 연산), 서식 설정은 언제 해야 하는지(Compose() 연산)를 알 수 있게 하는 연산을 정의하였습니다. Compositor 클래스가 포맷을 지정하는 글리프는 Glyph 클래스의 특정 서브클 래스인 Composition 클래스와 자식 관계를 갖는 객체들입니다. Composition 인스턴스는 자신이 생성될 때 Compositor 서브클래스의 인스턴스를 얻고, 서식 설정이 필요할 때 Compositor 인스턴스에게 Compose() 연산을 호줄하여 서식 을 지정하게 합니다.
- Composition 클래스는 Glyph 클래스의 서브클래스이면서 다시 Glyph 클래스의 인스턴스를 집합 관계의 자식으로 포함합니다. 이 구조의 의미는,Composition 인스턴스는 Glyph의 인스턴스를 포함할 수도 있고, 또 다른 Composition 인스턴스를 포함 할 수도 있다는 것입니다. 서식이 없는 Composition 객체는 문서의 기본 내용을 복합하는 시각 효과 담당 글리프만 가지고 있습니다. 즉, 문서의 물리적 구조를 결정하는 Row와 Column 같은 글리프는 포함하지 않습니다. 이 Composition 객체는 현재 생성되었으며, 그와 동시에 자신이 직접 서식을 정해 주어야 하는 글리프들로 초기화된 상태입니다. Composition 객체는 서식을 설정할 때 Compositor 객체의 Compose() 연산을 호출합니다. 이후에 이 객체는 Composition 객체와 자식 관계에 있는 인스턴스를 라인 분리 알고리즘에 따라서 반복적으로 생성하면서 새로운 Row와 Column 글리프를 삽입합니다.
- 각 Compositor 클래스는 서로 다른 라인 분리 알고리즘을 구현합니다. 예를 들어, SimpleCompositor 클래스는 문서의 색깔과 같은 난해한 특성들에 상관없이 지나 갈 수 있고, 적당한 색깔의 의미는 텍스트와 공백이 균등하게 분산되었음을 의미합니다. TeXCompositor는 알고리즘을 모두 완전하게 구현하는 클래스입니다.
- 이렇게 Compositor-Composition으로 클래스를 구분해 두면, 문서의 물리적 구조와 다른 서식 설정 알고리즘을 지원하는 코드 사이를 확실히 구분할 수 있습니다. Glyph 클래스를 고치지 않고도 새로운 Compositor 서브클래스를 추가할 수 있고, Compositor 서브클래스를 고치지 않고 새로운 Glyph 클래스를 추가할 수도 있습니다. 클래스 분리는 문서의 물리적 구조를 지원하는 코드 및 다른 서식 설정 알고리즘을 위한 코드가 확실히 분리될 수 있도록 해 줍니다. 이외에, Composition 클래스의 기본 글리프 인터페이스에 SetCompositor() 연산을 추가함으로써 런타임에 라인 분리 알고리즘을 변경할 수 있습니다.

## 전략 패턴

- 알고리즘을 객체로 캡슐화하는 것. 이것이 전략 패턴의 의도입니다. 이 전략 패턴의 주요 참여자는 Strategy 패턴을 구현한 객체(서로 다른 알고리즘들을 캡슐화한)와 이 객체가 동작할 전후 관계, 즉 동작 환경(context)입니다. Compositor 클래스가 이 Strategy 클래스에 해당하고 이 클래스들이 서로 다른 서식 설정 알고리즘을 캡술화 합니다. Composition 클래스는 Compositor 클래스의 전략에 대한 Context 클래스에 해당합니다.
- 전략 패턴을 적용하는 데 가장 중요한 것은 전략과 동작 환경에 대한 인터페이스를 충분히 일반화해야 한다는 것입니다. 이로써 이들 일반화된 인터페이스가 어느 정도 범위의 알고리즘을 지원할 수 있어야 합니다. 새로운 알고리즘을 지원하기 위해서 전략이나 배경 인터페이스를 변경할 필요는 없습니다. 현재의 예를 보면 Glyph 클래스에 정의한 인터페이스는 자식을 읽고 쓰는 기능 및 삽입하며 삭제하는 기능을 지원합니다. 이 인터페이스를 통해서 Compositor의 서브클래스들은 문서의 물리적 구조를 변경할 수 있습니다. 이와 같이 Compositor 인터페이스는 서식 설정을 초기화할 때 필요한 것들을 모두 Composition 객체들에게 넘겨줍니다.

## 투명한 포함

- 프로그래밍 관점에서 볼 때, 사용자 인터페이스에 장식을 추가한다는 것은 결국 기존 코드의 확장이 필요하다는 뜻을 내포합니다. 그런 확장을 위해 상속을 사용하게 되면 런타임에 장식을 재배열하는 것을 사전에 막을 수 있지만, 상속기반 접근 방법을 사용할 때에 생기는 클래스 급증 문제도 가히 만만치 않게 됩니다.
- 그러니까 Composition 클래스를 상속하는 BorderedComposition 클래스로 테두리를 추가할 수 있을 것입니다. 또는, 동일한 방법으로 ScrollableComposition 서브클래스에 스크롤링 인터페이스를 추가해도 됩니다. 스크롤바와 테두리를 모두 원한다면 상속에 의해 BorderedScroUahleComposition 클래스를 만들면 됩니다. 이렇게 하면 모든 가능한 조합에 따라 클래스를 만들 수도 있습니다. 그러나 장식의 종류가 많아 질 때마다 클래스를 만드는 이런 해법은 언젠가는 더 이상의 확장을 불가능하게 합니다.
- 이럴 때는 `객체 합성`이 훨씬 더 유연한 확장 방법이 될 수 있습니다. 그러나 어떤 객체를 합성해야 할까요? 기존에 존재하는 글리프에 장식을 적용한다는 점은 기정사실이기 때문에(즉, 꾸밀 대상은 기존에 존재하는 글리프이므로), 장식 자체를 별도의 객체로 만들면 됩니다. 다시 말해, Border 클래스의 인스턴스로 기존 글리프들을 장식하면 됩니다. 이 과정을 통해서 복합할 수 있는 두 개의 후보가 생기게 됩니다. 하나는 글리프이고, 다른 하나는 테두리입니다. 이렇게 한 다음, 누가 누구를 포함할 것인지를 결정합니다. 실제 시용자 인터페이스를 보면 화면에 있는 글리프들을 테두리가 둘러싸고 있기 때문에 글리프를 테두리가 둘러싸게 만드는 쪽이 자연스러운 방법으로 보입니다. 그러나 정반대로도 할 수 있습니다. 즉, 테두리를 글리프 안에 넣는 것입니다. 이렇게 하면 테두리를 포함하는 Glyph 서브클래스를 변경해서 각각 의 클래스들이 테두리에 대해 알도록 해야 합니다. 여기서는 테두리가 글리프를 포함하도록 만드는 첫 번째 방법으로 갑니다. 이렇게 하면, 추가한 장식 클래스에 해당하는 Border 클래스에 테두리를 그리는 코드만 작성하는 것으로 간단히 정리되며, 다른 기존의 클래스는 변경하지 않아도 됩니다.
- Border 클래스는 어떻게 생겼을까요? 외관을 갖는 테두리도 개념적으로는 글리프의 일종이기 때문에 Border 클래스도 Glyph의 서브클래스여야 합니다. 이렇게 하는 중요한 이유는 테두리가 있는 그림인지 아닌지를 사용자가 글리프를 몰라도 사용할 수 있어야 하기 때문입니다. 사용자가 평범하고 테두리 없는 글리프에 그리라고 요청할 때면 테두리 장식 없이 기본 모양만 그려야 합니다. 글리프가 테두리에 포함 되어 있어도 사용자는 글리프를 포함하는 테두리를 전혀 다른 방법으로 다루어서는 안 됩니다. 단지, 이전의 평범한 글리프를 다룰 때처럼 복합 글리프에게 그리라고 말하면 됩니다. 다시 말해, 평범한 글리프이건 테두리를 포함한 글리프이건 동일하게 취급할 수 있어야 합니다. 즉, Border 인터페이스가 Glyph 인터페이스와 일치한 다는 뜻입니다. 이런 관계를 보장하기 위해 Border 클래스를 Glyph 클래스에서 상속 합니다.
- 지금까지의 것들을 모두 모아놓으면 투명한 포함(transparent enclosure) 개념을 끌 어낼 수 있습니다. 이는 (1)단일 자식(다른 말로 단일 구성요소)에 기반을 둔 합성과 (2) 호환되는 인터페이스의 개념을 조합한 것입니다. 사용자는 그들 자신이 단일 구성요소를 다루는지, 아니면 단일 구성요소를 포함하는 복합 객체를 다루는지 전혀 구분할 수 없습니다. 특히 포함한 것이 자신의 연산을 자신이 포함하는 구성요소에 위임할 때라면 더 구분하기 어렵습니다. 그러나 포함을 담당한 주체가 다른 구성요소에 연산 처리를 위임하기 전 또는 후에 자신의 행동을 수행하도록 하면, 그 구성요소의 행동을 확장할 수도 있게 됩니다. 이로써 무엇인가를 포함하는 복합 객체는 구성요소에 상태를 효과적으로 추가할 수 있습니다.

## 장식자 패턴

- 장식자 패턴은 '투명한 포함' 개념에 의해 장식을 지원하는 클래스와 포함되는 객체들 사이의 관계를 잡아낸 것입니다. 장식이라는 용어는 지금까지 언급해 왔던 것에 비해 더 넓은 의미를 지닙니다. 장식자 패턴에서 '장식'은, 객체에 추가할 수 있는 모든 책임에 해당합니다. 장식에 해당하는 예로는, 처리부를 갖는 추상 구문 트리, 새로운 상태 전이를 갖는 유한 상태 오토마타(finite state automata), 속성 태그를 갖는 영속적 객체망 등이 있는데, 이것은 기본 객체에 추가적인 책임이 부여된 예들 입니다. 장식자 패턴은 Lexi에 사용했던 방식을 좀더 넓은 범위에서 사용할 수 있도 록 해 줍니다.

## 추상 팩토리 패턴

- 추상 팩토리 패턴의 참가 객체는 팩토리와 제품입니다. 이 패턴은 클래스의 인스턴스를 직접 만들지 않고서도 관련된 제품 객체의 군을 생성하는 방법을 정의합니다. 제품 객체의 종류(예를 들어, 버튼, 박스,스크롤바 등)는 일정하고, 각 객체의 특성이 특정 제품군마다 차이를 보일 때 매우 좋은 방법입니다. 어떤 특정 팩토리를 지정하여 이를 통해서 제품을 생성하게 하는 방법으로 원하는 제품을 선택합니다. 팩토리의 인스턴스만 바꾸면 전체 제품군을 바꿀 수 있습니다. 추상 팩토리 패턴은 동일 계열의 제품군을 다룰 수 있다는 점에서 다른 생성 패턴과 다릅니다. 다른 생성 패턴은 한 종류의 제품 객체만 상대할 수 있기 때문입니다.

## 가교 패턴

- 서로 독립적으로 확장되지만 함께 동작해야 하는 개념들을 별도의 클래스 계층으로 분리하는 것이 가교 패턴의 목적입니다. 이렇게 두 개의 계층으로 분리할 때는 두 가지의 기준을 세워야 합니다. 하나는 논리적 개념에 해당하는 윈도우이고, 다른 하나는 그 윈도우에 대한 서로 다른 물리적 구현입니다. 가교 패턴을 적용하면, 윈도우 시스템에 종속적인 구현과 전혀 상관없이 논리적인 윈도우 추상화를 확장할 수 있고, 형ㅈ그 반대로 추상적 개념과 무관하게 새로운 윈도우 시스템의 구현도 추가할 수 있습니다.

## 명령 패턴

- 명령 패턴은 요청을 어떻게 캡슐화하는지 설명하는 패턴입니다. 명령 패턴은 요청을 발생시키는 데 필요한 균일한 인터페이스를 규정해 주기 때문에, 사용자 쪽에서는 서로 다른 요청을 동일하게 처리할 수 있습니다. 명령 패턴으로 만들어진 인터페이스는 요청 처리의 구현 내용 을 시용자에게 숨깁니다. 하나의 명령(객체)은 요청의 구현을 전부 또는 일부 다른 객체에 위임할 수 있고, 전혀 위임하지 않고 자신이 처리할 수도 있습니다. 이런 특성은 Lexi처럼 여러 부분에 흩어진 기능을 한곳에 집중하여 접근할 수 있도록 해야 하는 응용프로그램에서는 완벽한 해법이 될 수 있습니다. 또한, 이 패턴에는 취소와 재실행을 처리하는 인터페이스를 추가할 수도 있습니다.

## 반복자 패턴

- 반복자 패턴은 객체 구조에 대한 접근 및 순회 방법을 지원하기 위한 기법을 잡아낸 패턴입니다. 이 패턴은 복합 구조뿐 아니라 컬렉션에도 잘 응용할 수 있습니다. 순회 알고리즘을 추상화하기 때문에, 사용자는 자신이 순회하는 객체의 내부 표현 구조를 알 필요가 없습니다. 반복자 패턴은 다양화될 수 있는 개념들을 캡슐화하면 어떻게 유연성과 재사용성 혜택을 취할 수 있는지 다시 한 번 여실히 보여주는 예입니다. 사실 반복 처리의 문제는 놀랄 만큼 깊고 복잡하며, 반복자 패턴에는 여기서 짚어 본 부분보다 훨씬 더 많은 양자택일의 요건들과 미묘한 의미들이 내포되어 있습니다.

## 방문자 패턴

- Visitor 패턴은 Glyph 클래스의 변경 없이도 추가 가능성을 내포한 글리프 구조 분석을 가능하게 하려고 사용한 기법을 잡아낸 것입니다. 이 패턴의 또 다른 매력적인 특징은 꼭 복합 객체에만 적용할 수 있는 것이 아니라 모든 구조에 다 적용할 수 있다는 점입니다. 집합,리스트 심지어는 그래프에도 적용할 수 있습니다. 방문자가 방문하는 클래스들이 꼭 동일한 부모 클래스를 가질 필요도 없습니다. 이 말은 Visitor 객체가 방문할 클래스 계층이 서로 달라도 돌아갈 수 있다는 뜻입니다.
- 방문자 패턴을 사용하기 전에 반드시 확인해야 하는 부분이 하나 있습니다. 가장 자주 변경되는 클래스 계층이 무엇인가 하는 것입니다. 구조 클래스 구조가 안정된 상태에서 객체에게 여러 가지 일을 많이 시키고 싶다면 방문자 패턴을 사용하는 것이 좋습니다. 새로운 종류의 Vister 클래스를 추가하더라도 기존 클래스 구조는 변하지 않을 텐데요, 이 부분은 특히 클래스 구조가 클 때 더욱 중요합니다. 그러나 기존 클래스 구조에 새로운 (서브)클래스가 추가되면 반드시 Visitor 클래스에 Visit...() 연산을 추가해야 한다는 것을 잊지 말아야 합니다. 한 예로,Foo를 Glyph 서브 클래스로 추가한다면 Visitor 클래스에 VisitFoo() 연산을 추가해야 합니다. 우리가 Lexi에 추가하고 싶은 것은 새로운 종류의 Glyph가 아니라, 새로운 종류의 분석 기법입니다. 방문자 패턴은 이러한 목적에 잘 맞는 패턴입니다.

## 요약

1. 문서의 물리적 구조를 표현하기 위한 복합체 패턴
2. 서로 다른 서식 설정 알고리즘을 위한 전략패턴
3. 사용자 인터페이스를 꾸미기 위한 장식자 패턴
4. 여러 개의 룩앤필 표준을 지원하기 위한 추상 팩토리 패턴
5. 여러 개의 윈도우 플랫폼을 허용하기 위한 가교 패턴
6. 취소 가능한 사용자 연산을 위한 명령 패턴
7. 객체 구조를 접근하고 순회하기 위한 반복자 패턴
8. 문서 구조의 구현을 복잡하게 하지 않고 다수의 분석 기능을 제공하기 위한 방문자 패턴
