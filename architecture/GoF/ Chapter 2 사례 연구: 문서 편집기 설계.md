# Chapter 2 사례 연구: 문서 편집기 설계

- 이번 장에서는 위지윅(WYSIWYG: What You See Is What You Get, 눈에 보이는 대로 출력됨) 방식의 문서 편집기 Lexi를 설계하는 사례 연구를 소개합니다. Lexi 및 이와 비슷한 응용프로그램 설계 문제에 디자인 패턴이 어떤 해법을 제시하는지 살펴보고자 하는 것입니다. 예제를 보며 이번 장의 끝부분까지 잘 따라왔다면 여덟개의 패턴에 대한 경험을 얻게 될 것입니다. 위지윅 방식의 편집기가 보여주는 문서는 대개 중앙에 커다란 사각형 영역으로 나타납니다. 문서는 다양한 서식 설정이 가능하며 문자와 그래픽을 마음대로 섞을 수 있습니다. 풀다운 메뉴와 스크롤바가 문서 주변을 둘러싸고 있고, 문서의 특정 페이지로 이동하게 하는 페이지 아이콘 모음이 있습니다.

## 2.1 설계문제들

- Lexi 설계에 들어가는 일곱 가지 현안들을 살펴봅시다.
  - 1. `문서 구조.` 문서의 내부를 어떻게 표현할 것인지는 Lexi 설계의 모든 측면에 영향을 줍니다. 편집, 서식 설정, 화면 표시, 텍스트 분석 등을 구현하려면 이 문서 표현 구조를 종횡무진 훌어가야 합니다. 이 문서 정보를 어떻게 구성 할 것인가에 따라 프로그램의 나머지 설계도 크게 달라질 것입니다.
  - 2. `서식 설정.` Lexi는 실제로 문자와 그래픽을 행과 열로 어떻게 정렬할까요? 여러 가지 서식화 정책을 처리할 책임은 어떤 객체가 가져야 할까요? 이런 방침들이 문서의 내부 표현과 어떻게 상호작용할 수 있을까요?
  - 3. `사용자 인터페이스 꾸미기.` Lexi의 사용자 인터페이스는 스크롤바, 테두리, 음영 등의 장식 요소들을 포함합니다. 이런 장식은 Lexi의 사용자 인터페이스가 진화하면 쉽게 바뀝니다. 그러므로 나머지 응용프로그램을 중단하지 않고 장식을 쉽게 추가하고 제거할 수 있어야 합니다.
  - 4. `여러 룩앤필(look and feel) 표준의 지원.` Lexi는 심각한 수정 없이 모티프(Motif)와 프레젠테이션 매니저(Presentation Manager:PM) 같은 다른 룩앤필 표준을 쉽게 지원할 수 있어야 합니다.
  - 5. `여러 윈도우 시스템의 지원.` 일반적으로 특정한 룩앤필 표준은 특정한 윈도우 시스템에서 구현됩니다. 그러므로 Lexi의 설계는 가급적 윈도우 시스템에 독립적이어야 합니다.
  - 6. `사용자 조작.` 사용자는 버튼이나 풀다운 메뉴 등 사용자 인터페이스를 사용해서 Lexi를 제어합니다. 이 인터페이스에 숨겨진 실제 응용프로그램의 기능은 응용프로그램을 구성하는 전체 객체에 분산됩니다. 그러므로 분산된 기능에 접근하거나 이 기능 수행의 영향을 취소하는 데에 동일한 방법을 쓸 수 있도록 해야 합니다.
  - 7. `철자 검사와 붙임표 처리.` 어떻게 Lexi가 단어 검사와 붙임표(hyphen) 결정과 같은 분석 연산을 처리할 수 있을까요? 새로운 분석 연산을 추가할 때도 수정 또는 추가할 연산의 개수를 어떻게 최소화할 수 있을까요?

## 2.2 문서 구조

- 문서는 문자, 선, 다각형 등 기본적인 그래픽 요소를 단순히 배열한 것입니다. 이런 요소들을 통해서 문서의 전체 내용을 정의할 수 있게 됩니다. 그러나 설계자는 종종 이런 요소를 그래픽 요소로 보지 않고 각각 행, 열, 그림, 표, 아니면 다른 형태의 하위 구조 등의 물리적 구조로 봅니다. 또한 이 하위 구조는 또 다른 하위 구조를 포함할 수 있습니다.
- Lexi의 사용자 인터페이스는 사용자가 이들 하위 구조를 직접 다룰 수 있어야 합니다. 예를 들어, 시용자는 다이어그램을 하나의 단위로 다루어야 하며, 이 다이어그램을 개별적 그래픽 요소들이 모인 집합체로 생각해서는 안 됩니다.
- 또한 테이블을 하나로 조작할 수 있어야지, 테이블을 텍스트와 그래픽 요소들이 대량으로 모인 것으로 보면 안 됩니다. 이렇게 해야 인터페이스를 직관적이고 간단하게 만들 수 있습니다. Lexi의 구현에 비슷한 품질을 부여하려면 문서의 물리적 구조에 부합하는 내부 표현을 선택합니다.
- 우선적으로, 본 편집기의 내부 표현은 다음 열거한 항목을 지원해야 합니다.
  - 문서의 물리적 구조 유지 기능 : 이 물리적 구조란 문자와 그래픽, 행, 열, 테이블, 기타 것들의 정렬을 의미합니다.
  - 문서를 시각적으로 생성하고 표현하는 부분
  - 내부 표현 영역의 요소들과 화면에 표시된 요소들을 사상(寫像)하는 부분 : 이것이 있어야 사용자가 시각적 표현에 있는 무엇인가를 선택할 때 사용자가 어떤 요소를 가리킨 것인지를 Lexi가 결정할 수 있습니다.
- 이들 목표를 축으로 해서, 부가적으로 제약 사항 몇개가 추가됩니다. 첫째, 문자와 그래픽을 동일하게 다뤄야 합니다. 본 편집기의 인터페이스는 사용자가 그림 안에 문자를 넣거나 문자 안에 그림을 넣을 수 있게 합니다. 그러므로 그림을 텍스트의 특별한 경우로 처리하거나 텍스트를 그림의 특별한 경우로 처리해서는 안 됩니다. 서로를 서로의 특별한 경우로 처리한다면, 텍스트와 그림을 모두 처리하는 데에 작업이 중복됩니다. 따라서 서식을 맞추거나 조작 기법을 한 번만 정의해서 문자와 그래픽 모두를 처리할 수 있어야 합니다.
- 둘째, 단일 요소와 그룹 요소를 구분해서 구현하면 안 됩니다. Lexi는 단일 요소와 복합 요소를 동일하게 다룰 수 있어야만 임의의 복잡한 문서를 다룰 수 있습니다. 예를 들어, 2열 5번째 행 10번째 요소가 하나의 문자일 수도 있고, 수많은 하위 요소를 갖는 복잡한 다이어그램일 수도 있습니다. 이 요소는 스스로 자신을 그리고 차원을 표시할 수 있는 대상이지, 그것이 복잡하다고 해서 폐이지의 어디에 나타낼까, 어떻게 보이게 할까에 대한 추가 부담을 가질 필요는 없습니다.
- 허나, 철자법 검사와 붙임표 연결 지점 같은 처리를 하기 위한 텍스트 분석은 필요합니다. 두 번째 제약 사항에 반대되는 입장입니다. 선이 단순 객체인지 복합 객체인지에 대한 고려는 하지 않으려고 합니다. 그러나 가끔은 분석 대상에 따라서 분석 방법이 달라져야 합니다. 즉, 다각형의 철자 검사를 하거나 다각형을 붙임표로 연결 한다는 것은 이상한 일입니다. 그러므로 내부 표현을 설계할 때는 이러한 사항들 간의 충돌을 고려해야 합니다. 다시 말해, 어떤 때는 모든 요소들을 서로 동일하게 다루어야 하고, 어떤 때는 서로 구분해서 처리해야 합니다.

### 재귀적 합성

- 계층적으로 구조화된 정보를 보여주는 가장 일반적인 방법으로 재귀적 합성(recursive composition) 기법이 있습니다. 이 기법을 이용하면 단순한 것에서 복잡한 것을 점진적으로 만들어 낼수 있습니다. 쉽게 말해, 재귀적 합성은 간단한 그래픽 요소들을 복합하여 문서를 만드는 방법입니다. 첫 단계에서 문서에 있는 한 행(row)의 왼쪽에서 오른쪽으로 글자들과 그래픽들을 채웁니다. 그러면 여러 선들이 하나의 열(column)을 만들게 되고, 다수의 열이 하나의 페이지를 만듭니다.
- 물리적 구조를 표현하는 데 있어서, 각각의 주요 요소를 모두 객체로 만들어 구현할 수 있습니다. 이렇게 하면 글자나 그래픽과 같은 시각적 요소뿐만 아니라 보이지 않는 구조적 요소(선, 열 등)도 포함할 수 있습니다.
- 문서에 정의할 글자와 그래픽 요소를 객체화하면 Lexi 설계의 유연성을 늘릴 수 있게 됩니다. 이제는 문자와 그래픽 모두를 바라보는 방법이 같아집니다. 즉, 화면에 표시하고 서식을 지정할 수 있으며 다른 것들 안에 포함될 수 있는 대상으로 동일시 합니다. 이렇게 함으로써 다른 기능에 영향을 주지 않고 새 글자를 추가할 수도 있습니다. Lexi의 객체 구조는 문서의 물리적 구조를 그대로 따르게 됩니다.
- 이 접근법에는 두 가지 중요한 의미가 내포되어 있습니다. 첫째, 각 객체에 대응하는 클래스가 필요합니다. 둘째, 이 클래스는 객체들을 일관되게 다루기 위해 호환성을 갖는 인터페이스를 정의해야 합니다. 그러나 두 번째 사항은 확정적인 것은 아닙니다. C++와 같은 언어에서 인터페이스를 호환성 있게 만드는 방법은 관련된 클래스들을 상속을 통해 묶는 것인데, 그러면 부모 클래스에 공통의 인터페이스를 정의할 수 있습니다.

### 글리프

- 화면에 표시되는 구성요소를 포괄적으로 일컫는 개념인 글리프(glyph)는, 본 편집기의 문서 구조에서 나타낼 수 있는 모든 객체를 위한 추상 클래스인 Glyph로 정의하려 합니다. 글리프의 서브클래스는 기본적인 그래픽 요소(문자와 이미지 같은)와 구조 적 요소(행과 열 같은)를 정의합니다.
- 글리프는 세 가지의 기본적인 책임을 맡고 있습니다.
  - (1) 어떻게 자기 자신을 그리는 지에 대한 부분
  - (2) 차지하는 영역이 얼마나 되는지에 대한 부분
  - (3) 자신의 자식들과 부모가 누구인지를 가리키거나 참조하는 부분입니다.
- 글리프의 서브클래스는 Draw() 연산을 재정의해서 윈도우에 자신을 그립니다.
- Draw () 연산의 호출이 일어날 때 Window 객체에 대한 참조자를 전달받습니다. Window 클래스는 스크린의 윈도우에 텍스트와 기본 도형을 표현하기 위한 그래픽 연산을 정의합니다. Glyph의 서브클래스인 Rectangle 클래스는 다음과 같이 Draw (〉 연산을 재정의합니다.

```c++
void Rectangle::Draw (Window* w) {
  // Window 객체에 대한 참조자 * w를 매개변수로 전달받음
  w->DrawRect (_x0, _y0, _x1, _y1);
}
```

- \_x0, \_Y0, \_x1과 \_y1 은 Rectangle의 멤버 변수로 정의되어 사각형의 대각 위치 에 있는 양 모서리의 좌표를 나타냅니다. DrawRect() 연산은 직사각형을 화면에 그리는 윈도우 연산입니다.
