# 함수형사고


## 왜

- 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕습니다(마이클 페더스)
- 함수형 언어는 가변 상태를 제어하는 메커니즘을 구축하기 보다, 움직이는 부분을 아예 제거하는 데 주력합니다.
- 객체지향 명령어 프로그래밍 언어에서, 재사용의 단위는 클래스와 그 클래스들이 주고받는 통신 메시지이고, 이는 클래스 다이어그램으로 포착 할 수 있습니다. OOP의 세계에서는 고유한 자료구조를 작성하는 것을 권장합니다. 그 자료구조에 특정 동작을 메서드의 형태로 부착해서 사용합니다.
- 함수형 프로그래밍 언어는 같은 방식으로 재상용을 달성하려 하지 않고, 최적화 된 동작으로 몇몇 자료구조(list, set, map)를 이용하는 방식의 재사용을 선호 합니다. 개발자가 이런 방법을 잘 사용하려면, 특정 용도로 정의된 방법에 자료구조와 고계함수를 함께 넣어야 합니다.
- 함수 수준의 캡슐화는, 모든 문제에 대한 새로운 클래스 구조를 구축하는 것보다 세분화되고 기초적인 수준에서 재사용을 가능하게 합니다.
- 함수형 개발자는 적은 수의 자료구조와 그것들을 잘 이해하기 위한 최적화 된 방법을 만들기를 선호한다.

## 전환

- 함수형 코드를 작성하기 위해서는, 함수형 언어인 스칼라나 클로저로의 전환이 필요한 것이 아니라 문제에 접근하는 방식의 전환이 필요하다.
- 함수형 프로그래밍은, 복잡한 최적화는 런타임에게 맡기고 개발자가 좀 더 추상화 된 수준에서 코드를 작성할 수 있게 함으로써, 알고리즘 측면에서 가비지 컬력션과 동일한 역할을 수행할 것입니다. 개발자들은 가비지 컬렉션에서 얻었던 것같이 복잡성이 낮아지고 성능이 높아지는 혜택을 받게 될 것입니다.
- 명령형 프로그램이란 상태를 변형하는 일련의 명령들로 구성 된 프로그래밍 방식을 말한다. 전형적인 for 루프가 명령형 프로그래밍의 훌륭한 예이다.
- 함수형 프로그래밍은 프로그램을 수학 공식을 모델링하는 표현과 변형으로 기술하며, 가변 상태를 지양한다.
- 함수형 사고로의 전환은, 어떤 경우에 세부적인 구현에 뛰어들지 않고 이런 고수준 추상 개념을 적용할지를 배우는 것입니다.
  - 문제의 공통점을 고려하여 다른 방식으로 분류하기를 권장한다는 것입니다.
  - 런타임이 최적화를 잘할 수 있도록 해준다는 것입니다. 어떤 경우에서는, 결과가 변하지 않는 한, 작업 순서를 바꾸면 더 능률적이 됩니다.
  - 개발자가 엔진 세부사항에 깊이 파묻힐 경우 불가능한 해답을 가능하게 합니다.
- 절차보다는 결과에 집중해야 합니다.
- 고수준의 추상화는 마찰을 없애 줍니다.
- 불필요한 마찰을 더하지 말아야 합니다.
- 함수형 프로그래밍은 매개변수와 합성에 크게 의존하므로 움직이는 부분 사이의 상호작용에 대한 규칙이 많지 않고, 따라서 개발자의 작업을 쉽게 해줍니다.
- 새로운 어휘를 배우는 것이 함수형 프로그래밍 같은 새로운 패러다임을 배우는 과정에서의 어려운 점 중 하나입니다. 여러 커뮤니티에서 다른 어휘를 사용하는 바람에 이것이 더욱 어려워졌습니다. 하지만 일단 그것들의 유사성을 터득하면 문법적으로 놀랍게도 함수형 언어들이 중복되는 기능을 지원한다는 것을 깨달을 것입니다.

## 양도하라

- 함수형 언어의 기능들은 10년 전만 해도 사용할 수 없을 만큼 느렸지만, 지금은 그것들이 개발자의 시간과 노력을 최적화 할 수 있게 해주므로 충분히 사용할만 합니다.
- 가비지 컬렉션 같은 저수준 세부사항의 조작을 런타임에 양도함으로써 찾아야 할 수많은 오류를 방지해주는 능력이야말로 함수형 사고의 가치라고 할 수 있습니다.
- 사용하는 추상화 단계보다 한 단계 아래를 이해하라.
- 클로저는 함수형 언어나 프레임워크에서 코드 블록을 다양한 상황에서 실행하게 해주는 메커니즘으로 많이 쓰입니다.
- 언어로 하여금 상태를 관리하게 해야합니다.
- 클로저는 지연 실행(deferred execution)의 좋은 예입니다.
- 상태 대신 문맥을 잡아야 합니다.
  - 명령형 어어는 상태로 프로그래밍 모델을 만듭니다.
  - 클로저는 코드와 문맥을 한 구조로 캡슐화해서 행위의 모델을 만들 수 있게 해줍니다.
- 커링은 다인수 함수를 일인수 함수들의 체인으로 바꿔주는 방법입니다.
- 부분 적용은 주어진 다인수 함수를 생략될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법입니다.
- 커링(또는 부분 적용)은 전통적인 객체 지향 언어에서 팩토리 함수를 구현할 상황에서 사용하면 좋습니다.
- 재귀는 상태 관리를 런타임에 양도할 수 있게 해줍니다.
- 가비지 컬렉션처럼 대단한 발전은 아니지만 재귀는 프로그래밍 언어의 중요한 흐름을 조명해 줍니다. 우직이는 부분의 관리를 런타임에 양도하는 것입니다. 개발자가 중간 값을 건드리지 못하게 하면 결국 그로 인한 오류도 생기지 않을 것입니다.
- 스택 증가는 재귀가 좀 더 보편화되지 못한 주된 이유 중 하나 입니다. 재귀는 보통 중간 값을 스택에 보관하게끔 구현되는데, 재귀에 최적화 되지 언어에서는 스택 오버플로를 유발하게 됩니다. 스칼라나 클러저 같은 언어들은 이 제약을 몇가지 방법으로 우회 합니다.
  - 개발자가 런타임이 이 문제를 해결하는데 도움을 줄 수있는 방법 중 하나는 꼬리 호출 최적화 입니다.
- 함수형 언어들은 깔끔한 구문과 지원을 통해 재귀를 간단한 코드 재활용의 도구로 사용할 수 있게 합니다.
- 명령형에서 함수형 스타일로 바꾸면 얻는 것중 의 하나가 런타임이 효율적인 결정을 할 수 있게 된다는 점입니다.

## 열심히보다는 현명하게

- 메모이제이션은 연속해서 사용되는 연산 값을 함수 레벨에서 캐시하는 것을 지칭하는 것으로 처음 사용되었습니다. 시간이 많이 걸리는 연산을 반복적으로 사용해야 할때 유용합니다.
- 메모이제이션은 프로그래밍 언어에 내장되어 반복되는 함수의 리턴 값을 자동으로 캐싱해주는 기능입니다.
- 언어의 설계자들은 반드시 규칙을 지킬 필요가 없기 때문에 그들이 만든 메커니즘이 항상 더 효율적입니다.
- 메모아지즈된 함수는 부수효과가 없어야하고 외부 정보에 절대로 의존하지 말아야 합니다.
- 개발자가 스칼라나 클로저 같은 함수형 언어에 관심이 없다고 해도, 개발자가 사용하는 언어가 진화하면서 함수형 프로그래밍은 자연스럽게 그들의 세계로 발을 들여 놓을 것입니다.
- 표현의 평가를 가능한 최대한 늦추는 기법인 게으른 평가는 함수형 프로그래밍 언어에서 많이 볼수 있는 기능입니다. 게으른 컬렉션은 그 요소들을 한꺼번에 미리 연산을 하는 것이 아니라, 필요에 따라 하나씩 전달해 줍니다.
  - 시간이 많이 걸리는 연산을 반드시 필요할 때까지 미룰 수 있게 됩니다.
  - 요청이 계속되는 한 요소를 계속 전달하는 무한 컬렉션을 만들 수 있습니다.
  - 맵이나 필터 같은 개념을 게으르게 사용하면 효율이 높은 코드를 만들 수 있습니다.
- 게으른 목록은 몇가지 이점이 있습니다.
  - 무한 수열을 만들 수 있습니다.
  - 저장 시 크기가 줄어듭니다.
  - 런타임이 좀더 효율적인 코드를 만들 수 있다는 점입니다.

## 진화하라

- 함수형 언어에서의 코드 재사용은 객체지향 언어와는 접근 방법이 다릅니다.
  - 객체지향 언어는 주로 수많은 자료구조와 거기에 딸린 수많은 연산을 포함합니다.
  - 함수형 언어에서는 적은 수의 자료구조와 많은 연산들이 있기 마련입니다.
  - 객체지향 언어는 클래스에 종속된 메서드를 만드는 것을 권장하여 반복되는 패턴을 재사용하려 합니다.
  - 함수형 언어는 자료구조에 대해 공통된 변형 연산을 적용하고, 특정 경우에 맞춰서 주어진 함수를 사용하여 작업을 커스터마이즈함으로써 재상요을 장려합니다.
- 100개의 함수를 하나의 자료 구조에 적용하는 것이 10개의 함수를 10개의 자료구조에 적용하는 것보다 낫습니다.
- 함수 수준에서 캡슐화하면 커스텀 클래스 구조를 만드는 것보다 좀 더 세밀하고 기본적인 수준에서 재사용이 가능해 집니다.
- 문제를 프로그램에 맞추지 말고, 프로그램을 문제에 맞게끔 조정해가야 합니다.
- 함수형 언어의 공통적인 기능은 연산자 오버로딩입니다.
- 새로운 언어을 만들지 말고 ,연산자 오버로딩을 통해 문제 도메인을 향하여 언어를 구부리자.
- 예외는 많은 함수형 언어가 준수하는 전제 몇 가지를 깨뜨립니다.
  - 함수형 언어는 부수효과가 없는 순수함수를 선호합니다.
  - 참조 투명성을 깨드립니다.
- 함수형 언어에서는 다른 두 값을 리턴해야 하는 경우가 종종 있는데 그런 행동을 모델링하는 자료구조가 Either 클래스입니다. Either는 왼쪽 또는 오른쪽 값 중 하나만 가질 수 있게 설계 되었습니다. 이런 자료구조를 분리합집합이라고 합니다. 함수형의 보편적인 관례에 따라 Either 클래스의 왼쪽이 예외 오른쪽이 결과 값입니다.
- 메서드의 결과는 답이든 Either의 값을 푸는 한 단계의 우회만 거치면 얻어집니다. 이런 우회 덕분에 게으름을 구현하는 것이 가능해집니다.
- Either를 예외 처리에 사용하여 얻는 이점은 게으름만이 아니라 디폴트 값을 제공한다는 것이 다른 이점 입니다.

## 전진하라

- 함수형 언어계의 어떤 이들은 디자인 패턴이 개념 자체에 결함이 있기 때문에 함수형 프로그래밍에서는 필요가 없다고 주장합니다. 패턴의 좁은 정의만 볼 때에는 일리가 있는 말입니다. 하지만 그런 주장은 패턴의 사용보다는 의미론에 국한된 것입니다.
- 함수형 프로그래밍에서는 전통적인 디자인 패턴들이 다음과 같은 세 가지로 나타납니다.
  - 패턴이 언어에 흡수됩니다.
  - 패턴 해법이 함수형 패러다임에도 존재하지만, 구체적인 구현 방식이 다릅니다.
  - 해법이 다른 언어나 패러다임에 없는 기능으로 구현됩니다.
- 합성(주어진 매개변수와 일급 함수들의 형태로 이루어집니다)은 함수형 프로그래밍 라이브러리에서 재사용의 방식으로 주로 사용됩니다.
- 함수형 언어들은 객체지향 언어들보다 더 큰 단위로 재사용합니다.
- 함수형 프래그래밍은 구조물들 간에 잘 알려진 관계(커플링)를 만들기보다는, 큰 단위의 재상용 메커니즘을 추출하려 합니다. 이런 노력은 객체 간의 관계(모피즘)를 규정하는 수학의 한 분야인 카테고리 이론에 근거를 둡니다.
- 함수형 언어들은 일급 함수(언어의 다른 구조물들이 사용되는 모든 곳에서 사용될 수 있는 함수)를 매개변수나 리턴 값으로 사용합니다.
- 전통적인 디자인패턴을 사용하는 객체지향의 관점에서 볼 때는 클래스나 메서드를 만들어서 문제를 푸는 방식이 더 편해 보일 수도 있습니다. 하지만 함수형 언어들은 어떤 토대나 보일러플레이트를 사용하지 않고도 같은 결과를 얻을 수 있게 해줍니다.
- 일급 함수를 사용하면 불필요한 구조물들을 없앨 수 있기 때문에 템플릿 메서드 디자인 패턴을 구현하기가 쉬워집니다.
- 고계함수가 있기 때문에 명령 패턴이나 템플릿 패턴 같은 고전적인 패턴에서 자주 사용되는 보일러플레이트 코드가 필요 없어 집니다.
- 일급 함수의 사용으로 간편해진 디자인 패턴으로는 전략 패턴을 들 수 있습니다. 전략 패턴은 각자 캡슐화 되어 서로 교환 가능한 알고리즘 군을 정의합니다. 이것은 클라이언트에 상관없이 알고리즘을 바꿔서 사용할 수 있게 해주는 패턴 입니다.
- 디자인 패턴은 언어나 런타임에 흡수 될 수 있습니다.
- 패턴들은 그 의미를 보존하면서 다른 방법으로 구현될 수 있습니다.
- 함수형 언어와 런타임은 전적으로 다른 기능을 가질 수 있고, 그것들을 사용하면 같은 문제라도 완전히 다른 방식으로 풀어나갈 수 있습니다.

## 실용적 사고

- 모든 함수형 언어는 다양한 웹 프레임워크를 가지고 있습니다. 이들의 공통적인 특성은 다음과 같습니다.
  - 경로 설정 프레임워크
  - 함수를 목적지로 사용
  - 도메인 특화 언어
  - 빌드 도구와의 밀접한 연동

## 폴리글랏과 폴리패러다임

- 멀티패러다임 언어는 개발자가 각 패러다임을 적재적소에 사용할 수 있다는 엄청난 이점이 있습니다. 하지만, 개발자들이 큰 프로젝트에 임할 때는 멀티패러다임 언어를 조심해서 사용해야 합니다. 언어가 다양한 추상화와 철학을 반영하기 때문에 작은 개발자 그룹이 서로 전혀 다른 라이브러리를 만들 수 있습니다.
- 모든 개발자는 같은 목표를 향해 일할 수 있어야 한다는 엔지니어링 철학에 따르면 문제를 해결 할 수 있습니다. 유닛 테스팅을 하면 메타프로그래밍을 통한 복잡한 확장 구조를 정확하게 이해할 수 있습니다. 소비자 주도 계약 같은 기법을 사용하면, 팀 간의 실행 가능한 계약을 테스트 할 수 있습니다.
- 문맥 위주의 시스템은 토대, 곧바로 사용할 수 있는 방식, 토대를 이용한 문맥의 이해를 제공합니다. 따라서 문맥 위주의 시스템은 사용 시 어려움을 줄여줍니다. 이런 시스템에서는 커다란 전역 자료구조가 상속 구조 뒤에 숨어 있어서, 거기서 파생 된 확장이 상위 구조를 통해 커다란 모습으로 나타나는 경우가 있습니다. 합성 위주의 시스템은 묵시적인 방식이 적고, 초기 사용이 그리 용이하지는 않지만, 좀 더 세밀한 빌딩 블록을 제공하므로 결국은 더 유용하게 됩니다. 제대로 설계된 합성 위주의 시스템은 캡슐화 된 모듈 내부에서 좁은 의미의 국지적 문맥을 제공합니다.
- 합성 위주의 도구가 문맥 위주의 도구보다 시간, 복잡성, 유용성 등에서 스케일 하기 더 쉽다느 것으 경험으로 알 수 있습니다.
- 컴퓨터 언어 종류는 주로 두 축을 기준으로 나눌 수 있습니다.
  - 강한 타이핑 또는 약한 타이핑
  - 동적 타이핑 또는 정적 타이핑
- 명령형 언어는 상태 변화를 쉽게 하기 위한 많은 기능을 탑재합니다.
- 함수형 언어는 가변 상태를 최소화하고 좀 더 범용화 된 기계 장치를 구축하려 합니다.
- 함수형이 타이핑 시스템을 좌우하지는 않습니다.
- 불변성에 의존하는가에 따라서, 언어들의 주요 차별점은 동적이냐 정적이냐가 아니고 명령형이냐 함수형이냐입니다. 이것은 소프트웨어를 만드는 방법에 흥미로운 영향을 줍니다.
- 폴리그랏이란 현대식 런타임을 사용하여 플랫폼은 바꾸지 않고 여러 언어를 적절하게 섞어서 사용하여 애플리케이션을 만드는 것을 의미한다는 것입니다.
- 함수형 스타일로 갈아타는 것은 단지 새로운 문법을 배우는 것 이상의 큰 전환이지만, 아주 이롭고 중대한 효과를 볼 수 있을 것입니다.
