
# HTTPS에 대한 기초 이해

## HTTP의 약점
- 평문(암호화하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능
- 평문이기 때문에 도청 가능

## HTTPS는 SSL의 껍질을 덮어쓴 HTTP
HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아닙니다. HTTP 통신을 하는 소켓 부분을 SSL이나 TSL이라는 프로토콜로 대체하고 있을 뿐입니다.  
보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용하는 경우에는 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 됩니다. 즉 SSL이라는 껍질을 덮어쓴 HTTP가 HTTPS인 것입니다.  

## SSL 인증서
- 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.
- SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

## SSL 인증서의 내용
- 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
- 서버 측 공개키 (공개키의 내용, 공개키의 암화 방법)

## SSL 인증서가 서비스를 보증하는 방법
- 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제겅한다.
- 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스테 있는 지 확인한다.
- 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.
- 비밀키로 암호화한 정보를 공개키로 복호화할 수 있다는 것은 그 정보가 틀림 없이 쌍으로 존재하는 것이다. 즉 정보의 출저(접속한 사이트)를 신뢰할 수 있다.

## SSL의 동작방법
- SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다. 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.
- 공개키 방식은 컴퓨터의 성능을 많이 들기 때문에 두 가지 방식을 혼합해서 사용한다.
  - 실제 데이터: 대칭키
  - 대칭키의 키: 공개키

## HTTPS 흐름
1. 클라이언트가 Client Hello 메시지를 송신하면서 SSL 통신을 시작합니다. 메시지에는 클라이언트가 제공하는 SSL 버전을 지정하고, 암호 스위트(Cipher Suite)로 불리는 리스트(사용하는 암호화 알고리즘이나 키 사이즈 등)이 포함되어 있습니다.
1. 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답합니다. 클라이언트와 같이 SSL 버전과 암호 스위트를 포합합니다. 서버의 암호 스위스트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것입니다.
1. 서버가 Ceriticate 메시지를 송신합니다. 메시지에는 공개키 증명서가 포함되어 있습니다.
1. 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시사에션 부분이 끝났음을 통지합니다.
1. SSL의 최초 네고세이션이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답합니다. 메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있습니다. 이 메시지는 (3)의 공개키 증명서에서 꺼낸 공갸키로 암호화되었습니다.
1. 클라이언트는 Chahne Cipher Spec 메시지를 송신합니다. 이 메시지는 이 메시지 이후의 통신은 암호키를 상ㅇ해서 진행한다는것을 나타내고 있습니다.
1. 클라이언트의 Finished 메시지를 송신합니다. 이 메시지는 접속 전체의 체크 값을 포함하고 있습니다. 네고시에이션이 성공했는지 어떤지는 서버가 이 메시지를 올바르게 복호활 수 있는지 아닌지가 결정합니다.
1. 서버도 마찬가지로 Change Cipher Spec 메시지를 송신합니다.
1. 서버에도 마찬가지로 Finished 메시지를 송신합니다.
1. 서버와 클라이언트의 Finished 메시지 교환이 완려되면 SSL에 의해 접속은 확립됩니다. 이제부터 애플리케이션 계층의 프로토콜에 의해 통신 입니다. 즉 HTTP 리퀘스트를 송신합니다.
1. 애플리케이션 계층의 프로토콜에 의한 통신입니다. 즉 HTTP 리스폰스를 송신합니다.
1. 마지막에 클라이언트가 접속을 끌ㄴㅎ습니다. 접속을 끊을 경우 close_notify메시지를 송신합니다. 그림에서는 생략되었지만 그 후에는 TCP FIN 메시지를 보내 TCP 송신을 종료합니다.

---

http https  
웹상 정보를 주고 받는 프로토콜  

보안이 강화된것 https  

http 평문 (암호화 없음)  

Ssl 인증서  
통신을 제 3자가 보증해 주는 문서  
CA라는 기관에서 인증  

대칭키  
암호화 복호화 키가 같음  

공개키 암호화 방식  
암호화 복호화 키가 다름  
컴퓨터 자원 많이 사용  

따라서 조합하여 사용  


SSL  
TLS  
 관리하는 기관이 다름  

방식이나 정의 하는 것이 거의 같은 흐름속에 가기 때문에 같은 걸로 취급하는 것 같음  


공개키 대칭키  

대칭키 => 복호화가 된다  
MD5 복호화가 안된다 그래서 암호화 해서 비교 ( 우리가 알면 안되기 떄문에 )  

공개키는 페어가 있다  
OpenSSL  
Private key  
Public key  

핸드 쉐이크  
S private key  
C public key  

1. 클라이언트 대칭키를 공개키로 암호화해서 전송
2. 서버가 클라이언트 대칭키 비밀키로 복호화해서 확인 후 서버의 대칭키를 암호화 해서 전송
3. 클라이언트가 서버의 대칭키를 공개키를 복호화해서 가진다

세션을 유지하면서 쓰면 이득이다.  
1.0처럼 주고 끊고 하면 핸드 쉐이킹 부분이 계속 일어나니까 느려진다.  

JWT는 인증서의 약한 버전이라고 봐도 될거 같다.  







---
참조 : [HTTPS에 대한 기초 이해](https://cheese10yun.github.io/https/)

---

## http와 https의 차이
대칭 키 암호화(symmetric key cryptography)에서 비대칭 키 암호(asymmetric key cryptography) 사용<br>
인증 기관(Certification Authority)을 사용<br>

쉽게 설명 했다고 하는데 솔직히 잘 모르겠다 ...<br>