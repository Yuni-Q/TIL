
# Memory

## 개관
C와 같은 언어에는 malloc()나 free()와 같은 저수준의 메모리 관리를 위한 원시함수(primitive)를 존재합니다. 개발자들은 이들을 이용해 명시적으로 운영체제로부터 메모리를 할당 받거나 돌려주는 작업을 합니다.  

자바스크립트에서는 무언가(객체, 문자열 등)가 생겨날 때 메모리가 할당되며 이들이 더 이상 사용되지 않을 때는 ‘자동으로’ 메모리가 반환되는데 이런 과정을 <b>가비지컬렉션(garbage collection)</b>이라고 합니다. 이렇게 자원을 반환하는 것이 자동으로 일어나는 것처럼 보이는 것 때문에 자바스크립트 개발자들(또한 다른 고수준 언어의 개발자들도)은 자신들이 더 이상 메모리관리를 신경쓰지 않아도 된다는 잘못된 생각을 하고 있습니다만 이것은 대단히 큰 실수입니다.

## 메모리 생명주기
1. 메모리 할당(allocate)
프로그램이 사용할 수 있도록 운영체제가 메모리를 할당합니다.  
저수준 언어(예를 들어 C)에서는 이를 개발자가 명시적으로 처리해줘야 합니다.  
그러나 고수준 언어에서는 개발자가 신경쓸 필요 없습니다.  
1. 메모리 사용(use)
이제 할당된 메모리를 실제로 프로그램이 사용하는 단계입니다.  
개발자가 코드 상에서 할당된 변수를 사용함으로써 읽기와 쓰기 작업이 이루어집니다.  
1. 메모리 해제(release)
프로그램에서 필요하지 않은 메모리 전체를 되돌려주어 다시 사용가능하게 만드는 단계입니다.  
메모리 할당 작업과 마찬가지로 저수준 언어에서는 이를 명시적으로 처리해야 합니다.  

## 메모리란 ?
하드웨어 수준에서, 컴퓨터 메모리는 많은 수의 플립플롭(flip flop)으로 구성되어 있습니다.  
각각의 플립플롭은 몇 개의 트랜지스터를 갖고 있으며 하나의 비트를 저장할 수 있습니다.  
개별 플립플롭은 고유한 식별자(unique identifier)를 통해 위치를 확인할 수 있기 때문에 우리가 그것을 읽거나 쓰는 것이 가능해집니다.  
따라서 개념적으로 볼 때 컴퓨터 메모리는 여러 개의 비트로 구성된 커다란 하나의 배열로 볼 수 있으며 우리는 여기에 무언가를 읽고 쓸 수 있습니다.  

코드를 컴파일하면 컴파일러는 원시 데이터타입을 검사해서 얼마나 많은 메모리가 필요할지 미리 계산합니다.  
그러면 필요로 하는 만큼의 양이 스택스페이스(stack space)라는 곳에서 프로그램에 할당됩니다.  
이런 변수들이 할당되는 공간을 스택스페이스라고 부르는 까닭은 함수가 호출 되면 해당 함수의 메모리가 기존 메모리의 위에 추가되기 때문입니다.  
함수가 종료되면 LIFO(후입선출)의 순서로 제거됩니다.  

## 동적할당
어떤 변수가 얼마나 많은 메모리를 필요로할지 컴파일타임에 알지 못하면 일은 좀 더 복잡해집니다.  

자바스크립트는 개발자들을 메모리 할당의 책임에서 해방시켜주었습니다.  
자바스크립트는 변수 할당 시점에 메모리 할당을 스스로 수행합니다.

## 자바스크립트에서 메모리의 사용
자바스크립트에서 할당된 메모리를 사용하는 것은 기본적으로 그 메모리 내에서 읽거나 쓰는 것을 뜻합니다.  
이것은 객체의 속성이나 변수의 값을 읽거나 쓸 때 혹은 함수에 인수를 넘겨줄 때에도 일어납니다.  

## 메모리가 더 이상 필요하지 않을 때 놓아주기
이 단계가 바로 대부분의 메모리 관리 문제가 일어나는 때입니다.  

여기서 가장 어려운 작업은 할당된 메모리가 언제 더 이상 필요 없는지 알아내는 것입니다.  
프로그램 상에서 일정한 메모리가 더 이상 사용되지 않고 있으며 이를 반환해야 하는지를 프로그래머가 판단해야 할 때도 종종 있습니다.  

고수준의 언어에는 가비지컬렉터(garbage collector)라는 소프트웨어가 내장되어 있는데 이것의 역할은 메모리 할당을 추적하고 언제 할당된 메모리가 더 이상 사용되지 않는지 파악해서 자동으로 반환하는 것입니다.  
불행하게도 이러한 과정은 추정에 기반하는데 왜냐하면 일반적으로 메모리의 일부가 필요할지를 알아내는 문제는 결정불가능(undecidable), 즉 알고리즘으로 풀 수 없는 문제이기 때문입니다.  
대부분의 가비지컬렉터는 어떤 메모리를 가리키는 모든 변수가 스코프를 벗어나게 됐을 때 처럼 더 이상 접근 불가능한 메모리를 수집합니다.  
이는 메모리 공간에서 수집할 수 있는 것들을에 대해 보수적인 입장에서 추측하는 것인데 왜냐하면 어떤 메모리 영역을 가리키는 변수는 아직 존재하지만 그것을 그 이후로 절대로 접근하지 않는 경우는 언제라도 생길 수 있기 때문입니다.  

## 가비지컬렉션
어떤 메모리가 더 이상 필요 없음을 알아내는 것이 결정할수 없는 문제이기 때문에 가비지컬렉션은 이 일반적인 문제에 대해 제한적인 해결책만을 구현합니다.  

## 메모리 참조
가비지 컬렉션 알고리즘이 의존하고 있는 주요 개념은 참조(reference)입니다.  

메모리 관리의 관점에서는 어떤 객체가 다른 객체에 (명시적이든 암묵적이든) 접근할 수 있으면 다른 객체를 참조한다고 말합니다.  
이런 관점에서 ‘객체’라는 것의 개념은 일반적인 자바스크립트 객체에서 좀 더 큰 범위로 확장되어 함수 스코프(function scope)나 글로벌 렉시컬 스코프(lexical scope)까지도 포함하는 것이 됩니다.  
렉시컬 스코핑은 변수 이름이 중첩된 함수에서 해석되는 방식을 정의합니다. 중첩되어 있는 더 안 쪽의 함수는 부모 함수가 값을 반환한 다음에도 부모 함수의 스코프를 포함하고 있습니다.  

## 참조횟수계산 가비지컬렉션
이것은 가장 단순한 형태의 가비지컬렉션 알고리즘입니다.  
객체는 만약 그것을 가리키는 참조가 하나도 없는 경우 가비지컬렉션 대상(garbage collectible)으로 간주됩니다.  


## 순환 참조 때문에 생기는 문제
순환 때문에 생기는 제한점들이 있습니다.  
이 객체들은 함수 호출 뒤에 스코프를 벗어나게 되므로 실질적으로는 쓸모가 없게 되고 이들이 차지하던 메모리는 반환될 수 있습니다.  
하지만 참조횟수계산 알고리즘에서는 두 객체가 적어도 한 번은 참조한 것으로 간주하므로 둘 다 가비지컬렉션 될 수 없습니다.  

### 순환참조 문제는 해결
서로에 대한 참조가 있기는 하지만 루트에서는 닿을 수 없는 상태로 만듭니다.  

## 마크스위프 알고리즘
객체가 필요한지 결정하기 위해서 이 알고리즘은 해당 객체에 닿을 수 있는지(reachable)를 판단합니다.  
마크스위프 알고리즘은 다음의 세 단계를 거칩니다.  

1. 루트(Roots)
일반적으로 루트는 코드에서 참조되는 전역 변수입니다.  
가비지컬렉터는 모든 루트의 완전한 목록을 만들어냅니다.  
1. 그런 다음 모든 루트와 그 자식들을 검사해서 활성화 여부를 표시합니다(활성상태이면 가비지가 아닙니다). 루트가 닿을 수 없는 것들은 가비지로 표시됩니다.
1. 마지막으로 가비지컬렉터는 활성으로 표시되지 않은 모든 메모리를 OS에 반환합니다.

## 메로리 누수란 ?
이름에서 알 수 있듯이 메모리누수(memory leaks)는 전에는 프로그램에서 사용했다가 더 이상 필요하지 않지만 아직 OS나 자유메모리 풀에 반환되지 않은 메모리 조각들을 말합니다.  


## 네 가지 흔한 자바스크립트 메모리누수
1. 전연 변수
기대치 않게 생성된 전역변수는 물론 문제입니다만 많은 경우에는 의도적으로 가비지컬렉터가 정리할 수 없는 전역변수를 사용하기도 합니다.   
임시로 정보를 저장하거나 많은 양의 정보를 처리할 때 사용하는 전역 변수에 특별히 세심한 주의를 기울일 필요가 있습니다.  
꼭 그래야 한다면 전역 변수를 사용할 수도 있지만 사용을 마친 다음에는 꼭 null로 할당하거나 다른 변수로 할당하시기 바랍니다.  
> 자바스크립트 파일의 상단에 use strict를 사용하면 위와 같은 모든 것들을 회피할 수 있습니다.  
>이 모드에서 자바스크립트는 예상치 못한 전역 변수 생성을 방지할 수 있는 훨씬 엄격한 파싱을 시도합니다.  

## 2. 잊혀진 타이머 혹은 콜백함수

## 3. 클로져
한 번 동일한 부모 스코프에 있는 클로져들에 대한 스코프가 생성되고 나면 이것은 공유된다는 점입니다.  


## 4: DOM에서 벗어난 요소 참조
테이블 셀에 대한 참조 하나만으로도 전체 테이블이 메모리에 남아 있게 됩니다.  

---
참조 : [자바스크립트는 어떻게 작동하는가: 메모리 관리 + 4가지 흔한 메모리 누수 대처법](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d)