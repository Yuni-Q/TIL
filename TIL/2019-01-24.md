
# MSA
- MSA를 활용하려면 MQ 시스템이 필요하다.
- Node가 생산성이 좋기 때문에 기본 베이스로 사용한다.
  - Node.js는 싱글스레드이기 때문에 장애가 발생시 큐에 있던 작업과 함께 죽어버릴 수 있다. 이에 따라 결제 서버와 같은 곳에서 쓰이기에는 매우 위험하다.
  - 멀티 프로세스, 스케쥴러를 활용하여 싱크 맞추기 등의 방법이 있지만 여러가지 로스가 너무 심하다.
  - 자바 스프링(or 스프링부트)를 사용해서 안정성 있는 결제 서버 운영
- 속도가 중요한 인증 서버의 경우 go로 구현
  - Rust나 C도 있지만 생산성과 Node보다 빠르기만하면 되기 때문에 go가 적절하다고 판단 된다.

- MSA는 도메인 별로 서버와 DB를 분리한다. API Spec만 맞으면 언어의 제한은 없다.
- DB를 각자 사용한다.
- 각 API에 대응하는 Worker가 존재한다.
- Worker는 주기적으로 해야 되는 작업을 주로 한다.
- 또한 특정 이벤트(회원가입)이 발생 했을 때 다른 서버에 요청해야하는 작업을 AWS SNS와 SQS를 활용하여 비동기적으로 처리한다. 다른 서버에 문제가 있어도 이벤트(회원가입)는 정상 종료 할 수 있게 한다. 또한 user API는 해당 이벤트에 따라 어떤 요청이 필요한지 알지 못한다(AWS SNS가 처리). 이에 따라 SQS와 AWS SNS의 네이밍이 중요하다.

# 쿠버레네티스
- AWS에서 EKS를 최근에 발표했다.
- 우선 도커는 무엇인가 VM이다. 메모리는 차지하지 않고 도커 이미지를 git과 같은 방식으로 사용해서 차이점만을 pull 받을 수 있다. 이에 따라 도커는 매우 라이트 하다.
- 운영이 쉬워진다.
- 도커 컴포즈로 한번에 또커 10개도 띄울 수 있다. 이에 따라 서버단위로 관리가 편해졌다.
- 그 도커들을 메니징 할수 있는 것이 도커스왑과 쿠버레네티스가 있다.
- 현재는 쿠버레네티스의 승리로 보이며 go로 개발되어 있다. 현재는 kops를 통해 AWS의 EC2를 관리하지만 EKS로 바뀔 것이다.

# React
- V-DOM기반으로 차이점만을 rerender한다.
- compare(Deep)과 shellow compare가 있다.
  - shellow compare는 값과 주소만을 비교해서 생산성을 높인다.
  - Class는 pureComponent
  - SFC는 memo

# Redux
- 상태관리
- High order Component
- Store, dispatch, Action, mapStateToProps를 활용해서 글로벌하게 상태를 관리한다.
- ContextAPI 리덕스 기능 중 상태관리 기능을 간략하게 사용

