
# redis 기초

## Strings

> SET을 이용해서 값을 저장하고, GET을 이용해서 값을 가져올 수 있다.<br>
이미 있는 key에 대해서 값을 설정하면, 값을 덮어씁니다.<br>
> MSET과 MGET을 이용해서 한 번에 여러 개의 key, value를 저장하고 읽을 수 있습니다.<br>

## 리스트
LPUSH를 이용해서 리스트의 맨 앞(왼쪽-left)에, RPUSH를 이용해서 리스트의 맨 뒤에 값을 밀어넣을 수 있습니다. LRANGE로 일정 범위의 값을 읽을 수 있습니다.<br>
LRANGE는 시작과 끝을 위한 두 개의 index 값이 필요합니다. 인덱스가 마이너스(-)이면, 리스트의 끝(오른쪽)을 기준으로 인덱스 값을 메깁니다.<br>
오른쪽 끝의 인덱스는 -1 입니다. 따라서 "0 -1"은 0번째 부터 마지막 까지의 범위를 의미 합니다.<br>
pop은 Redis list에서 가장 중요한 연산 입니다. 이 연산은 리스트에서 값을 읽는게, 아니라 꺼냅니다. 읽으면서 지운다라고 생각하면 됩니다.<br>

### Capped Lists
소셜 네트워크 메시지 서비스혹은 로그 경우 마지막에 저장된 값만 필요한 경우가 많습니다.<br>
LTRIM을 이용해서 특정 영역의 값만 남기고 나머지는 삭제할 수가 있습니다.<br>

### Blocking operation on lists
BRPOP과 BLPOP 명령을 이용하면, blocking 작업이 가능합니다. 이들 명령을 호출하면, 데이터가 없을 경우 데이터가 준비될 때까지 block 됩니다.<br>
물론 block 시간 설정도 가능 합니다.<br>

## Hash
Hash는 값으로 field & value의 쌍으로 이루어진 테이블을 저장할 수 있는 데이터 타입 입니다.<br>

## Set
Set은 정렬되지 않은 string의 집합이다. SADD 명령을 이용해서 set에 새로운 값을 추가할 수 있습니다.<br>
SISMEMBER명령으로 값이 set에 있는지 확인할 수 있습니다.<br>

## Sorted Set
Set과 hash를 섞은 데이터 타입이라고 보면 됩니다<br>
Set과 마찬가지로 키는 유니크하며, 키로 정렬 됩니다.<br>
ZADD의 사용법은 SADD와 비슷하다. 정렬에 사용 할 score 매개변수가 하나 더 추가된다는 것만 다릅니다.<br>
이제 값을 가져 오면 score를 키로 정렬된 결과를 받아볼 수 있습니다.<br>
Sorted set은 값을 입력 할 때, 정렬이 되기 때문에, O(long(N))의 시간 복잡도를 가집니다.<br>
WITHSCORES옵션으로 score 값도 함께 읽을 수 있습니다.<br>

### Operation on ranges
Sorted set은 범위 검색을 위한 몇 가지 툴을 제공 합니다.<br>

### Lexicographical scores
Redis 2.8에 lexicographical scores가 추가 됐습니다.<br>
score가 같을 경우, 값을 비교해서 정렬합니다.<br>
비교 함수로 C의 memcmp 함수를 사용합니다.<br>

## Bitmaps
Bitmap의 가장 큰 장점은 0과 1의 상태를 가지는 아이템들을 대단히 효율적으로 저장하고, 읽을 수 있다는데 있습니다.<br>
하루 동안의 유니크 방문자를 계산해야 한다고 가장해 봅시다.<br>
유저가 방문할 때, 유저 아이디에 해당하는 bit 값을 1로 만들어 주는 걸로 간단하게 유저의 방문여부를 알 수 있습니다.<br>
이때 필요한 메모리는 단지 1bit이기 때문에 512MB의 메모리로 40억(512 * 1024 * 1024 * 8)의 유저의 방문정보를 기록할 수 있습니다.<br>

## HyperLogLogs
어떤 데이터셋에서 집합에서 유일한 원소의 갯수를 검사하기 위해서 사용하는 알고리즘입니다.<br>
세익스피어 전집에서 unique한 단어의 갯수를 계산하려면 매우 큰 메모리가 필요할 것입니다.<br>
HyperLogLogs를 이용하면 약간의 오차를(대략 1billion에 대해서 2% 정도) 허용하는 대신 매우 작은 메모리로 유니크한 원소의 갯수를 검사할 수 있습니다.<br>
셰액스 피어의 전집에 나오는 유일한 영어 단어 개수를 세는 것으로 비교하자면, HashSet을 이용할 경우 10,4447,016 크기의 메모리가 필요한 반면, HyperLogLogs는 512바이트가 필요하다.<br>
물론 Hashet의 오차는 0%, HyperLogLogs는 3%의 오차가 발생한다.<br>
