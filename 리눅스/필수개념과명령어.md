
# 서버를 구축할 때 알아야 할 필수 개념과 명령어

## 터미널/콘솔에서 시스템 종료 명령 실행
- shutdown -P now
- halt -p
- init 0
> -P와 -p 옵션은 시스템 종료를 의미한다.  
> 유닉스/리눅스에서는 대문자와 소문자를 구분한다.  
> # : root 사용자  
> $ : 일반 사용자  

## 시스템 재부팅
- shutdown -r now
- reboot
- init 6

## 로그아웃
- logout
- exit

## 런레벨
|런레벨|영문 모드|설명|비고|
|----|-------|---|---|
|0|Power Off|종료 모드||
|1|Rescue|시스템 복구 모드||
|2|Multi-User||사용하지 않음|
|3|Multi-User|텍스트 모드의 다중 사용자 모드||
|4|Multi-User||사용하지 않음|
|5|Graphical|그래픽 모드의 다중 모드||
|6|Reboot||||
> 일반적으로 런레벨 3번을 Multi-User 모드로 사용한다. 2번과 4번은 CentOS 7에서는 사용하지 않지만 호환성을 위해서 런레벨 3번과 동일한 것으로 취급한다.  

## 히스토리
- history : 사용했던 명령을 오묻 볼 수 있다.
- history c : 기억되었던 명령어를 모두 삭제 한다.

## vi
- :q : 종료 한다.
- I or A : 글자를 입력(Insert)하거나 추가(Append) 한다.
- :wq : 저장(Write)하고 종료(Quit) 한다.
- :q! : 기존의 병견된 내용을 무시하고 종료한다.
> 스왑 파일(swap file)이 존재한다는 것은 앞에서 수정 작업이 정상적으로 종료되지 않았다는 것을 알려 줍니다.  
> ex) .파일 이름.swp

### 명령 모드에서 입력 모드로 전환하는 키
|키|설명|키|설명|
|-|---|-|---|
|i|현재 커서의 위치부터 입력(I)|I|현재 커서 줄의 맨 앞에서 부터 입력(Shift + I)|
|a|현재 커서의 위치 다음 칸부터 입력(A)|A|현재 커서 줄의 맨 마지막부터 입력(Shift + A)|
|o|현재 커서의 다음 줄에 입력(O)|O|현재 커서의 이전 줄에 입력(Shift + O)|
|s|현재 커서 위치의 한 글자를 지우고 입력(S)|S|현재 커서의 한 줄을 지우고 입력(Shift + S)|

### 명령 모드에서 커서를 이동할 때 사용하는 키
|키|설명|키|설명|
|-|---|-|---|
|h|커서를 왼쪽으로 한칸 이동(<-와 같은 의미, H)|j|커서를 아래로 한칸 이동(J)|
|k|커서를 위로 한칸 이동(K)|l|커서를 오른쪽으로 한칸 이동(->와 같으 의미, l)|
|Ctrl + F|다음 화면으로 이동(Page Down과 같은 의미)|Ctrl + B|이전 화면으로 이동(Page Up과 같은 의미)|
|^|현재 행의 처음으로 이동(Home과 같은 의미, Shift + 6)|$|현재 행의 마지막으로 이동(End와 같은 의미, Shift + 4)|
|gg|제일 첫 행으로 이동|G|제일 끝 행으로 이동(Shift + G)|
|숫자 G|해당 숫자의 행으로 이동(숫자 다음 Shift + G|:숫자|해당 숫자의 행으로 이동|

### 명령 모드에서 삭제, 복사, 붙여 넣기 관련 키
|키|설명|키|설명|
|-|---|-|---|
|x|현재 커서가 위치한 글자 삭제(Del과 같은 의미, X)|X|현재 커서가 위치한 앞 글자 삭제(BackSpace와 같은 의미, Shift + X)|
|dd|현재 커서의 행 삭제(D 연속 두번 입력)|숫자 dd|현재 커서부터 숫자만큼의 행 삭제(숫자 다음 D 연속 두번 입력)|
|yy|현재 커서가 있는 행을 복사(Y 두번 연속 입력)|숫자 yy|현재 커서부터 숫자만큼의 행을 복사(숫자 다음 Y 두번 연속 입력)|
|p|복사한 내용을 현재 행 이후에 붙여 넣기(P)|P|복사한 내용을 현재 행 이전에 붙여 넣기(Shift + P)|

### 명령 모드에서 문자열 찾기
|키|설명|키|설명|
|-|---|-|---|
|/문자열 Enter|해당 문자열을 찾음(현재 커서 이후로)|n|찾은 문자 중에서 다음 문자로 이동(N)|
|:%s/기존문자열/새문자열/|문자열 치환|:.set number|행 번호 표시|

### 도움말 사용법
- man : manual의 약어로, 리눅스에 포함된 체계화된 도움말이다.  

#### man 명령어는 섹션을 1~9까지 9개 페이지로 나눈다.
- 1 : 명령어   
- 2~3 : 프로그래밍
- 4 : 디바이스
- 5 : 파일 형식
- 6 : 게임
- 7 : 기타 주제
- 8 : 시스템 관리
- 9 : 커널 관련 설명

## 리눅스 기본 명령어

### whoami
현재 사용자가 누군인지 알려준다.  

### ls
List의 약자로 Windows의 dir과 같은 역할을 한다.  
즉, 해당 디렉터리(=폴더)에 있는 파일의 목록을 나열 한다.
- ls : 현재 디렉터리의 파일 목록
- ls -a : 현재 디렉터리의 목록(숨김 파일 포함)
- ls -l : 현재 디렉터리의 목록을 자세히 보여줌
> 리눅스는 숨김 파일(hidden file)이라는 속성이 별도로 존재하지 않는다.  
> 파일 이름이나 제일 앞 글자를 .으로 하면 자동으로 숨김 파일이 된다.  

### cd
Change Directory의 약자로 디렉터리를 이동하는 명령이다.  
- .(현재 디렉터리)
- ..(현재 디렉터리의 상위 디렉터리)

### pwd
Print Working Directory의 약자로 현재 디렉터리의 전체 경로를 화면에 보여준다.  

### rm
ReMove의 약자로 파일이나 디렉터리를 삭제한다.  
당연히 파일이나 디렉터리를 삭제할 권한이 있어야 한다.  
단, root 사용자는 모든 권한이 있으므로 이 명령어에 제약이 없다.  
- rm abc.txt : 해당 파일을 삭제(내부적으로 rm -i로 연결 됨)
- rm -i abc.txt : 삭제 시 정말 삭제할지 확인하는 메세지가 나옴
- rm -f abc.txt : 삭제 시 확인하지 않고 삭제(f는 Force의 약자)
- rm -r abc : 해당 디레거리를 삭제(r은 Recursive의 약자)
- rm -rf abc : r 옵션과 f 옵션을 합친 것으로, abc 디렉터리와 그 아래에 있는 하위 디렉터리를 강제로 전부 삭제(편리하지만 상당히 주의해서 사용해야 함)

### cp
Copy의 약자로 파일이나 디렉터리를 복사한다.  
새로 복사한 파일은 복사한 사용자의 소유가 된다.  
그러므로 명령어를 실행하는 사용자는 해당 파일의 읽기 권한이 필요하다.  
- cp abc.txt cba.txt : abc.txt를 cba.txt라는 이름으로 바꿔서 복사
- cp -r abc cba : 디렉터리 복사

### touch
크기가 0인 새 파일을 생성하거나, 이미 파일이 존재한다면 파일의 최종 수정 시간을 변경한다.  

### mv
- mv abc.txt /etc/sysconfig/ : abc.txt을 /etc/sysconfog/ 디렉터릴로 이동
- mv aaa bbb ccc ddd : aaa, bbb, ccc 파일을 /ddd 디렉터리로 이동
- mv abc.txt www.txt : abc.txt의 이름을 www.txt로 변경해서 이동

### mkdir
Make DIRectory의 약자로 새로은 디렉터리 생성한다.  
생성된 디렉터리는 명령어를 실행한 사용자의 소유가 됨  

### rmdir
ReMove DIRectory의 약자로 디렉터리를 삭제한다.  
해당 디렉터리의 삭제 권한이 있어야 하며, 디렉터리는 비어 있어야 한다.  
파일이 들어 있는 디렉터리를 삭제하려면 -rm -r을 실행해야 한다.  

### cat
conCATenate의 약자로 파일의 내용을 화면에 보여준다.  
여러 개 파일을 나열하면 파일을 연결해서 보여준다.  

### head, tail
텍스트 형식으로 작성된 파일의 앞 10행 또는 마지막 10행만 화면에 출력한다.  

### more
텍스트 형식으로 작성된 파일을 페이지 단위로 화면에 출력한다.  
Space를 누르면 다음 페이지로 이동하며, B를 누르면 앞 페이지로 이동한다.  
Q를 누르면 종료한다.  

### less
more 명령어와 용도가 비슷하지만 기능이 더 확장되어 있다.  
more에서 사용하는 키도 사용 할 수 있으며, 화살표 키나 Page Up, Page Down도 사용 할 수 있다.  

### file
해당 파일이 어떤 종류의 파일인지를 표시해 준다.  

### clear
현재 사용중인 터미널 화면을 깨끗하게 지워준다.  

## 사용자 관리와 파일 속성

### 사용자와 그룹
/etc/passwd
사용자 이름:암호:사용자ID:사용자가 소속된 그룹 ID:전체 이름:홈 디렉터리:기본 셀  
> root 사용자는 사용자 id와 그룹 id가 0번으로 설정 되어 있다.  

#### useradd (또는 adduser)
새로운 사용자를 추가한다.  
이 명령어를 실행하면 /etc/passwd, /etc/shadow, /etc/group 파일에 새로운 행이 추가 된다.  
- useradd newuser : newuser라는 이름의 사용자 생성
- useradd -u 1111 newuser : newuser 사용자를 생성하면서 사용자 ID를 1111로 지정
- useradd -g mygroup newuser : newuser 사용자를 생성하면서 mygroup 그룹에 newuser 사용자를 포함 시킴(mygroup 그룹을 먼저 만들어 놓아야 함)  
- user add -d /newhome newuser : newuser 사용자를 생성하면서 홈 디렉터리를 /newhome으로 지정
- useradd -s /bin/csh newuser : newuser 사용자를 생성하면서 기본 셀을 /bin/csh로 지정   

#### passwd
사용자의 비밀번호를 지정하거나 변경한다.  

#### usermod
사용자의 속성을 변경한다.  
옵션은 useradd와 동일하다.  

#### userdel
사용자를 삭제한다.  
- userdel -r newuser : newuser 사용자를 삭제하면서 홈 디렉터리까지 삭제  

#### chage
사용자의 암호를 주기적으로 변경하도록 설정한다.  
- chage -l newuser : newuser 사용자에 설정된 사항을 확인  
- chage -m 2 newuser : newuser 사용자에 설정한 암호를 사용해야 하는 최소일자(즉, 변경 후 최소 2일은 사용해야 함)
- chage -M 30 newuser : newuser 사용에 설정한 암호를 사용할 수 있는 최대일자(즉, 변경 후 최대 30일까지 사용할 수 있음)
- chage -E 2019/12/12 newuser : newuser 사용자에 설정한 암호가 만료되는 날짜(즉, 2019/12/12까지만 사용할 수 있음)
- chage -W 10 newuser : newuser 사용자에 설정한 암호가 만료되기 전에 경고하는 기간. 지정하지 않았을 경우 기본 값은 7일(즉, 암호가 만료되기 10일 전부터 경고 메시지가 나감)

#### groups
사용자가 소속된 그룹을 보여준다.  
- groups : 현재 사용자가 소속된 그룹을 보여줌
- groups newuser : newuser가 소소된 그룹을 보여줌

#### groupadd
새로운 그룹을 생성한다.  
- groupadd newgroup : newgroup이라는 그룹을 생성
- groupadd -g 2222 newgroup : newgroup 그룹을 생성하면서 그룹 ID를 2222로 지정  

#### groupmod
그룹의 속성을 변경한다.  
- groupmod -n newgroup mygroup : newgroup 그룹의 이름을 mygroup으로 변경

#### groupdel
그룹을 삭제한다.  

#### gpasswd
그룹의 암호를 설정하거나 그룹 관리를 수행한다.  
- gpasswd newgroup : newgroup 그룹의 암호를 지정
- gpasswd -A newuser newgroup : newuser 사용자를 newgroup 그룹의 관리자로 지정
- gpasswd -a user1 newroup : user1을 newgroup 그룹의 사용자로 추가
- gpasswd -d newuser newgroup : user1을 newgroup 그룹의 사용자에서 제거

### 파일과 디렉터리의 소유와 허가권
|-|rw-r--r--|1|root|root|0|12월 1 20:54|sample.txt|
|-|---------|-|----|----|-|------------|----------|
|파일 유형|파일 허가권|링크 수|파일 소유자 이름|파일 소유 그룹 이름|파일 크기(Byte)|마지막 변경 날짜/시간|파일 이름|

#### 파일 유형
d : 디렉터리  
\- : 일반적인 파일  
b : 블록 디바이스(하드디스크, 플로피 디스크, CD/DVD 등의 저장 장치)  
c : 문자 디바이스(마우스, 키보드, 프린터 등의 입출력 장치)  
l : 링크(Windows의 바로가 가기 아이콘과 비슷한 개념으로 연결된 파일을 의미한다. 이때 실제 파일은 다른 곳에 존재함을 기억하자)  

#### 파일 허가권
r : read  
w : write  
x : execute  

1번째는 소유자의 파일 접근 권한  
2번째는 그룹의 파일 접근 권한  
3번째는 그 외 사용자의 파일 접근 권한

|r|w|-|r|-|-|r|-|-|
|-|-|-|-|-|-|-|-|-|
|4|2|0|4|0|0|4|0|0|
||6|||4|||4||
> 파일의 허가권을 변경하는 명령어로는 chmode가 있다.  
> 이 명령어는 root 사용자 또는 해당 파일의 소유자만이 실행할 수 있다.  
> chmod 명령어를 상대 모드로도 사용 할 수 있다.  

Windows의 경우 확장명으로 해당 파일의 종류를 판단하지만, 리눅스는 확장자에 별 의미를 두지 않는다.  
즉, 실행파일이건 텍스트 파일이건 모두 일반적으로 확장명을 갖지 않는다.  
그래서 해당 파일이 어떤 파일인지를 알려면 file 명령어를 사용해야 한다.  

#### 파일 소유권
파일 소유권은 파일을 소유한 사용자와 그룹을 의미한다.  
chown으로 파일의 소유권을 변경 할 수 있다.  
- chown coentos sample.txt : 파일의 소유자를 centos로 바꾸어라
- chown centos.centos sample.txt : 파일의 그룹도 centos 그룹으로 바꾸어라
- chgrp centos sample.txt : 그룹만 centos 그룹으로 변경 하라.


#### 링크
하드 링크, 심볼링 링크 2가지가 있다.  
하드 링크를 생성 하려면 'ln 링크대상파일이름 링크파일이름'을 실행한다.  

> inode는 리눅스 유닉스 파일 시스템에서 사용하는 자료구조를 말하는데, 파일이나 디렉터리의 여러가지 정보가 있다.  
> 모든 파일이나 디렉터리는 각자 1개씩의 inode가 있으며, 각 inode에는 해당 파일의 소유권, 허가권, 파일 종류 등의 정보와 해당 파일의 실제 데이터가 어디에 있는지 위치(=주소)도 있다.  
> 이런한 inode가 모여 있는 공간이 inode 블록이며, 일반적으로 전체 디스크의 1% 정도를 차지한다.  
> Data 블록은 실제 데이터가 저장되어 있는 디스크 공간으로 전체 디스크의 대부분을 차지한다.  

원본에 심볼릭 링크를 생성하면 새로운 inode2를 만들고, 데이터는 원본 파일과 연결되는 효과를 갖는다.  
심볼링 링크를 생성하려면 'ln -s 링크대상파일이름 링크파일이름'을 실행한다.  

하드 링크는 디렉터리에서 원본 파일이 없어져도 아무런 이상이 없고, 심볼릭 링크는 디렉터리에서 원본 파일이 없어지면 연결이 끊어진다.(다시 원본 파일을 현재 디렉터리에 가져와서 다시 한번 확인해보면 심볼릭 링크가 원상태로 복구되었음을 확인 할 수 있다.)  

## 리눅스 관리자를 위한 명령어

### 프로그램 설치를 위한 RPM
CentoOS에서 패키지(프로그램)를 설치하는 데 가장 많이 사용되는 것이 RPM과 YUM이다.  
YUM이 별도로 존재한다기보다는 RPM을 포함한 확장 개념에 가까우므로 먼저 RPM의 개념을 익혀야 한다.  

확장자명은 *.rpm이며, 이를 패키지라고 부른다.  

강제로 패키지를 설치하는 --force 옵션과 의존성을 무시하고 설치하는 --nodeps 옵션도 사용할 수 있으나, 이러한 옵션은 정상 설치를 보장할 수 없으므로 주의해서 사용해야 한다.  

#### 자주 사용하는 rpm 명령어 옵션

##### 설치
rpm -Uvh 패키지파일이름.rpm
-  대문자 U : 기존에 패키지가 설칟되지 않았다면 일반적인 설치를 하고, 기존에 패키지가 설치되어 있다면 업그레이드를 한다.(i 옵션은 설치되어 있다면 오류가 발생하므로, U 옵션이 더 편하다)  
- v : 설치 과정 확인  
- h : 설치 진행 과정을 # 기호로 화면에 출력

##### 삭제
rpm -e 패키지 이름
- e : erase(지움)의 약자  

##### 이미 설치된 패키지 조회
rpm -qa 패키지이름 : 시스템에 패키지가 설치되었는지 확인  
rpm -qf 파일절대경로 : 이미 설치된 파일이 어느 패키지에 포함된 것인지 확인  
rpm -ql 패키지이름 : 특정 패키지에 어떤 파일들이 포함되었는지 확인  
rpm -qi 패키지이름 : 설치된 패키지의 상세 정보  

##### 아직 설치되지 않은 rpm 파일 조회
rpm -qlp 패키지파일이름.rpm : 패키지 파일에 어떤 파일들이 포함되었는지 확인  
rpm -qip 패키지파일이름.rpm : 패키지 파일의 상세 정보  

#### RPM의 단점
의존성 문제  

### 편리하게 패키지를 설치하는 YUM
YUM은 RPM과 별로라기 보다는 rpm 패키지를 설치하는 편리한 도구라고 생각하면 된다.  
yum 명령어는 rpm 명령어의 패키지 의존성 문제를 완전하게 해결해준다.  

#### 기본 설치 방법
yum -y install 패키지이름
- -y 옵션을 써주면 사용자에게 yes/no를 묻는 부븐이 무조건 yes를 입력한 것으로 간주하고, 자도응로 넘어가서 편리하다.  

#### rpm 파일 설치 방법
yum localinstall rpm파일이름.rpm
- rpm -Uvh 대신 사용합니다.  

#### 업데이트 가능한 목록 보기
yum check-update

#### 업데이트
yum update

#### 삭제
yum remove 패키지이름

#### 정보 확인
yum info 패키지이름  

#### 패키지 그룹 설치
yum groupinstall "패키지그룹이름"
- 패키지 그룹에 포함되는 패키지들을 통쨰로 성치할 때 사용 할 수 있다.
- 종류는 yum grouplist으로 확인 할 수 있다.
- 설치할 때 그룹의 이름은 주로 띄어쓰기가 많으므로 꼭 "" 안에 써야 한다.  

#### 패키지 리스트 확인
yum list 패키지이름

#### 특정 파일이 속한 패키지 이름 확인
yum provides 파일이름

#### GPG 키 검사 생략
yum install --nogpgcheck rpm파일이름.rpm

#### 기존 저장소 목록 지우기
yum clean all

#### YUM의 작동 방식과 설정 파일
1. yum install 입력
1. /etc/yum.repos.d/ 디렉터리의 repo 파일을 열어서 URL 주소 확인
1. 전체 패키지 목록 파일을 요청
1. 전체 패키지 목록 파일만 다운로드
1. 설치할 패키지와 관련된 패키지의 이름을 화면에 출력
1. y를 입력하면 서치에 필요한 패키지 파일을 요청함
1. 설치할 패키지 파일을 다운로드해서 자동 설치

## 파일의 압축과 묶기

### 파일 압축
리눅스에서 많이 보는 압축 파일의 확장자명으로는 xz, bz2, gz, zip, Z 등이 있다.  
예전에는 주로 확장면 gz를 사용했으나, 최근에는 압축률이 더 좋은 xz나 bz2를 더 많이 사용하는 추세다.  

#### xz
확장명 xz로 압축하거나 풀어준다.  
비교적 최신의 압축 명령으로 압축률이 뛰어나다.  

- xz 파일이름 : 파일이름을 압축파일인 파일이름.xz로 만든다. 기존 파일은 삭제됨  
- xz -d 파일이름.xz : 파일이름.xz 압축 파일을 일반 파일인 파일이름으로 만듦(d는 Decompress의 의미)   
- xz -l 파일이름.xz : 파일이름.xz 압축 파일에 포함된 파일 목록과 압축률 등을 출력(l은 List의 의미)    
- xz -k 파일이름.xz : 압축 후에 기존 파일을 삭제하지 않고 그대로 둠(k는 Keep의 의미)  

#### bzip2
확작명 bz2로 압축하거나 풀어준다.  
- bzip 파일이름 : 파일이름을 압축 파일인 파일명.bz2로 만듦
- bzip -d 파일이름 : 파일이름.bz 압축 파일을 일반 파일인 파일이름으로 만듦(d는 Decompress의 의미)   

#### bunzip2
확장명이 bz2의 압축을 풀어준다.  
bzip2 -d와 동일한 명령이다.  

#### gzip
확장명 gz으로 압축하거나 풀어준다.  
- gzip 파일이름 : 파일이름을 압축 파일인 파일명.gz로 만듦
- gzip -d 파일이름 : 파일이름.gz 압축 파일을 일반 파일인 파일이름으로 만듦(d는 Decompress의 의미)   

#### gunzip2
확장명이 gz2의 압축을 풀어준다.  
gzip2 -d와 동일한 명령이다.  

#### zip
Windows용과 호환되는 확장명 zip으로 압축하거나 풀어준다.  
- zip 생성할파일이름.zip 압축할파일이름 : 압축할 파일 이름을 새로생성될파일이름.zip으로 만듦

#### uzip
Windows용과 호환되는 확장명 zip으로 묶은 압축 파일을 풀어준다.  
- uzip 압축파일이름.zip : 압축파일이름.zip의 압축을 풀어준다.  

### 파일 묶기
리눅스(유닉스)에서는 파일 압축과 파일 묶기는 원칙적으로 별개의 프로그램으로 실행하도록 되어있다.  
물론 사용자의 편의성을 위해 한번에 할 수 있는 옵션도 제공한다.  
파일 묶기의 명령어는 tar이며 묶여진 파일의 확장명도 tar이다.  

#### tar
확장명 tar로 묶음 파일을 만들거나 묶음을 푼다.  

##### 동작
- c(소문자) : 새로운 묶음을 만든다.  
- x : 묶인 파일을 푼다. 
- t : 묶음을 풀기 전에 묶인 경로를 보여준다.
- C(대문자) : 묶음을 풀 때 지정된 디렉터리에 압축을 푼다. 지정하지 않으면 묶을 때와 동일한디렉터리에 묶음이 풀린다.  

##### 옵션
- f(필수) : 묶음 파일 이름 지정. 원래 tar는 테이프 장치 백업이 기본이다.(생략하면 테이프로 보내짐)
- v : visual의 의미로
- J(대문자) : tar + xz
- z(소문자) : tar + gzip
- j(소문자) : tar + bzip2

##### 명령어
- tar xvfJ 파일이름.tar.xz : 묶인 파일 푼다 / 풀리는 과정 보여주면서 / 묶음 파일 이름 지정 / xz 
- tar xvfj 파일이름.tar.bz2 : 묶인 파일 푼다 / 풀리는 과정 보여주면서 / 묶음 파일 이름 지정 / bzip2

### 파일 위치 검색

#### find 경로 옵션 조건 action

##### 옵션
- -name
- -user(소유자)
- -newer(전, 후)
- -perm(허가권)
- -size(크기)

##### action
- -print(기본 값)
- -exex(외부 명령 실행)

##### 고급 사용 예
- find -size 0k -exec ls -l { } \; : 현재 사용자의 홈 디렉터리 하위에 파일 크기가 0인 파일의 목록을 상세히 출력
- find /home -name "*.swp" -exec rm { } \; : /home 홈 디렉터리 하위에 확장명이 *.swp인 파일을 삭제  
> -ecex : 외부 명령어의 시작  
> \; : 외부 명령어의 끝  
> { } : find 명령어의 실행 결과인 swp 파일이 rm 명령으로 실행 됨  

#### which 실행파일이름
PATH에 설정된 디렉터리만 검색한다.  
절대 경로를 포함한 위치를 검색한다.  

#### whereis 실행파일이름
실행파일, 소스, man 페이지 파일까지 검색한다.  

#### locate 파일이름
파일 목록 데이터베이스에서 검색하기 때문에 매우 빠르고 유용하지만, updatedb 명령어를 1회 실행해야 사용할 수 있다.  
또 updatedb 명령어 실행 이후에 설치된 실행 파일은 찾을 수 없으므러, 다시 updatedb 명령어를 실행해야 찾을 수 있다.  

### CRON과 AT

### cron
주기적으로 반복되는 일을 자동으로 실행할 수 있도록 시스템 작업을 예약해 놓는 것을 cron이라 부른다.  
systemctl status crond 명령으로 corn과 관련 서비스인 crond가 동작하는지 확인 할 수 있다.  
cron과 데몬(서비스)은 crond이고, 관련 파일은 /etc/crontab이다.  
> 분 시 일 월 요일 사용자 실행명령   
> 요일은 일요일(0)로 시작 된다  
00 05 1 * * root cp -r /home /backup
> *은 매월이므로 요일은 상관하지 않는다.  

### at
일회성 작업을 예약하는 것이다.  
- 예약: at 시간
- 확인: at -l
- 취소: atrm 작업번호
> 정확한 시간을 설정하는 방법으로 rdate 명령어를 실행해 타임 서버에서 시간을 가져온 다음 현재 리눅스에 설정하면 된다.  
> 우리나라에서 운영하는 타임서버로는 time.bora.net / ntp.kornet.net / ntp.postech.ac.kr 등이 있다.  

## 네트워크 관련 설정과 명렁어

### 네트워크 관련 필수 개념

#### TCP/IP
- 컴퓨터끼리 네트워크상으로 의사소통하는 약속을 프로토콜이라고 부르는데, 프로토콜 중 가장 널리 사용되는 종류 중 하나이다.  
- 통신의 전송/수신을 다루는 TCP(Transmission Control Protocol)와 데이터 통신을 다루는 IP(Internet Protocol)로 구성 된다.  

#### 호스트 이름과 도메인 이름
- 호스트 이름은 각각의 컴퓨터에 지정된 이름을 말한다. 
- 도메인 이름(또는 도메인 주소)은 hanb.co.kr과 같은 방식으로 표기하며 kr은 한국, co는 회사, hanb는 단체/회사의 이름을 의미한다.  
- FQDN(Full Qualified Domain Name)

#### IP 주소
- 각 컴퓨터의 랜카드는 네트워크 카드 또는 NIC(Network Interface Card)라고도 한다.  
- 즉, 네트워크 연결된 모든 컴퓨터는 고유한 IP 주소가 있으며, 이는 서로 다르기 때문에 특정 컴퓨터의 IP 주소를 알면, 그 컴퓨터가 전 세계 어디에 있는지 접속할 수 있다는 개념이다.(사설 IP 주소는 예외)  
- 4바이트로 이루어지며, 각 자리는 0~255까지의 숫자가 올 수 있다. 
- 자기 자신을 의미하는 IP 주소는 127.0.0.1 이다.

#### 네트워크 주소
- 같은 네트워크에 속해 있는 공통 주소이다.
- 공통된 네트워크 주소는 앞 3가지이다.  
> 192.168.xxx.ooo의 주소 영역은 사설 네트워크(Private network)의 주소다.  
> 사설 네트워크는 외부와 분리 된 내부의 별도 네트워크를 의미하며, 주로 공인 IP 주소가 부족할 때 많이 사용된다.  

#### 브로드캐스트 주소
- 내부 네트워크의 모든 컴퓨터가 수신하는 주소를 말한다.
- 현재 주소의 제일 끝자리를 255로 바꾼 주소다(C 클래스의 경우)
> 아파트 스피커처럼 모든 컴퓨터가 들을 수 있는 주소라고 생각하면 쉽게 이해할 수 있다.  

#### 게이트웨이
- 게이트웨이(Gateway)는 내부 네트워크를 외부로 연결하는 컴퓨터 또는 장비이다.  
- 인터넷을 사용하기 위해 외부에 접속하려면 반드시 게이트웨이의 IP 주소를 알아야만 한다.
- 게이트웨이는 쉽게 말해 외부 네트워크로 나가는 통로쯤으로 생각하면 된다.
- 내부로 향하는 문(네트워크 카드)과 외부로 향하는 문(네트워크 카드)이 있어야 한다. 즉, 네트워크 카드가 두개 장착되어 있어야 한다. 
> 실무에서 게이트웨이 주소는 제일 마지막 숫자를 254 또는 253 또는 1로 많이 사용한다. 이것은 네트워크 관리자가 마음대로 결정할 사항이다.  
- 게이트웨이를 별도로 추가해주는 명령어의 형식은 route add default gw 게이트웨이주소 dev 장치이름

#### 넷마스크와 클래스
- 넷마스크(Netmask) : 네트워크의 규모를 결정한다

#### DNS 서버 주소
- 인터넷을 사용할 때 www.daum.net과 같은 URL을 해당 컴퓨터의 IP 주소로 변환해 주는 서버 컴퓨터를 말한다.  
- DNS(Domain Name System)서버(=네임 서버)의 주소를 사용하지 않거나, 잘못 입력되어 있으면 정상적으로 웹 사이트에 접속되지 않으므로 올바른 정보를 설정해야 한다.
- 설정 파일은 /etc/resolv.conf며, 내용 중에 'nameserver DNS서버IP'의 형식으로 설정되어 있다.  
- VMware를 사용하면 VMware가 게이트웨이, DHCP 서버, DNS 서버의 역할을 모두 가상으로 제공한다.  

#### 리눅스에서의 네트워크 장치 이름
랜 카드가 리눅스에 장착되었을 때 CentOS 7은 자동으로 이름을 ens32 또는 ens33으로 인식한다.  
> 이전 버전은 eth0, eth1 등으로 인식 했다.  

- ifconfig ens32 또는 ens33 : 네트워크 설정 정보를 출력
- ifup ens32 또는 ens33 : 네트워크 장치를 가동
- ifdown ens32 또는 ens33 : 네트워크 장치를 정지

#### 중요한 네트워크 관련 명령어

##### nmtui
Network Manager Text User Interface의 약자로, 네트워크와 관련된 작업 대부분은 이 명령어를 기반으로 삼아 실행 할 수 있다.  
- 자동 IP 주소 또는 고정 IP 주소 사용 결정
- IP 주소, 서브넷 마스크, 게이트웨이 정보 입력
- DNS 정보 입력
- 네트워크 카드 드라이버 설정
- 네트워크 장치(ens32 또는 ens33)의 설정

##### systemctl start/stop/restart/status network
네트워크 설정을 변경한 후에 변경된 내용을 시스템에 적용시키는 명령어다.  

##### ifup 장치이름
해당 장치를 작동시켜 주는 명령어다.  

##### ifdown 장치이름
ifup과 반대로 네트워크 장치를 끄는 명령어다.  

##### ifconfig 장치이름
해당 장치의 IP 주소와 관련 된 정보를 출력해주는 명령어다.  

##### nslookup
DNS 서버의 작동을 테스트하는 명령어다.  

##### ping IP 주소 또는 URL
해당 컴퓨터가 네트워크상에서 응답하는지를 테스트하는 간편한 명령어다.  
즉, 상대 컴퓨터가 아무런 이상이 없이 작동되는지를 네트워크상에서 체크할 때 주로 사용된다.  

#### 네트워크 설명과 관련 된 주요 파일

##### /etc/sysconfig/network
네트워크 기본 정보가 설정 되어 있는 파일로 네트워크 사용 여부가 써 있다.  

##### /etc/sysconfig/network-scripts/ifcfg-ens32(또는 ifcfg-ens33)
ens32 장치에 설정 된 네트워크 정보가 모두 들어 있는 파일이다.  

##### /etc/resolv.conf
DNS 서버의 정보와 호스트 이름이 들어 있는 파일이다. 

##### /etc/hosts
한 컴퓨터의 호스트 이름과 FQDN이 들어 있는 파일이다.  

#### 네트워크 보안을 위한 SELinux
SELinux(Security Enhanced Linux)는 보안에 취약한 리눅스를 보호하기 위해 탄생했다.  
시스템에서 보안에 영향을 미치는 서비스, 권한 등을 제어할 수 있다.  

SELinux의 사용 여부는 강제(enforcing), 허용(permissive), 비활성(disabled)라는 3가지 레벨을 지원합니다.  
설정 파일은 /etc/sysconfig/selinux 파일이다.  
CentOS 7을 설치하면 기본적으로 강제(enforcing)로 설정 되어 있다.  

##### 강제
강제는 시스템 보안에 영향을 미치는 기능이 감지되면, 그 기능이 작동되지 않도록 시스템에서 막아준다.   

##### 허용
허용은 하되 사용 내용이 로그로 남고, 화면상에도 출력 된다.  

##### 비활성
SELinux를 사용하지 않는 것이어서 당연히 보안에는 취약해 진다.  

## 파이프, 필터, 리다이렉션

### 파이프
파이프(Pipe)는 2개의 프로그램을 연결해주는 연결 통로를 의미한다.  
'|'를 사용함(Shift + \ 를 누른 글자)  
- ls -l /etc | more : 'ls -l /etc'를 입력하면 파일이 너무 많아서, 1페이지에 모두 담을 수 없으므로 1페이지씩 나눠서 보겠다는 의미다.  

### 필터
필터(Filter)는 필요한 것만 걸러주는 명령어다.  
'grep', 'tail', 'we', 'sort', 'awk', 'sed' 명령어 등이 있다.  
주로 파이프와 같이 사용 된다.  
- ps -ef | grep bash : 'ps -ef'를 입력하면 모든 프로세스 번호를 출력하므로, bash라는 글자가 들어간 프로세스만 출력하게 된다.  

### 리다이렉션
리다이렉션(Redirection)은 표준입출력의 방향을 바꿔준다.  
표준 입력은 키보드, 표준 출력은 뫼터이지만 이를 파일로 처리하고 싶을 때 주로 사용한다.  
- ls -l > list.txt : 'ls -l'의 결과를 화면에 출력하지 말고, list.txt 파일에 저장한다. 만약, list.txt 파일이 기존에 있으면 덮어 쓴다.  
- ls -l > list.txt : 'ls -l'의 결과를 화면에 출력하지 말고, list.txt 파일에 저장한다. 만약, list.txt 파일이 기존에 있으면 덮어 쓴다.  
- sort < list.txt : list.txt 파일을 정렬해서 화면에 출력
- sort < list.txt > out.txt : list.txt 파일을 정렬해서 out.txt 파일에 쓴다.  

## 프로세스, 데몬, 서비스

### 프로세스
하드디스크에 저장된 실행 코드(프로그램)가, 메모리에 로딩되어 활성화된 것 정도로 설명할 수 있다.  

#### 포그라운드 프로세스
실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스이다.  
화면에서 실행되는 것이 프로세스라고 생각하면 된다.  

#### 백그라운드 프로세스
실행은 되었지만, 화면에는 나타나지 않고 뒤에서 실행되는 프로세스를 말한다.  
바이러스 백신, 서버 데몬 등은 눈에는 보이지 않지만 실행되는 것이다.  

#### 프로세스 번호
프로세스 번호가 필요한 이유는 메모리에서 활성화 된 프로세스를 메모리에서 강제로 제거하려면 프로세스 번호를 사용해야 하기 때문이다.  

#### 직업 번호
현재 실행되는 백그라운드 프로세스의 순차 번호를 의미한다.  

#### 부모 프로세스와 자식 프로세스
모든 프로세스는 혼자서 독립적으로 실행되는 것이 아니라, 부모 프로세스의 하위에 종속되어 실행된다.  

#### 명령어
- ps : 현재 프로세스의 상태를 확인하는 명령어로, 많은 옵션과 함께 사용될 수 있다.(ps -ef | grep 프로세스이름)
- kill : 프로세스를 강제로 종료하는 명령어로, '-9' 옵션과 함께 사용하면 무조건 프로세스가 종료된다. 
- pstree : 부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여준다.
- jobs : 현재 백그라운드로 가동 중인 프로세스를 확인 할 수 있다.
- bg : Ctrl + Z로 일시 중지 된 프로세스를 백그라운드 프로세스롤 계속 실행 한다.
- fg : 백그라운드 프로세스를 포그라운드 프로세스로 만들 수 있다. 
> 명령어 뒤에 붙이는 '&'는 백그라운드로 프로세스를 실행하겠다는 의미다.  

### 서비스
데몬(daemon)이라고도 부르는 서비스(service)는 서버 프로세스를 의미한다.  
서비스는 눈에 보이지 않지만, 현재 시스템에서 동작 중인 프로세스이므로 백그라운드 프로세스의 일종이라고 할 수 있다.  

## 서비스와 소켓
서비스는 평사잇에도 늘 가동하는 서버 프로세스며, 소켓(Socket)은 필요할 때만 작도하는 서버 프로세를 말한다.  
서비스와 소켓은 systemd라고 부르는 서비스 매니저 프로그램으로 작동시키거나 관리한다.  

### 서비스
- 시스템과 독자적으로 구동되어 제공하는 프로세스를 말한다.(웹서버, DB서버, FTP서버 등이 있다)  
- 실행 및 종료는 대게 'systemctl start/stop/restart 서비스이름'으로 사용한다.  
- 서비스 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 '서비스이름.service'라는 이름으로 확인할 수 있다.  
- 부팅과 동시에 서비스를 자동 실행 여부를 지정할 수 있는데, 터미널에 systemctl list-unit-files을 실행하면 현재 사용과 사용 안 함을 확인할 수 있다.  
> 상태가 static으로 설정된 것은 설정할 수 없으며, 다른 서비스나 소켓에 의존해서 실행 되므로 특별히 신경쓰지 않아도 된다.  

#### 명령어
- 서비스 시작/중지/재시작 : systemctl start/stop/restart 서비스이름
- 서비스 상태 확인 : systemctl status 서비스이름
- 서비스 사용/사용 안 함 설정 : systemctl enable/disable 서비스이름

### 소켓
- 서비스는 항상 가동되지만, 소켓은 외부에서 특정 서비스를 요청할 경우에 systemd가 구동 시킨다. 그리고 요청이 끝나면 소켓도 종료된다.
- 그래서 소켓으로 설정된 서비스를 요청할 때는 처음 연결되는시간이 앞에서 설명한 서비스와 비교했을 때 약간 더 걸릴 수 있다.  
- 소켓과 관련된 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 소켓이름.socket이라는 이름으로 존재한다.  

## 응급 복구












---
참조 : [이것이 리눅스다](https://book.naver.com/bookdb/book_detail.nhn?bid=9219952)